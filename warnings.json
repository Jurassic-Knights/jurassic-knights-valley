[{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\assets\\ui\\ui_manifest.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\assets\\ui\\ui_theme.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\audit_assets.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\fix-config-refs.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\locales\\en.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\scripts\\generate_height_maps.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\scripts\\sync-cursor-to-agent.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\scripts\\weapon_import_mapping.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\DebugLoader.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\SystemLoader.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\ai\\AISystem.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'entityManager' is defined but never used.","line":11,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":23,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"entityManager"},"fix":{"range":[281,333],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getConfig' is defined but never used.","line":13,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":34,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"getConfig"},"fix":{"range":[401,412],"text":""},"desc":"Remove unused variable \"getConfig\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Registry' is defined but never used.","line":18,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":18,"endColumn":18,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"Registry"},"fix":{"range":[654,696],"text":""},"desc":"Remove unused import declaration."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * AISystem - Central orchestrator for all AI-driven entities\r\n *\r\n * Routes entity updates to appropriate behavior modules based on entityType.\r\n * Supports: Enemies, Bosses, NPCs, and custom AI types.\r\n *\r\n * Owner: AI System\r\n */\r\n\r\nimport { Logger } from '@core/Logger';\r\nimport { entityManager } from '@core/EntityManager';\r\nimport { EventBus } from '@core/EventBus';\r\nimport { GameConstants, getConfig } from '@data/GameConstants';\r\nimport { EntityTypes } from '@config/EntityTypes';\r\nimport { EnemyAI } from './behaviors/enemies/EnemyAI';\r\nimport { BossAI } from './behaviors/bosses/BossAI';\r\nimport { NPCAI } from './behaviors/npcs/NPCAI';\r\nimport { Registry } from '@core/Registry';\r\nimport type { IGame, IEntity } from '../types/core';\r\n\r\n/** Behavior module with updateState (and optionally triggerPackAggro) */\r\ntype AIBehavior = {\r\n    updateState(entity: IEntity, dt: number): void;\r\n    updateState?(entity: IEntity, hero: IEntity | null, dt: number): void;\r\n    triggerPackAggro?(entity: IEntity, target: IEntity | null): void;\r\n};\r\n\r\nclass AISystem {\r\n    private game: IGame | null = null;\r\n    private behaviors: Record<string, AIBehavior> = {};\r\n\r\n    constructor() {\r\n        Logger.info('[AISystem] Constructed');\r\n    }\r\n\r\n    init(game: IGame): void {\r\n        this.game = game;\r\n        this.registerDefaultBehaviors();\r\n        Logger.info('[AISystem] Initialized');\r\n    }\r\n\r\n    /**\r\n     * Register default behavior handlers\r\n     */\r\n    registerDefaultBehaviors() {\r\n        // Register behavior modules as they load\r\n        if (EnemyAI) this.behaviors['enemy'] = EnemyAI;\r\n        if (BossAI) this.behaviors['boss'] = BossAI;\r\n        if (NPCAI) this.behaviors['npc'] = NPCAI;\r\n    }\r\n\r\n    /**\r\n     * Register a custom behavior module\r\n     * @param {string} type - AI type identifier\r\n     * @param {object} handler - Behavior module with updateState(entity, dt) method\r\n     */\r\n    registerBehavior(type: string, handler: AIBehavior) {\r\n        this.behaviors[type] = handler;\r\n        Logger.info(`[AISystem] Registered behavior: ${type}`);\r\n    }\r\n\r\n    /**\r\n     * Main update loop - processes all AI entities\r\n     */\r\n    update(dt: number) {\r\n        if (!EntityManager) return;\r\n\r\n        const hero = this.game?.hero;\r\n\r\n        // Process enemies\r\n        const enemies = EntityManager.getByType(EntityTypes?.ENEMY_DINOSAUR) || [];\r\n        const soldiers = EntityManager.getByType(EntityTypes?.ENEMY_SOLDIER) || [];\r\n\r\n        for (const enemy of [...enemies, ...soldiers]) {\r\n            if (enemy.active && !enemy.isDead) {\r\n                this.updateEntity(enemy, hero, dt);\r\n            }\r\n        }\r\n\r\n        // Process bosses\r\n        const bosses = EntityManager.getByType('Boss') || [];\r\n        for (const boss of bosses) {\r\n            if (boss.active && !boss.isDead) {\r\n                this.updateEntity(boss, hero, dt, 'boss');\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update a single entity's AI\r\n     */\r\n    updateEntity(entity: IEntity, hero: IEntity | null, dt: number, forceType: string | null = null) {\r\n        // Determine AI type: explicit > entityType-based > default\r\n        const aiType = forceType || entity.aiType || this.getDefaultAIType(entity);\r\n        const behavior = this.behaviors[aiType];\r\n\r\n        if (behavior && typeof behavior.updateState === 'function') {\r\n            // Some behaviors expect (entity, hero, dt), others just (entity, dt)\r\n            if (behavior.updateState.length >= 3) {\r\n                (behavior as { updateState(e: IEntity, h: IEntity | null, d: number): void }).updateState(entity, hero, dt);\r\n            } else {\r\n                behavior.updateState(entity, dt);\r\n            }\r\n        } else if (EnemyAI) {\r\n            // Fallback to generic enemy AI (takes entity, dt)\r\n            EnemyAI.updateState(entity, dt);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get default AI type based on entity properties\r\n     */\r\n    getDefaultAIType(entity: IEntity & { isBoss?: boolean }) {\r\n        if (entity.isBoss) return 'boss';\r\n        if (entity.entityType?.includes('enemy')) return 'enemy';\r\n        if (entity.entityType?.includes('npc')) return 'npc';\r\n        return 'enemy';\r\n    }\r\n\r\n    /**\r\n     * Event listeners for combat events\r\n     */\r\n    initListeners() {\r\n        if (EventBus && GameConstants.Events) {\r\n            EventBus.on(GameConstants.Events.ENTITY_DAMAGED, (data) => this.onEntityDamaged(data));\r\n            EventBus.on(GameConstants.Events.ENTITY_DIED, (data) => this.onEntityDied(data));\r\n        }\r\n    }\r\n\r\n    onEntityDamaged(data: { entity: IEntity & { state?: string; target?: IEntity | null; packAggro?: boolean; groupId?: string | null }; source?: IEntity }) {\r\n        const { entity, source } = data;\r\n        if (!entity) return;\r\n\r\n        // Trigger aggro on damage\r\n        if (entity.state !== 'attack' && entity.state !== 'chase' && source) {\r\n            entity.target = source;\r\n            entity.state = 'chase';\r\n        }\r\n\r\n        // Pack aggro\r\n        if (entity.packAggro && entity.groupId && EnemyAI) {\r\n            EnemyAI.triggerPackAggro(entity, source);\r\n        }\r\n    }\r\n\r\n    onEntityDied(data: { entity: IEntity & { xpReward?: number }; [key: string]: unknown }) {\r\n        const { entity } = data;\r\n        if (!entity) return;\r\n\r\n        entity.state = 'dead';\r\n\r\n        if (EventBus && GameConstants.Events) {\r\n            EventBus.emit(GameConstants.Events.ENEMY_KILLED, {\r\n                enemy: entity,\r\n                xpReward: entity.xpReward,\r\n                lootTableId: entity.lootTableId\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\n// Create and export singleton instance\r\nconst aiSystem = new AISystem();\r\nexport { AISystem, aiSystem };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\ai\\behaviors\\BaseAI.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\ai\\behaviors\\bosses\\BossAI.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Registry' is defined but never used.","line":17,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":17,"endColumn":18,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"Registry"},"fix":{"range":[442,492],"text":""},"desc":"Remove unused import declaration."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * BossAI - Phase-based boss behavior\r\n *\r\n * Extends basic enemy AI with:\r\n * - Health-based phase transitions\r\n * - Special abilities\r\n * - Enrage mechanics\r\n *\r\n * Owner: AI System\r\n */\r\n\r\nimport { Logger } from '../../../core/Logger';\r\nimport { EventBus } from '../../../core/EventBus';\r\nimport { AudioManager } from '../../../audio/AudioManager';\r\nimport { BaseAI } from '../BaseAI';\r\nimport { EnemyAI } from '../enemies/EnemyAI';\r\nimport { Registry } from '../../../core/Registry';\r\nimport { MathUtils } from '../../../core/MathUtils';\r\nimport type { IEntity } from '../../../types/core';\r\n\r\nconst BossAI = {\r\n    /**\r\n     * Update boss AI state\r\n     */\r\n    updateState(boss: IEntity, hero: IEntity | null, dt: number) {\r\n        if (!boss.active || boss.isDead) return;\r\n\r\n        // Update phase based on health\r\n        this.updatePhase(boss);\r\n\r\n        // Update ability cooldowns\r\n        if (boss.abilityCooldown > 0) {\r\n            boss.abilityCooldown -= dt / 1000;\r\n        }\r\n\r\n        // State machine\r\n        switch (boss.state) {\r\n            case 'idle':\r\n            case 'wander':\r\n                this.updateWander(boss, hero, dt);\r\n                break;\r\n            case 'chase':\r\n                this.updateChase(boss, hero, dt);\r\n                break;\r\n            case 'attack':\r\n                this.updateAttack(boss, hero, dt);\r\n                break;\r\n            case 'ability':\r\n                this.updateAbility(boss, hero, dt);\r\n                break;\r\n            case 'returning':\r\n                this.updateReturning(boss, dt);\r\n                break;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Update boss phase based on health percentage\r\n     */\r\n    updatePhase(boss: IEntity) {\r\n        const healthPercent = boss.health / boss.maxHealth;\r\n        const oldPhase = boss.phase || 1;\r\n\r\n        if (healthPercent > 0.66) boss.phase = 1;\r\n        else if (healthPercent > 0.33) boss.phase = 2;\r\n        else boss.phase = 3;\r\n\r\n        // Trigger phase transition effects\r\n        if (boss.phase !== oldPhase) {\r\n            this.onPhaseChange(boss, oldPhase, boss.phase);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Handle phase transition\r\n     */\r\n    onPhaseChange(boss: IEntity, oldPhase: number, newPhase: number) {\r\n        Logger.info(`[BossAI] ${boss.enemyName} entered Phase ${newPhase}`);\r\n\r\n        // Phase-specific buffs\r\n        if (newPhase === 2) {\r\n            boss.speed *= 1.2;\r\n            boss.attackRate *= 1.3;\r\n        } else if (newPhase === 3) {\r\n            // Enrage\r\n            boss.speed *= 1.5;\r\n            boss.damage *= 1.5;\r\n            boss.isEnraged = true;\r\n        }\r\n\r\n        // Emit event for VFX/audio\r\n        if (EventBus) {\r\n            EventBus.emit('BOSS_PHASE_CHANGE', {\r\n                boss,\r\n                oldPhase,\r\n                newPhase\r\n            });\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Use special ability\r\n     */\r\n    updateAbility(boss: IEntity, hero: IEntity | null, dt: number) {\r\n        // Ability execution - can be extended per boss type\r\n        if (boss.currentAbility && boss.abilityTimer > 0) {\r\n            boss.abilityTimer -= dt;\r\n            if (boss.abilityTimer <= 0) {\r\n                this.executeAbility(boss, hero);\r\n                boss.state = 'chase';\r\n                boss.currentAbility = null;\r\n            }\r\n        } else {\r\n            boss.state = 'chase';\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Execute specific ability\r\n     */\r\n    executeAbility(boss: IEntity, hero: IEntity | null) {\r\n        const ability = boss.currentAbility;\r\n        Logger.info(`[BossAI] ${boss.enemyName} uses ${ability}`);\r\n\r\n        if (EventBus) {\r\n            EventBus.emit('BOSS_ABILITY', {\r\n                boss,\r\n                ability,\r\n                target: hero\r\n            });\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Wander (bosses rarely wander, mostly patrol)\r\n     */\r\n    updateWander(boss: IEntity, hero: IEntity | null, dt: number) {\r\n        // Bosses have large aggro range\r\n        if (hero && !hero.isDead && BaseAI?.canSee(boss, hero)) {\r\n            boss.target = hero;\r\n            boss.state = 'chase';\r\n\r\n            if (AudioManager) {\r\n                AudioManager.playSFX('sfx_boss_aggro');\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Slow patrol\r\n        if (EnemyAI) {\r\n            EnemyAI.updateWander(boss, dt);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Chase with ability checks\r\n     */\r\n    updateChase(boss: IEntity, hero: IEntity | null, dt: number) {\r\n        if (!boss.target) {\r\n            boss.state = 'returning';\r\n            return;\r\n        }\r\n\r\n        // Check for ability usage\r\n        if (boss.abilityCooldown <= 0 && boss.abilities?.length > 0) {\r\n            const dist = boss.distanceTo\r\n                ? boss.distanceTo(hero)\r\n                : MathUtils.distance(hero.x, hero.y, boss.x, boss.y);\r\n\r\n            // Random ability at medium range\r\n            if (dist > boss.attackRange * 1.5 && dist < boss.aggroRange) {\r\n                if (Math.random() < 0.3) {\r\n                    this.startAbility(boss);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Standard chase\r\n        if (EnemyAI) {\r\n            EnemyAI.updateChase(boss, dt);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Start an ability\r\n     */\r\n    startAbility(boss: IEntity) {\r\n        const abilities = boss.abilities || [];\r\n        if (abilities.length === 0) return;\r\n\r\n        boss.currentAbility = abilities[Math.floor(Math.random() * abilities.length)];\r\n        boss.abilityTimer = 1000; // 1 second windup\r\n        boss.abilityCooldown = 5; // 5 second cooldown\r\n        boss.state = 'ability';\r\n    },\r\n\r\n    /**\r\n     * Attack (delegated to EnemyAI)\r\n     */\r\n    updateAttack(boss: IEntity, hero: IEntity | null, dt: number) {\r\n        if (EnemyAI) {\r\n            EnemyAI.updateAttack(boss, dt);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Return to spawn\r\n     */\r\n    updateReturning(boss: IEntity, dt: number) {\r\n        if (EnemyAI) {\r\n            EnemyAI.updateReturning(boss, dt);\r\n        }\r\n        // Bosses heal faster when returning\r\n        boss.health = Math.min(boss.health + dt * 0.1, boss.maxHealth);\r\n    }\r\n};\r\n\r\n// ES6 Module Export\r\nexport { BossAI };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\ai\\behaviors\\enemies\\EnemyAI.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Registry' is defined but never used.","line":19,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":18,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"Registry"},"fix":{"range":[638,688],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'dt' is defined but never used. Allowed unused args must match /^_/u.","line":119,"column":34,"nodeType":"Identifier","messageId":"unusedVar","endLine":119,"endColumn":36}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * EnemyAI - Enemy behavior state machine\n *\n * Extracted from Enemy.js for modularity.\n * Handles wander, chase, attack, and returning behaviors.\n *\n * Usage: EnemyAI.updateState(enemy, dt)\n *\n * Owner: Combat System\n */\n\nimport { entityManager } from '../../../core/EntityManager';\nimport { AudioManager } from '../../../audio/AudioManager';\nimport { EventBus } from '../../../core/EventBus';\nimport { GameConstants, getConfig } from '../../../data/GameConstants';\nimport { BiomeConfig } from '../../../data/BiomeConfig';\nimport { EntityTypes } from '../../../config/EntityTypes';\nimport { GameInstance } from '../../../core/Game';\nimport { Registry } from '../../../core/Registry';\nimport { MathUtils } from '../../../core/MathUtils';\nimport type { IEntity } from '../../../types/core';\n\nconst EnemyAI = {\n    /**\n     * Update enemy AI state\n     * @param {Enemy} enemy - The enemy to update\n     * @param {number} dt - Delta time in ms\n     */\n    updateState(enemy: IEntity, dt: number) {\n        if (!enemy.active || enemy.isDead) return;\n\n        switch (enemy.state) {\n            case 'idle':\n            case 'wander':\n                this.updateWander(enemy, dt);\n                break;\n            case 'chase':\n                this.updateChase(enemy, dt);\n                break;\n            case 'attack':\n                this.updateAttack(enemy, dt);\n                break;\n            case 'returning':\n                this.updateReturning(enemy, dt);\n                break;\n        }\n    },\n\n    /**\n     * Wander behavior with aggro detection\n     */\n    updateWander(enemy: IEntity, dt: number) {\n        // Check for hero aggro\n        const hero = entityManager?.getByType('Hero')?.[0] || GameInstance?.hero;\n        if (hero && !hero.isDead && this.canSee(enemy, hero)) {\n            enemy.target = hero;\n            enemy.state = 'chase';\n\n            if (AudioManager) {\n                AudioManager.playSFX('sfx_enemy_aggro');\n            }\n            return;\n        }\n\n        enemy.wanderTimer += dt;\n\n        if (!enemy.wanderTarget || enemy.wanderTimer >= enemy.wanderInterval) {\n            const angle = Math.random() * Math.PI * 2;\n            const dist = Math.random() * enemy.patrolRadius * 0.5;\n            enemy.wanderTarget = {\n                x: enemy.spawnX + Math.cos(angle) * dist,\n                y: enemy.spawnY + Math.sin(angle) * dist\n            };\n            enemy.wanderTimer = 0;\n            // Read wander timers from config for live tuning\n            const cfg = getConfig() as { AI?: { WANDER_TIMER_MIN?: number; WANDER_TIMER_MAX?: number } };\n            const wanderMin = cfg.AI?.WANDER_TIMER_MIN || 2000;\n            const wanderMax = cfg.AI?.WANDER_TIMER_MAX || 5000;\n            enemy.wanderInterval = wanderMin + Math.random() * (wanderMax - wanderMin);\n        }\n\n        if (enemy.wanderTarget) {\n            enemy.moveAlongPath(enemy.wanderTarget.x, enemy.wanderTarget.y, enemy.speed * 0.3, dt);\n        }\n    },\n\n    /**\n     * Chase behavior with leash distance check\n     */\n    updateChase(enemy: IEntity, dt: number) {\n        if (!enemy.target) {\n            enemy.state = 'returning';\n            return;\n        }\n\n        const dist = enemy.distanceTo(enemy.target);\n\n        // Check leash distance\n        const spawnDist = MathUtils.distance(enemy.x, enemy.y, enemy.spawnX, enemy.spawnY);\n        if (spawnDist > enemy.leashDistance) {\n            enemy.state = 'returning';\n            enemy.target = null;\n            return;\n        }\n\n        // Attack if in range\n        if (dist <= enemy.attackRange) {\n            enemy.state = 'attack';\n            return;\n        }\n\n        // Move towards target\n        enemy.moveAlongPath(enemy.target.x, enemy.target.y, enemy.speed, dt);\n    },\n\n    /**\n     * Attack behavior\n     */\n    updateAttack(enemy: IEntity, dt: number) {\n        if (!enemy.target) {\n            enemy.state = 'wander';\n            return;\n        }\n\n        const dist = enemy.distanceTo(enemy.target);\n\n        // Chase if target moved out of range\n        if (dist > enemy.attackRange * 1.2) {\n            enemy.state = 'chase';\n            return;\n        }\n\n        // Attack on cooldown\n        if (enemy.attackCooldown <= 0) {\n            this.performAttack(enemy);\n            enemy.attackCooldown = 1 / enemy.attackRate;\n        }\n    },\n\n    /**\n     * Return to spawn behavior\n     */\n    updateReturning(enemy: IEntity, dt: number) {\n        const dist = MathUtils.distance(enemy.spawnX, enemy.spawnY, enemy.x, enemy.y);\n\n        if (dist < 20) {\n            enemy.state = 'wander';\n            enemy.target = null;\n            enemy.wanderTarget = null;\n            enemy.wanderTimer = 0;\n            enemy.health = enemy.maxHealth;\n            return;\n        }\n\n        enemy.moveAlongPath(enemy.spawnX, enemy.spawnY, enemy.speed * 0.8, dt);\n    },\n\n    /**\n     * Perform attack on target\n     */\n    performAttack(enemy: IEntity) {\n        if (!enemy.target) return;\n\n        if (EventBus && GameConstants?.Events) {\n            EventBus.emit('ENEMY_ATTACK', {\n                attacker: enemy,\n                target: enemy.target,\n                damage: enemy.damage,\n                attackType: enemy.attackType\n            });\n        }\n\n        if (AudioManager) {\n            AudioManager.playSFX('sfx_enemy_attack');\n        }\n\n        if (enemy.target.takeDamage) {\n            enemy.target.takeDamage(enemy.damage, enemy);\n        }\n    },\n\n    /**\n     * Trigger pack aggro for group members\n     */\n    triggerPackAggro(enemy: IEntity, target: IEntity | null) {\n        if (!entityManager || !enemy.groupId) return;\n\n        // Read pack aggro radius from config for live tuning\n        const packRadius =\n            (getConfig() as { AI?: { PACK_AGGRO_RADIUS?: number } }).AI?.PACK_AGGRO_RADIUS ||\n            BiomeConfig?.patrolDefaults?.packAggroRadius ||\n            300;\n\n        const enemies = entityManager\n            .getByType(EntityTypes.ENEMY_DINOSAUR)\n            .concat(entityManager.getByType(EntityTypes.ENEMY_SOLDIER));\n\n        for (const other of enemies) {\n            if (other === enemy || other.groupId !== enemy.groupId) continue;\n            if (other.isDead || !other.packAggro) continue;\n\n            const dist = enemy.distanceTo(other);\n            if (dist <= packRadius) {\n                other.target = target;\n                other.state = 'chase';\n            }\n        }\n\n        if (AudioManager) {\n            AudioManager.playSFX('sfx_pack_aggro');\n        }\n    },\n\n    /**\n     * Check if enemy can see hero (in aggro range)\n     */\n    canSee(enemy: IEntity, hero: IEntity | null) {\n        if (!hero || enemy.isDead) return false;\n        return enemy.distanceTo(hero) <= enemy.aggroRange;\n    }\n};\n\n// ES6 Module Export\nexport { EnemyAI };\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\ai\\behaviors\\npcs\\NPCAI.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'dt' is defined but never used. Allowed unused args must match /^_/u.","line":39,"column":52,"nodeType":"Identifier","messageId":"unusedVar","endLine":39,"endColumn":54},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'dt' is defined but never used. Allowed unused args must match /^_/u.","line":97,"column":56,"nodeType":"Identifier","messageId":"unusedVar","endLine":97,"endColumn":58}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * NPCAI - NPC behavior for merchants, quest givers, and patrol NPCs\r\n *\r\n * Supports:\r\n * - Static (merchants)\r\n * - Patrol routes\r\n * - Dialogue triggers\r\n *\r\n * Owner: AI System\r\n */\r\n\r\nimport { EventBus } from '../../../core/EventBus';\r\nimport { MathUtils } from '../../../core/MathUtils';\r\nimport type { IEntity } from '../../../types/core';\r\n\r\nconst NPCAI = {\r\n    /**\r\n     * Update NPC AI state\r\n     */\r\n    updateState(npc: IEntity, hero: IEntity | null, dt: number) {\r\n        if (!npc.active) return;\r\n\r\n        switch (npc.state) {\r\n            case 'idle':\r\n                this.updateIdle(npc, hero, dt);\r\n                break;\r\n            case 'patrol':\r\n                this.updatePatrol(npc, dt);\r\n                break;\r\n            case 'dialogue':\r\n                this.updateDialogue(npc, hero, dt);\r\n                break;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Idle behavior - check for player proximity\r\n     */\r\n    updateIdle(npc: IEntity, hero: IEntity | null, dt: number) {\r\n        if (!hero) return;\r\n\r\n        const dist = npc.distanceTo\r\n            ? npc.distanceTo(hero)\r\n            : MathUtils.distance(hero.x, hero.y, npc.x, npc.y);\r\n\r\n        // Show interaction prompt when player is close\r\n        const interactRange = npc.interactRadius || 140;\r\n        if (dist <= interactRange) {\r\n            if (!npc.playerNearby) {\r\n                npc.playerNearby = true;\r\n                this.onPlayerApproach(npc, hero);\r\n            }\r\n        } else {\r\n            if (npc.playerNearby) {\r\n                npc.playerNearby = false;\r\n                this.onPlayerLeave(npc);\r\n            }\r\n        }\r\n\r\n        // Face the player when nearby\r\n        if (npc.playerNearby) {\r\n            npc.facingRight = hero.x > npc.x;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Patrol behavior\r\n     */\r\n    updatePatrol(npc: IEntity, dt: number) {\r\n        if (!npc.patrolPoints || npc.patrolPoints.length === 0) {\r\n            npc.state = 'idle';\r\n            return;\r\n        }\r\n\r\n        const target = npc.patrolPoints[npc.patrolIndex || 0];\r\n        const dist = MathUtils.distance(target.x, target.y, npc.x, npc.y);\r\n\r\n        if (dist < 20) {\r\n            // Wait at patrol point\r\n            npc.patrolWait = (npc.patrolWait || 0) + dt;\r\n            if (npc.patrolWait >= (npc.patrolWaitTime || 2000)) {\r\n                npc.patrolWait = 0;\r\n                npc.patrolIndex = ((npc.patrolIndex || 0) + 1) % npc.patrolPoints.length;\r\n            }\r\n        } else {\r\n            // Move to patrol point\r\n            const speed = (npc.speed || 50) * (dt / 1000);\r\n            npc.x += ((target.x - npc.x) / dist) * speed;\r\n            npc.y += ((target.y - npc.y) / dist) * speed;\r\n            npc.facingRight = target.x > npc.x;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Dialogue state (player is interacting)\r\n     */\r\n    updateDialogue(npc: IEntity, hero: IEntity | null, dt: number) {\r\n        // Face the player during dialogue\r\n        if (hero) {\r\n            npc.facingRight = hero.x > npc.x;\r\n        }\r\n        // Dialogue is handled by UI system\r\n    },\r\n\r\n    /**\r\n     * Player approached NPC\r\n     */\r\n    onPlayerApproach(npc: IEntity, hero: IEntity) {\r\n        if (EventBus) {\r\n            EventBus.emit('NPC_PLAYER_NEARBY', {\r\n                npc,\r\n                hero\r\n            });\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Player left NPC range\r\n     */\r\n    onPlayerLeave(npc: IEntity) {\r\n        if (EventBus) {\r\n            EventBus.emit('NPC_PLAYER_LEFT', { npc });\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Start dialogue with NPC\r\n     */\r\n    startDialogue(npc: IEntity) {\r\n        npc.state = 'dialogue';\r\n\r\n        if (EventBus) {\r\n            EventBus.emit('NPC_DIALOGUE_START', { npc });\r\n        }\r\n    },\r\n\r\n    /**\r\n     * End dialogue\r\n     */\r\n    endDialogue(npc: IEntity) {\r\n        npc.state = 'idle';\r\n\r\n        if (EventBus) {\r\n            EventBus.emit('NPC_DIALOGUE_END', { npc });\r\n        }\r\n    }\r\n};\r\n\r\nexport { NPCAI };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\animation\\Tween.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\AudioManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getConfig' is defined but never used.","line":10,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":34,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"getConfig"},"fix":{"range":[215,226],"text":""},"desc":"Remove unused variable \"getConfig\"."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Audio Manager\r\n * Handles all audio playback using Web Audio API\r\n *\r\n * Owner: SFX Engineer\r\n */\r\n\r\nimport { Logger } from '@core/Logger';\r\nimport { EventBus } from '@core/EventBus';\r\nimport { GameConstants, getConfig } from '@data/GameConstants';\r\nimport { SFX } from './SFX_Core';\r\nimport { weatherSystem } from '@systems/WeatherSystem';\r\nimport { AssetLoader } from '@core/AssetLoader';\r\nimport { Registry } from '@core/Registry';\r\nimport { environmentRenderer } from '../rendering/EnvironmentRenderer';\r\n\r\nconst AudioManager = {\r\n    context: null as AudioContext | null,\r\n    masterGain: null as GainNode | null,\r\n    sfxGain: null as GainNode | null,\r\n    musicGain: null as GainNode | null,\r\n    initialized: false,\r\n\r\n    init() {\r\n        // Defer AudioContext creation until user interaction\r\n        document.addEventListener('click', () => this.warmUp(), { once: true });\r\n\r\n        // Listen for Weather\r\n        if (EventBus && GameConstants) {\r\n            EventBus.on(GameConstants.Events.WEATHER_CHANGE, (data: { type: string }) => {\r\n                if (SFX) {\r\n                    SFX.setWeather(data.type);\r\n                }\r\n            });\r\n            EventBus.on(GameConstants.Events.HERO_LEVEL_UP, () => {\r\n                this.playSFX('sfx_level_up');\r\n            });\r\n        }\r\n\r\n        Logger.info('[AudioManager] Waiting for user interaction...');\r\n    },\r\n\r\n    warmUp() {\r\n        if (this.initialized) return;\r\n\r\n        try {\r\n            const AudioCtor = window.AudioContext || (window as unknown as { webkitAudioContext: typeof AudioContext }).webkitAudioContext;\r\n            this.context = new AudioCtor();\r\n\r\n            // Create gain nodes\r\n            this.masterGain = this.context.createGain();\r\n            this.sfxGain = this.context.createGain();\r\n            this.musicGain = this.context.createGain();\r\n\r\n            // Set default volumes\r\n            this.sfxGain.gain.value = 0.7;\r\n            this.musicGain.gain.value = 0.5;\r\n\r\n            // Connect: Source -> Category Gain -> Master -> Destination\r\n            this.sfxGain.connect(this.masterGain);\r\n            this.musicGain.connect(this.masterGain);\r\n            this.masterGain.connect(this.context.destination);\r\n\r\n            // Initialize procedural SFX\r\n            if (SFX) {\r\n                SFX.init(this.context, this.sfxGain);\r\n\r\n                // Sync weather from EnvironmentRenderer (visual source of truth)\r\n                if (environmentRenderer?.weatherType) {\r\n                    SFX.setWeather(environmentRenderer.weatherType);\r\n                } else if (weatherSystem?.currentWeather) {\r\n                    SFX.setWeather(weatherSystem.currentWeather);\r\n                }\r\n            }\r\n\r\n            this.initialized = true;\r\n            Logger.info('[AudioManager] Initialized with SFX');\r\n        } catch (e) {\r\n            Logger.error('[AudioManager] Failed to initialize:', e);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Play a sound effect by ID\r\n     * @param {string} id - Asset ID from registry\r\n     */\r\n    playSFX(id: string) {\r\n        if (!this.initialized) {\r\n            // Try to warm up on first SFX call\r\n            this.warmUp();\r\n            if (!this.initialized) return;\r\n        }\r\n\r\n        // Use procedural synthesis\r\n        if (SFX) {\r\n            SFX.play(id);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Play background music by ID\r\n     * @param {string} id - Asset ID from registry\r\n     */\r\n    playBGM(id: string) {\r\n        if (!this.initialized) return;\r\n\r\n        const config = AssetLoader.getAudio(id);\r\n        if (!config) return;\r\n\r\n        Logger.info(`[AudioManager] Play BGM: ${id}`);\r\n    },\r\n\r\n    /**\r\n     * Set volume for a category\r\n     */\r\n    setVolume(category: string, value: number) {\r\n        const gain =\r\n            category === 'master'\r\n                ? this.masterGain\r\n                : category === 'sfx'\r\n                    ? this.sfxGain\r\n                    : category === 'music'\r\n                        ? this.musicGain\r\n                        : null;\r\n\r\n        if (gain) {\r\n            gain.gain.value = Math.max(0, Math.min(1, value));\r\n        }\r\n    }\r\n};\r\n\r\nif (Registry) Registry.register('AudioManager', AudioManager);\r\n\r\nexport { AudioManager };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFXLoader.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Core.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'volume' is assigned a value but never used. Allowed unused args must match /^_/u.","line":67,"column":64,"nodeType":"Identifier","messageId":"unusedVar","endLine":67,"endColumn":70},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'volume' is assigned a value but never used. Allowed unused args must match /^_/u.","line":95,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":95,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * SFX_Core - Core Sound System\n *\n * Base module with init, play dispatcher, and helper functions.\n * Category-specific sounds are loaded from separate files.\n *\n * ============================================================================\n * SOUND DESIGN RULES - ALL NEW SOUNDS MUST FOLLOW THESE\n * ============================================================================\n * 1. VOLUME: Always use `SFX.TARGET_VOLUME` for peak gain values.\n * 2. HELPERS: Use SFX.playNoise() and SFX.playTone() which auto-apply TARGET_VOLUME.\n * ============================================================================\n */\n\n// Ambient declarations for global dependencies\nimport { Logger } from '@core/Logger';\n\nconst SFX = {\n    ctx: null as AudioContext | null,\n    masterGain: null as GainNode | null,\n    TARGET_VOLUME: 0.5,\n\n    // Sound handlers registry - populated by category files\n    handlers: {} as Record<string, () => void>,\n\n    init(audioContext: AudioContext, masterGain: GainNode) {\n        this.ctx = audioContext;\n        this.masterGain = masterGain;\n        Logger.info('[SFX] Core initialized');\n    },\n\n    /**\n     * Register sound handlers from category modules\n     */\n    register(categoryHandlers: Record<string, () => void>) {\n        Object.assign(this.handlers, categoryHandlers);\n    },\n\n    /**\n     * Play a sound by ID\n     */\n    play(id: string) {\n        if (!this.ctx) return;\n\n        const handler = this.handlers[id];\n        if (handler) {\n            handler.call(this);\n            return;\n        }\n\n        Logger.warn(`[SFX] Unknown sound: ${id}`);\n    },\n\n    // ==================== HELPERS ====================\n\n    createNoise(duration = 0.5) {\n        const sampleRate = this.ctx.sampleRate;\n        const samples = sampleRate * duration;\n        const buffer = this.ctx.createBuffer(1, samples, sampleRate);\n        const data = buffer.getChannelData(0);\n        for (let i = 0; i < samples; i++) {\n            data[i] = Math.random() * 2 - 1;\n        }\n        return buffer;\n    },\n\n    playNoise(duration: number, attack: number, decay: number, volume = 0.3, filterFreq = 2000) {\n        if (!this.ctx) return { noise: null, gain: null, filter: null };\n\n        const noise = this.ctx.createBufferSource();\n        noise.buffer = this.createNoise(duration);\n\n        const filter = this.ctx.createBiquadFilter();\n        filter.type = 'lowpass';\n        filter.frequency.value = filterFreq;\n\n        const gain = this.ctx.createGain();\n        gain.gain.setValueAtTime(0, this.ctx.currentTime);\n        gain.gain.linearRampToValueAtTime(this.TARGET_VOLUME, this.ctx.currentTime + attack);\n        gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + duration);\n\n        noise.connect(filter);\n        filter.connect(gain);\n        gain.connect(this.masterGain);\n\n        noise.start();\n        noise.stop(this.ctx.currentTime + duration);\n        return { noise, gain, filter };\n    },\n\n    playTone(\n        freq: number,\n        duration: number,\n        type: OscillatorType = 'sine',\n        volume = 0.3,\n        attack = 0.01,\n        decay: number | null = null\n    ) {\n        if (!this.ctx) return { osc: null, gain: null };\n\n        const osc = this.ctx.createOscillator();\n        osc.type = type;\n        osc.frequency.value = freq;\n\n        const gain = this.ctx.createGain();\n        gain.gain.setValueAtTime(0, this.ctx.currentTime);\n        gain.gain.linearRampToValueAtTime(this.TARGET_VOLUME, this.ctx.currentTime + attack);\n        gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + (decay || duration));\n\n        osc.connect(gain);\n        gain.connect(this.masterGain);\n\n        osc.start();\n        osc.stop(this.ctx.currentTime + duration);\n        return { osc, gain };\n    },\n\n    // Weather ambience (stub - implement proper looping ambience later)\n    setWeather(type: string) {\n        Logger.info(`[SFX] Weather ambience: ${type}`);\n        // TODO: Implement looping rain/storm ambience\n    },\n\n    playThunder() {\n        // Low rumbling thunder\n        this.playNoise(1.5, 0.1, 1.2, 0.4, 200);\n    }\n};\n\nexport { SFX };\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Dino_T1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Dino_T1_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Dino_T1_03.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'t' is assigned a value but never used.","line":65,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":65,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * SFX_Dino_Oviraptor - T1_03 Oviraptor Sound Handlers\n * Beaked, feathered, bird-like predator\n */\nimport { SFX } from './SFX_Core';\n\n(function () {\n    const handlers = {\n        sfx_aggro_dinosaur_t1_03: function () {\n            const t = SFX.ctx.currentTime;\n            // Bird-like squawk with frequency modulation\n            const osc = SFX.ctx.createOscillator();\n            osc.type = 'square';\n            osc.frequency.setValueAtTime(550, t);\n            osc.frequency.exponentialRampToValueAtTime(450, t + 0.1);\n            osc.frequency.exponentialRampToValueAtTime(600, t + 0.2);\n            osc.frequency.exponentialRampToValueAtTime(400, t + 0.3);\n\n            const gain = SFX.ctx.createGain();\n            gain.gain.setValueAtTime(0, t);\n            gain.gain.linearRampToValueAtTime(SFX.TARGET_VOLUME * 0.7, t + 0.02);\n            gain.gain.linearRampToValueAtTime(SFX.TARGET_VOLUME * 0.6, t + 0.15);\n            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.35);\n\n            osc.connect(gain);\n            gain.connect(SFX.masterGain);\n            osc.start(t);\n            osc.stop(t + 0.4);\n        },\n        sfx_hurt_dinosaur_t1_03: function () {\n            SFX.playTone(650, 0.15, 'square', SFX.TARGET_VOLUME, 0.01, 0.12);\n        },\n        sfx_death_dinosaur_t1_03: function () {\n            const t = SFX.ctx.currentTime;\n            // Descending warble\n            const osc = SFX.ctx.createOscillator();\n            osc.type = 'square';\n            osc.frequency.setValueAtTime(600, t);\n            osc.frequency.exponentialRampToValueAtTime(200, t + 0.5);\n\n            const lfo = SFX.ctx.createOscillator();\n            lfo.frequency.setValueAtTime(12, t);\n            lfo.frequency.linearRampToValueAtTime(3, t + 0.45);\n            const lfoGain = SFX.ctx.createGain();\n            lfoGain.gain.value = 50;\n            lfo.connect(lfoGain);\n            lfoGain.connect(osc.frequency);\n\n            const gain = SFX.ctx.createGain();\n            gain.gain.setValueAtTime(SFX.TARGET_VOLUME, t);\n            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.55);\n\n            osc.connect(gain);\n            gain.connect(SFX.masterGain);\n            lfo.start(t);\n            osc.start(t);\n            lfo.stop(t + 0.6);\n            osc.stop(t + 0.6);\n        },\n        sfx_spawn_dinosaur_t1_03: function () {\n            SFX.playNoise(0.15, 0.02, 0.1, SFX.TARGET_VOLUME * 0.3, 4000);\n            SFX.playTone(500, 0.2, 'square', SFX.TARGET_VOLUME * 0.4, 0.03, 0.15);\n        },\n        sfx_flee_dinosaur_t1_03: function () {\n            const t = SFX.ctx.currentTime;\n            for (let i = 0; i < 4; i++) {\n                setTimeout(() => {\n                    SFX.playTone(\n                        600 + Math.random() * 100,\n                        0.08,\n                        'square',\n                        SFX.TARGET_VOLUME * 0.5,\n                        0.01,\n                        0.06\n                    );\n                }, i * 60);\n            }\n        }\n    };\n\n    if (SFX) {\n        SFX.register(handlers);\n    }\n})();\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Dino_T1_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Dino_T2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Dino_T2_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Dino_T2_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Dino_T2_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Dino_T2_05.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Dino_T3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Dino_T3_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Dino_T3_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Dino_T3_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Dino_T4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Dino_T4_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Dino_T4_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Enemies.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Herbivore_T1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Herbivore_T1_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Herbivore_T1_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Herbivore_T2.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Herbivore_T3.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Herbivore_T4.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Herbivores.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Human_T1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Human_T1_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Human_T1_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Human_T2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Human_T2_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Human_T2_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Human_T3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Human_T3_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Human_T3_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Human_T4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Human_T4_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Human_T4_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Resources.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Saurian_T1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Saurian_T1_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Saurian_T1_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Saurian_T2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Saurian_T2_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Saurian_T2_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Saurian_T3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Saurian_T3_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Saurian_T3_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Saurian_T3_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Saurian_T4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Saurian_T4_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_Shared.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SFX_UI.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\audio\\SoundRegistry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\components\\AIComponent.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\components\\CollisionComponent.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\components\\CombatComponent.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\components\\HealthComponent.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\components\\InventoryComponent.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\components\\StatsComponent.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'GameConstants' is defined but never used.","line":16,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":16,"endColumn":23,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"GameConstants"},"fix":{"range":[385,399],"text":""},"desc":"Remove unused variable \"GameConstants\"."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * StatsComponent\r\n * managed generic RPG stats for an entity (Hero, Dinosaur, Army Unit).\r\n *\r\n * Properties:\r\n * - Speed (Movement)\r\n * - Stamina (Action points)\r\n * - CritChance (Combat)\r\n * - Defense (Mitigation)\r\n * - Attack (03-hero-stats)\r\n * - Level/XP (03-hero-stats)\r\n */\r\nimport { Component } from '@core/Component';\r\nimport { Logger } from '@core/Logger';\r\n\r\nimport { GameConstants, getConfig } from '@data/GameConstants';\r\nimport { getWeaponStats } from '@data/GameConfig';\r\nimport type { IEntity, CombatComponent } from '../types/core';\r\n\r\ninterface StatsComponentConfig {\r\n    speed?: number;\r\n    maxStamina?: number;\r\n    stamina?: number;\r\n    critChance?: number;\r\n    defense?: number;\r\n    attack?: number;\r\n    critMultiplier?: number;\r\n    level?: number;\r\n    xp?: number;\r\n    xpToNextLevel?: number;\r\n    xpScaling?: number;\r\n    strength?: number;\r\n    dexterity?: number;\r\n    constitution?: number;\r\n    intelligence?: number;\r\n}\r\n\r\nclass StatsComponent extends Component {\r\n    type: string = 'StatsComponent';\r\n    speed: number = 100;\r\n    maxStamina: number = 100;\r\n    stamina: number = 100;\r\n    critChance: number = 0;\r\n    defense: number = 0;\r\n    attack: number = 10;\r\n    critMultiplier: number = 1.5;\r\n    level: number = 1;\r\n    xp: number = 0;\r\n    xpToNextLevel: number = 100;\r\n    get nextLevelXp(): number { return this.xpToNextLevel; }\r\n    set nextLevelXp(val: number) { this.xpToNextLevel = val; }\r\n    strength: number = 10;\r\n    dexterity: number = 10;\r\n    constitution: number = 10;\r\n    intelligence: number = 10;\r\n    xpScaling: number = 1.5;\r\n\r\n    constructor(parent: IEntity | null, config: StatsComponentConfig = {}) {\r\n        super(parent);\r\n        this.type = 'StatsComponent';\r\n\r\n        this.speed = config.speed || 100;\r\n        this.maxStamina = config.maxStamina || 100;\r\n        this.stamina = config.stamina !== undefined ? config.stamina : this.maxStamina;\r\n        this.critChance = config.critChance || 0;\r\n        this.defense = config.defense || 0;\r\n        this.attack = config.attack || 10;\r\n        this.critMultiplier = config.critMultiplier || 1.5;\r\n        this.level = config.level || 1;\r\n        this.xp = config.xp || 0;\r\n        this.xpToNextLevel = config.xpToNextLevel || 100;\r\n        this.xpScaling = config.xpScaling || 1.5;\r\n\r\n        Logger.info(`[StatsComponent] Attached to ${parent.constructor.name}`);\r\n    }\r\n\r\n    // consumeStamina & restoreStamina moved to HeroSystem\r\n\r\n    getSpeed(multiplier: number = 1) {\r\n        // Always read from config for live updates\r\n        const configSpeed = getConfig().Hero?.SPEED || this.speed;\r\n        return configSpeed * multiplier;\r\n    }\r\n\r\n    getXPForLevel(targetLevel: number) {\r\n        return Math.floor(this.xpToNextLevel * Math.pow(this.xpScaling, targetLevel - 1));\r\n    }\r\n\r\n    getTotalXPForLevel(targetLevel: number) {\r\n        let total = 0;\r\n        for (let i = 1; i < targetLevel; i++) {\r\n            total += this.getXPForLevel(i);\r\n        }\r\n        return total;\r\n    }\r\n\r\n    getAttack() {\r\n        const base = this.attack + (this.level - 1) * 2;\r\n        const equipBonus = this.parent.equipment?.getStatBonus('damage') || 0;\r\n        return base + equipBonus;\r\n    }\r\n\r\n    getDefense() {\r\n        const base = this.defense + (this.level - 1) * 1;\r\n        const equipBonus = this.parent.equipment?.getStatBonus('armor') || 0;\r\n        return base + equipBonus;\r\n    }\r\n\r\n    getCritChance() {\r\n        const base = this.critChance * 100;\r\n        const equipBonus = this.parent.equipment?.getStatBonus('critChance') || 0;\r\n        return base + equipBonus;\r\n    }\r\n\r\n    getAttackRange() {\r\n        // Base hand range + equipment bonuses\r\n        const baseRange = getConfig().Combat.DEFAULT_MINING_RANGE;\r\n        const equipBonus = this.parent.equipment?.getStatBonus('range') || 0;\r\n        return baseRange + equipBonus;\r\n    }\r\n\r\n    getWeaponRange(slotId: string) {\r\n        // Use additive model: base + entity bonus\r\n        const item = this.parent.equipment?.getSlot?.(slotId);\r\n        if (!item) return getConfig().Combat.DEFAULT_MINING_RANGE;\r\n        const stats = getWeaponStats(item);\r\n        return stats.range;\r\n    }\r\n\r\n    getAttackRate() {\r\n        const combat = this.parent?.components?.combat as CombatComponent | undefined;\r\n        const base = combat?.attackSpeed || 1.0;\r\n        const equipBonus = this.parent?.equipment?.getStatBonus('attackRate') || 0;\r\n        return base + equipBonus;\r\n    }\r\n\r\n    getDamageReduction(incomingDamage: number) {\r\n        const divisor = getConfig().Combat?.ARMOR_FORMULA_DIVISOR || 100;\r\n        const reduction = this.getDefense() / (this.getDefense() + divisor);\r\n        return Math.floor(incomingDamage * (1 - reduction));\r\n    }\r\n\r\n    getXPProgress() {\r\n        const required = this.getXPForLevel(this.level);\r\n        return this.xp / required;\r\n    }\r\n\r\n    getStat(name: string): number {\r\n        const value = (this as Record<string, unknown>)[name];\r\n        return typeof value === 'number' ? value : 0;\r\n    }\r\n}\r\n\r\nexport { StatsComponent };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\config\\AssetManifest.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\config\\BodyTypeConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\config\\BossConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\config\\ColorPalette.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\config\\EnemyConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\config\\EntityConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\config\\EntityTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\config\\EquipmentSlotsConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\config\\EquipmentStatsConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\config\\Events.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\config\\HeroDefaults.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\config\\RenderConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\config\\SetBonusesConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\config\\SpeciesScaleConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\config\\SystemConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\config\\WorldTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\core\\AnalyticsManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":75,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":75,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":96,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":96,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":113,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":113,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":130,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":130,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Analytics - Game analytics wrapper using GameAnalytics SDK\r\n *\r\n * Free tier: Unlimited events\r\n * Dashboard: https://gameanalytics.com\r\n *\r\n * Setup:\r\n * 1. Create account at gameanalytics.com\r\n * 2. Add game, get Game Key and Secret Key\r\n * 3. Set keys in ANALYTICS_CONFIG below\r\n */\r\n\r\nconst ANALYTICS_CONFIG = {\r\n    enabled: false, // Enable when ready for production data\r\n    gameKey: '8ac6be4add5322270364152da68e97ca',\r\n    secretKey: 'cdc6600ca0727e16cc74f30d23c520a07918f04c',\r\n    build: '1.0.0'\r\n};\r\n\r\nimport { Logger } from '@core/Logger';\r\nimport { Registry } from '@core/Registry';\r\n\r\nconst Analytics = {\r\n    initialized: false,\r\n\r\n    /**\r\n     * Initialize analytics (called once on game start)\r\n     */\r\n    init() {\r\n        if (!ANALYTICS_CONFIG.enabled) {\r\n            Logger.info('[Analytics] Disabled - set keys in AnalyticsManager.js');\r\n            return;\r\n        }\r\n\r\n        // Load GameAnalytics SDK\r\n        if (!gameanalytics) {\r\n            Logger.warn('[Analytics] GameAnalytics SDK not loaded');\r\n            return;\r\n        }\r\n\r\n        try {\r\n            gameanalytics.GameAnalytics.configureBuild(ANALYTICS_CONFIG.build);\r\n            gameanalytics.GameAnalytics.initialize(\r\n                ANALYTICS_CONFIG.gameKey,\r\n                ANALYTICS_CONFIG.secretKey\r\n            );\r\n            this.initialized = true;\r\n            Logger.info('[Analytics] Initialized');\r\n        } catch (e) {\r\n            Logger.error('[Analytics] Failed to initialize:', e);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Track game progression (level complete, boss killed, etc.)\r\n     */\r\n    trackProgression(status: string, area: string, step: string | null = null) {\r\n        if (!this.initialized) return;\r\n\r\n        // status: 'Start', 'Complete', 'Fail'\r\n        // area: 'Zone_Grasslands', 'Boss_Alpha', etc.\r\n        try {\r\n            if (step) {\r\n                gameanalytics.GameAnalytics.addProgressionEvent(\r\n                    gameanalytics.EGAProgressionStatus[status],\r\n                    area,\r\n                    step\r\n                );\r\n            } else {\r\n                gameanalytics.GameAnalytics.addProgressionEvent(\r\n                    gameanalytics.EGAProgressionStatus[status],\r\n                    area\r\n                );\r\n            }\r\n        } catch (e) {\r\n            /* ignore */\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Track resource/economy events (gold earned, items crafted)\r\n     */\r\n    trackResource(flowType: string, currency: string, amount: number, itemType: string, itemId: string) {\r\n        if (!this.initialized) return;\r\n\r\n        // flowType: 'Source' (earned) or 'Sink' (spent)\r\n        // currency: 'gold', 'gems', etc.\r\n        try {\r\n            gameanalytics.GameAnalytics.addResourceEvent(\r\n                gameanalytics.EGAResourceFlowType[flowType],\r\n                currency,\r\n                amount,\r\n                itemType,\r\n                itemId\r\n            );\r\n        } catch (e) {\r\n            /* ignore */\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Track custom design events\r\n     */\r\n    trackEvent(eventId: string, value: number | null = null) {\r\n        if (!this.initialized) return;\r\n\r\n        try {\r\n            if (value !== null) {\r\n                gameanalytics.GameAnalytics.addDesignEvent(eventId, value);\r\n            } else {\r\n                gameanalytics.GameAnalytics.addDesignEvent(eventId);\r\n            }\r\n        } catch (e) {\r\n            /* ignore */\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Track errors\r\n     */\r\n    trackError(severity: string, message: string) {\r\n        if (!this.initialized) return;\r\n\r\n        // severity: 'Debug', 'Info', 'Warning', 'Error', 'Critical'\r\n        try {\r\n            gameanalytics.GameAnalytics.addErrorEvent(\r\n                gameanalytics.EGAErrorSeverity[severity],\r\n                message\r\n            );\r\n        } catch (e) {\r\n            /* ignore */\r\n        }\r\n    }\r\n};\r\n\r\nif (Registry) Registry.register('Analytics', Analytics);\r\n\r\n// ES6 Module Export\r\nexport { Analytics };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\core\\AssetLoader.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\core\\AssetLoaderPathPatterns.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\core\\Component.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\core\\DOMUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\core\\Entity.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'oldMax' is assigned a value but never used.","line":128,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":128,"endColumn":29}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Entity - Base class for all game objects\r\n *\r\n * Owner: Director\r\n */\r\n\r\nimport { RenderConfig } from '@config/RenderConfig';\r\nimport { MaterialLibrary } from '@vfx/MaterialLibrary';\r\nimport { AssetLoader } from './AssetLoader';\r\nimport { environmentRenderer } from '../rendering/EnvironmentRenderer';\r\nimport { Registry } from './Registry';\r\nimport { CollisionComponent } from '../components/CollisionComponent';\r\nimport type { EntityConfig, IEntity } from '../types/core';\r\n\r\nclass Entity implements IEntity {\r\n    // Class properties\r\n    id: string;\r\n    entityType: string;\r\n    x: number;\r\n    y: number;\r\n    width: number;\r\n    height: number;\r\n    color: string;\r\n    sprite: string | null;\r\n    active: boolean;\r\n    islandGridX?: number;\r\n    islandGridY?: number;\r\n    scale: number = 1;\r\n\r\n    // Physics State for Interpolation\r\n    prevX: number;\r\n    prevY: number;\r\n\r\n    // Components\r\n    collision?: CollisionComponent;\r\n\r\n    /** IEntity interface compliance - returns entityType */\r\n    get type(): string {\r\n        return this.entityType;\r\n    }\r\n\r\n    /**\r\n     * Create an entity\r\n     * @param {EntityConfig} config - Entity configuration\r\n     */\r\n    constructor(config: EntityConfig = {}) {\r\n        this.id = config.id || `entity_${Date.now()}`;\r\n        this.entityType = config.entityType || 'entity'; // For type checking instead of constructor.name\r\n        this.x = config.x || 0;\r\n        this.y = config.y || 0;\r\n        this.width = config.width || 32;\r\n        this.height = config.height || 32;\r\n        this.color = config.color || '#888888';\r\n        this.sprite = config.sprite || null; // Asset ID\r\n        this.active = true;\r\n\r\n        // Grid coordinates (optional)\r\n        if (config.islandGridX !== undefined) this.islandGridX = config.islandGridX;\r\n        if (config.islandGridY !== undefined) this.islandGridY = config.islandGridY;\r\n\r\n        this.prevX = this.x;\r\n        this.prevY = this.y;\r\n\r\n        if (config.collision) {\r\n            // Auto-sync collision bounds with entity size if not explicitly set\r\n            this.collision = new CollisionComponent({\r\n                ...config.collision,\r\n                bounds: {\r\n                    width: this.width,\r\n                    height: this.height, // Default to visual size\r\n                    offsetX: 0,\r\n                    offsetY: 0,\r\n                    ...(config.collision.bounds || {}) // Allow override\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Refresh configuration from Registry (HMR/Live Update)\r\n     */\r\n    refreshConfig() {\r\n        // Resolve latest config from Registry\r\n        // Use type assertion to avoid circular dependency - EntityLoader is registered as ISystem\r\n        const EntityLoader = Registry.get('EntityLoader') as { getConfig?: (id: string) => Record<string, unknown> } | null;\r\n\r\n        if (EntityLoader?.getConfig) {\r\n            // use id or sprite (many props use sprite as ID)\r\n            const lookupId = this.id || this.sprite || '';\r\n            const registryConfig = EntityLoader.getConfig(lookupId) || {};\r\n\r\n            // 1. Update Dimensions (Async)\r\n            import('../utils/EntityScaling').then(({ EntityScaling }) => {\r\n                EntityScaling.applyToEntity(this, {}, registryConfig, { width: 32, height: 32 });\r\n            });\r\n\r\n            // 2. Update Gameplay Stats (Safe subset)\r\n            const SAFE_KEYS = [\r\n                'speed', 'damage', 'defense', 'attackRange', 'attackRate',\r\n                'aggroRange', 'leashDistance', 'respawnTime', 'xpReward',\r\n                'lootTable', 'tier', 'groupSize', 'spawnWeight'\r\n            ] as const;\r\n\r\n            const entityRecord = this as Record<string, unknown>;\r\n            for (const key of SAFE_KEYS) {\r\n                if (key in registryConfig) {\r\n                    const value = registryConfig[key];\r\n                    if (value !== undefined) {\r\n                        entityRecord[key] = value;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // 3. Update 'stats' object deeply if it exists\r\n            if (registryConfig.stats && typeof registryConfig.stats === 'object' && registryConfig.stats !== null) {\r\n                if (!entityRecord.stats || typeof entityRecord.stats !== 'object') {\r\n                    entityRecord.stats = {};\r\n                }\r\n                Object.assign(entityRecord.stats as Record<string, unknown>, registryConfig.stats);\r\n            }\r\n\r\n            // 4. Handle Health/MaxHealth specially\r\n            // Update Max Health\r\n            const healthValue = registryConfig.maxHealth || registryConfig.health || \r\n                (registryConfig.stats && typeof registryConfig.stats === 'object' && 'health' in registryConfig.stats \r\n                    ? (registryConfig.stats as Record<string, unknown>).health : undefined);\r\n            if (typeof healthValue === 'number' && healthValue > 0) {\r\n                const oldMax = (typeof entityRecord.maxHealth === 'number' ? entityRecord.maxHealth : \r\n                    (typeof entityRecord.health === 'number' ? entityRecord.health : 100));\r\n                entityRecord.maxHealth = healthValue;\r\n\r\n                    // If health was full, keep it full. If not, maybe scale it? \r\n                    // Simple rule: If current health > new max, clamp it.\r\n                    // If max increased, maybe heal? For now, just clamp.\r\n                    if (typeof entityRecord.health === 'number' && entityRecord.health > healthValue) {\r\n                        entityRecord.health = healthValue;\r\n                    }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draw a generic drop shadow under the entity\r\n     * @param {CanvasRenderingContext2D} ctx\r\n     */\r\n    drawShadow(ctx: CanvasRenderingContext2D, forceOpaque = false) {\r\n        if (!this.active) return;\r\n\r\n        // Check for RenderConfig before using (fallback for safety)\r\n        if (RenderConfig && RenderConfig.Hero) {\r\n            const shadowWidth = this.width * (RenderConfig.Hero.SHADOW_SCALE_X || 0.5);\r\n            const shadowHeight = shadowWidth * (RenderConfig.Hero.SHADOW_SCALE_Y || 0.3);\r\n            const yOffset = RenderConfig.Hero.SHADOW_OFFSET_Y || -5;\r\n\r\n            ctx.save();\r\n            // If forcing opaque (shadow pass), use fully opaque black\r\n            if (forceOpaque) {\r\n                ctx.fillStyle = 'black';\r\n                ctx.globalAlpha = 1.0;\r\n            } else {\r\n                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';\r\n            }\r\n\r\n            ctx.beginPath();\r\n            ctx.ellipse(\r\n                this.x,\r\n                this.y + this.height / 2 + yOffset,\r\n                shadowWidth / 2,\r\n                shadowHeight / 2,\r\n                0,\r\n                0,\r\n                Math.PI * 2\r\n            );\r\n            ctx.fill();\r\n            ctx.restore();\r\n            return;\r\n        }\r\n\r\n        // Check environmentRenderer singleton for dynamic shadows\r\n        const env = environmentRenderer;\r\n\r\n        // Default values if system missing\r\n        let scaleY = 0.3;\r\n        let alpha = 0.3;\r\n\r\n        if (env) {\r\n            scaleY = env.shadowScaleY;\r\n            alpha = env.shadowAlpha;\r\n        }\r\n\r\n        // Shadow dimensions based on entity size\r\n        // Using this.width and this.height directly in calculations below\r\n\r\n        // 1. Static Contact Shadow (Grounding Circle)\r\n        ctx.save();\r\n        ctx.translate(this.x, this.y + this.height / 2 - 6); // Nudge up\r\n\r\n        if (forceOpaque) {\r\n            ctx.fillStyle = 'black';\r\n            ctx.globalAlpha = 1.0;\r\n        } else {\r\n            ctx.fillStyle = 'black';\r\n            ctx.globalAlpha = alpha;\r\n        }\r\n\r\n        const contactWidth = this.width * 0.6;\r\n        const contactHeight = this.height * 0.15; // Flat oval\r\n\r\n        ctx.beginPath();\r\n        ctx.ellipse(0, 0, contactWidth / 2, contactHeight / 2, 0, 0, Math.PI * 2);\r\n        ctx.fill();\r\n        ctx.restore();\r\n\r\n        // 2. Dynamic Projected Shadow\r\n        ctx.save();\r\n\r\n        // Position at feet (Pivot Point)\r\n        ctx.translate(this.x, this.y + this.height / 2 - 6); // Nudge up\r\n\r\n        // Apply Skew (Sun Direction)\r\n        const skew = env ? env.shadowSkew || 0 : 0;\r\n        // Skew X: transform(1, 0, skew, 1, 0, 0)\r\n        ctx.transform(1, 0, skew, 1, 0, 0);\r\n\r\n        // Apply Dynamic Transform\r\n        // 1. Scale Y to squash/stretch\r\n        // 2. Flip Y (-scaleY) to project downwards (away from feet) from the pivot\r\n        ctx.scale(1, -scaleY);\r\n\r\n        // Draw Shadow (Silhouette)\r\n        if (forceOpaque) {\r\n            ctx.globalAlpha = 1.0;\r\n        } else {\r\n            ctx.globalAlpha = alpha;\r\n        }\r\n\r\n        // Optimize: Use cached silhouette from MaterialLibrary if available\r\n        let shadowImg: HTMLCanvasElement | HTMLImageElement | null = null;\r\n        if (this.sprite && MaterialLibrary) {\r\n            shadowImg = MaterialLibrary.get(this.sprite, 'shadow');\r\n        }\r\n\r\n        if (shadowImg) {\r\n            // Draw cached shadow silhouette\r\n            // Anchor at bottom (feet) so it projects \"up\" into the negative Y space\r\n            // which is flipped to positive Y (shadow on ground) by scale(1, -scaleY)\r\n            ctx.drawImage(shadowImg, -this.width / 2, -this.height, this.width, this.height);\r\n        } else if (this.sprite && AssetLoader) {\r\n            // Fallback: simple oval logic if sprite not ready\r\n        } else {\r\n            // Fallback oval - skip\r\n        }\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    /**\r\n     * Update entity (override in subclass)\r\n     * @param {number} dt - Delta time in ms\r\n     */\r\n    update(_dt: number) {\r\n        // Override in subclass\r\n    }\r\n\r\n    /**\r\n     * Render entity\r\n     * @param {CanvasRenderingContext2D} ctx\r\n     */\r\n    render(ctx: CanvasRenderingContext2D) {\r\n        if (!this.active) return;\r\n\r\n        // Draw sprite if available, else colored rectangle\r\n        if (this.sprite && AssetLoader) {\r\n            const img = AssetLoader.getImage(this.sprite);\r\n            if (img) {\r\n                ctx.drawImage(\r\n                    img,\r\n                    this.x - this.width / 2,\r\n                    this.y - this.height / 2,\r\n                    this.width,\r\n                    this.height\r\n                );\r\n                return;\r\n            }\r\n        }\r\n\r\n        // Fallback: colored rectangle\r\n        ctx.fillStyle = this.color;\r\n        ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);\r\n    }\r\n\r\n    /**\r\n     * Get bounding box for collision detection\r\n     * @returns {{x: number, y: number, width: number, height: number}}\r\n     */\r\n    getBounds() {\r\n        return {\r\n            x: this.x - this.width / 2,\r\n            y: this.y - this.height / 2,\r\n            width: this.width,\r\n            height: this.height\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Check collision with another entity\r\n     * @param {Entity} other\r\n     * @returns {boolean}\r\n     */\r\n    collidesWith(other: IEntity & { getBounds(): { x: number; y: number; width: number; height: number } }) {\r\n        const a = this.getBounds();\r\n        const b = other.getBounds();\r\n\r\n        return (\r\n            a.x < b.x + b.width &&\r\n            a.x + a.width > b.x &&\r\n            a.y < b.y + b.height &&\r\n            a.y + a.height > b.y\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get distance to another entity\r\n     * @param {IEntity} other\r\n     * @returns {number}\r\n     */\r\n    distanceTo(other: IEntity) {\r\n        const dx = other.x - this.x;\r\n        const dy = other.y - this.y;\r\n        return Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n}\r\n\r\n// ES6 Module Export\r\nexport { Entity };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\core\\EntityManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\core\\EventBus.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\core\\Game.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getConfig' is defined but never used.","line":8,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":34,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"getConfig"},"fix":{"range":[176,187],"text":""},"desc":"Remove unused variable \"getConfig\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'EntityLoader' is defined but never used.","line":9,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":22,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"EntityLoader"},"fix":{"range":[219,273],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'EventBus' is defined but never used.","line":16,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":16,"endColumn":18,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"EventBus"},"fix":{"range":[515,553],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":109,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":109,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4172,4175],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4172,4175],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":111,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4260,4263],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4260,4263],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":121,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":121,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4665,4668],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4665,4668],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":260,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":260,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9368,9371],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9368,9371],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":265,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":265,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9597,9600],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9597,9600],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'alpha' is assigned a value but never used. Allowed unused args must match /^_/u.","line":285,"column":12,"nodeType":"Identifier","messageId":"unusedVar","endLine":285,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Game - Main game loop and orchestration\r\n *\r\n * Owner: Director\r\n */\r\nimport { Logger } from './Logger';\r\nimport { Registry } from './Registry';\r\nimport { GameConstants, getConfig } from '@data/GameConstants';\r\nimport { EntityLoader } from '@entities/EntityLoader';\r\nimport { entityManager } from './EntityManager';\r\nimport { GameState } from './State';\r\nimport { Hero } from '../gameplay/Hero';\r\nimport { GameRenderer } from './GameRenderer';\r\n\r\n// Modules that don't exist yet - use ambient declarations\r\nimport { EventBus } from './EventBus';\r\nimport { SystemConfig } from '@config/SystemConfig';\r\nimport { Tween } from '../animation/Tween';\r\n\r\nimport { logProfileResults } from './GameProfile';\r\nimport { MerchantUI } from '@ui/MerchantUI';\r\nimport { VFXController } from '@vfx/VFXController';\r\nimport type { ISystem, IEntity } from '../types/core';\r\n\r\nclass Game {\r\n    private isRunning: boolean = false;\r\n    private lastTime: number = 0;\r\n    private tickRate: number;\r\n    private accumulator: number = 0;\r\n    private _hero: Hero | null = null;\r\n    private systems: ISystem[] = [];\r\n    private _boundGameLoop: (timestamp: number) => void;\r\n    private _profile: import('./GameProfile').ProfileData | null = null;\r\n\r\n    constructor() {\r\n        this.tickRate = GameConstants.Core.TICK_RATE_MS;\r\n        this._boundGameLoop = this.gameLoop.bind(this);\r\n    }\r\n\r\n    /**\r\n     * Get a registered system\r\n     * @param {string} name\r\n     */\r\n    getSystem<T extends ISystem>(name: string): T | null {\r\n        if (Registry) {\r\n            const sys = Registry.get(name);\r\n            if (sys) return sys as T;\r\n        }\r\n        return (window as unknown as Record<string, unknown>)[name] as T | null;\r\n    }\r\n\r\n    async init() {\r\n        Logger.info('[Game] Initializing...');\r\n\r\n        // Pre-fetch map data before WorldManager builds, so we avoid flashing default map on refresh\r\n        const { fetchMapData, setPrefetchedMapData } = await import('../world/MapDataService');\r\n        const mapData = await fetchMapData();\r\n        setPrefetchedMapData(mapData);\r\n\r\n        // Debug helper - writes status to loading screen for headless debugging\r\n        const debugStatus = (msg: string) => {\r\n            const loading = document.getElementById('loading');\r\n            if (loading) {\r\n                const p = loading.querySelector('p');\r\n                if (p) p.textContent = msg;\r\n            }\r\n            Logger.info('[Game Debug]', msg);\r\n        };\r\n        debugStatus('Starting initialization...');\r\n\r\n        // 1. Sort Systems by Priority\r\n        // This ensures AssetLoader (-5) runs before GameRenderer (33)\r\n        if (!SystemConfig) {\r\n            Logger.error('[Game] SystemConfig not found! Critical failure.');\r\n            return false;\r\n        }\r\n\r\n        const sortedSystems = [...SystemConfig].sort((a, b) => a.priority - b.priority);\r\n\r\n        // 2. Bootloader Loop (Init Phase)\r\n        Logger.info(`[Game] Booting ${sortedSystems.length} systems...`);\r\n        debugStatus(`Booting ${sortedSystems.length} systems...`);\r\n\r\n        let criticalInitFailed = false;\r\n        for (const config of sortedSystems) {\r\n            const name = config.global;\r\n            let sys;\r\n\r\n            try {\r\n                debugStatus(`Loading: ${name}`);\r\n\r\n                const globalWindow = window as unknown as Record<string, unknown>;\r\n                sys = Registry ? Registry.get(name) : (globalWindow[name] as ISystem);\r\n                if (!sys) sys = globalWindow[name] as ISystem; // Fallback\r\n\r\n                if (!sys) {\r\n                    Logger.warn(`[Game] System not found: ${name}`);\r\n                    debugStatus(`MISSING: ${name}`);\r\n                    continue;\r\n                }\r\n\r\n                // Initialization\r\n                if (config.init) {\r\n                    if (typeof sys.init === 'function') {\r\n                        // Check for Async\r\n                        if (config.isAsync) {\r\n                            Logger.info(`[Game] Awaiting async init: ${name}`);\r\n                            debugStatus(`Awaiting: ${name}...`);\r\n                            await (sys as any).init(this);\r\n                        } else {\r\n                            (sys as any).init(this);\r\n                        }\r\n                        Logger.info(`[Game] Initialized ${name}`);\r\n                        debugStatus(`OK: ${name}`);\r\n                    } else {\r\n                        Logger.warn(`[Game] System ${name} missing init() method`);\r\n                    }\r\n                }\r\n\r\n                // Register for Update Loop\r\n                if (typeof (sys as any).update === 'function') {\r\n                    this.systems.push(sys);\r\n                }\r\n            } catch (err) {\r\n                Logger.error(`[Game] CRITICAL: Failed to initialize ${name}:`, err);\r\n                debugStatus(`ERROR: ${name} - ${(err as Error).message}`);\r\n                Logger.error(`[Game] CRITICAL: ${name} init failed - Stack:`, err);\r\n                if (config.critical) {\r\n                    criticalInitFailed = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (criticalInitFailed) {\r\n            Logger.error('[Game] A critical system failed to initialize. Aborting.');\r\n            return false;\r\n        }\r\n\r\n        // 3. Post-Init Phase (Special Cases)\r\n\r\n        // Tween (External Lib) verification\r\n        if (Tween && !this.systems.includes(Tween)) this.systems.push(Tween);\r\n\r\n        // 4. Start Phase\r\n        Logger.info('[Game] Starting systems...');\r\n        for (const config of sortedSystems) {\r\n            if (config.start) {\r\n                const globalWindow = window as unknown as Record<string, unknown>;\r\n                const sys =\r\n                    (globalWindow[config.global] as ISystem) || (Registry && Registry.get(config.global));\r\n                if (sys && typeof sys.start === 'function') {\r\n                    sys.start();\r\n                    Logger.info(`[Game] Started ${config.global}`);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Hero spawn (replaces SpawnManager.spawnHero)\r\n        this.spawnHero();\r\n\r\n        if (MerchantUI) MerchantUI.init();\r\n        Logger.info('[Game] Boot Complete.');\r\n        return true;\r\n    }\r\n\r\n    private spawnHero(): void {\r\n        try {\r\n            const worldManager = Registry?.get<{ getHeroSpawnPosition: () => { x: number; y: number } }>('WorldManager');\r\n            const gameRenderer = Registry?.get<{ setHero: (h: IEntity) => void; worldWidth?: number; worldHeight?: number }>('GameRenderer');\r\n            const spawn = worldManager?.getHeroSpawnPosition?.() ?? {\r\n                x: GameConstants.World.DEFAULT_SPAWN_X,\r\n                y: GameConstants.World.DEFAULT_SPAWN_Y\r\n            };\r\n            const hero = new Hero({ x: spawn.x, y: spawn.y });\r\n            this._hero = hero;\r\n            if (gameRenderer?.setHero) gameRenderer.setHero(hero as unknown as IEntity);\r\n            entityManager.add(hero);\r\n            const savedGold = GameState.get('gold') as number | undefined;\r\n            if (savedGold !== undefined && savedGold !== null) hero.inventory.gold = savedGold;\r\n            Logger.info('[Game] Hero spawned at', spawn.x, spawn.y);\r\n        } catch (err) {\r\n            Logger.error('[Game] Failed to spawn hero:', err);\r\n        }\r\n    }\r\n\r\n    /** Start the game loop */\r\n    start() {\r\n        if (this.isRunning) return;\r\n\r\n        this.isRunning = true;\r\n        this.lastTime = performance.now();\r\n        this.loop();\r\n        Logger.info('[Game] Started');\r\n    }\r\n\r\n    /**\r\n     * Stop the game loop\r\n     */\r\n    stop() {\r\n        this.isRunning = false;\r\n        Logger.info('[Game] Stopped');\r\n    }\r\n\r\n    /**\r\n     * Main game loop\r\n     */\r\n    loop() {\r\n        if (!this.isRunning) return;\r\n\r\n        this.lastTime = performance.now();\r\n        this.isRunning = true;\r\n        this.gameLoop(this.lastTime);\r\n    }\r\n\r\n    /**\r\n     * Main game loop\r\n     * @param {number} timestamp\r\n     */\r\n    gameLoop(timestamp: number) {\r\n        if (!this.isRunning) return;\r\n\r\n        // Calculate delta time\r\n        let dt = timestamp - this.lastTime;\r\n        this.lastTime = timestamp;\r\n\r\n        // Cap dt to prevent spiral of death (max 100ms)\r\n        if (dt > 100) dt = 100;\r\n\r\n        this.accumulator += dt;\r\n\r\n        // Fixed Timestep Update\r\n        while (this.accumulator >= this.tickRate) {\r\n            this.update(this.tickRate);\r\n            this.accumulator -= this.tickRate;\r\n        }\r\n\r\n        // Interpolation Factor\r\n        const alpha = this.accumulator / this.tickRate;\r\n        this.render(alpha);\r\n\r\n        // Increment profile frame count\r\n        if (this._profile) this._profile.frameCount++;\r\n\r\n        // Use pre-bound method to avoid closure allocation every frame\r\n        requestAnimationFrame(this._boundGameLoop);\r\n    }\r\n\r\n    /**\r\n     * Update game logic (fixed timestep)\r\n     * @param {number} dt - Delta time in ms\r\n     */\r\n    update(dt: number) {\r\n        const profile = this._profile;\r\n\r\n        // 1. Update Registered Systems\r\n        if (profile) {\r\n            for (const system of this.systems) {\r\n                const name = system.constructor?.name || 'Unknown';\r\n                const start = performance.now();\r\n                (system as any).update(dt);\r\n                profile.systems[name] = (profile.systems[name] || 0) + (performance.now() - start);\r\n            }\r\n        } else {\r\n            for (const system of this.systems) {\r\n                (system as any).update(dt);\r\n            }\r\n        }\r\n\r\n        // 2. Update Entities (via EntityManager)\r\n        if (entityManager) {\r\n            if (profile) {\r\n                const start = performance.now();\r\n                entityManager.update?.(dt);\r\n                profile.entityManager = (profile.entityManager || 0) + (performance.now() - start);\r\n            } else {\r\n                entityManager.update?.(dt);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Render updates (variable timestep)\r\n     * @param {number} [alpha] - Interpolation factor (0-1)\r\n     */\r\n    render(alpha = 1) {\r\n        const profile = this._profile;\r\n\r\n        // 3. Render Game World (includes BG VFX)\r\n        if (GameRenderer) {\r\n            if (profile) {\r\n                const start = performance.now();\r\n                GameRenderer.render();\r\n                profile.gameRenderer = (profile.gameRenderer || 0) + (performance.now() - start);\r\n            } else {\r\n                GameRenderer.render();\r\n            }\r\n        }\r\n\r\n        // 4. Render Foreground VFX (Overlay Layer)\r\n        if (VFXController) {\r\n            if (profile) {\r\n                const start = performance.now();\r\n                VFXController.renderForeground();\r\n                profile.vfxForeground = (profile.vfxForeground || 0) + (performance.now() - start);\r\n            } else {\r\n                VFXController.renderForeground();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Start profiling frame times\r\n     */\r\n    startProfile() {\r\n        this._profile = {\r\n            systems: {},\r\n            entityManager: 0,\r\n            gameRenderer: 0,\r\n            vfxForeground: 0,\r\n            frameCount: 0,\r\n            startTime: performance.now()\r\n        };\r\n        Logger.info('[Game] Profiling started...');\r\n    }\r\n\r\n    /**\r\n     * Stop profiling and print results\r\n     */\r\n    stopProfile() {\r\n        if (!this._profile) return;\r\n        logProfileResults(this._profile);\r\n        this._profile = null;\r\n    }\r\n\r\n    /**\r\n     * Get the primary local hero (Standardized Accessor)\r\n     */\r\n    get hero(): Hero | null {\r\n        return this._hero;\r\n    }\r\n}\r\n\r\n// Create and export singleton\r\nconst GameInstance = new Game();\r\nexport { Game, GameInstance };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\core\\GameProfile.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\core\\GameRenderer.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'EntityRenderService' is defined but never used.","line":19,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":29,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"EntityRenderService"},"fix":{"range":[572,643],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ISystem' is defined but never used.","line":25,"column":26,"nodeType":"Identifier","messageId":"unusedVar","endLine":25,"endColumn":33,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"ISystem"},"fix":{"range":[978,987],"text":""},"desc":"Remove unused variable \"ISystem\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'CollisionSystem' is defined but never used.","line":30,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":30,"endColumn":25,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"CollisionSystem"},"fix":{"range":[1157,1218],"text":""},"desc":"Remove unused import declaration."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * GameRenderer - Canvas rendering system with viewport\r\n *\r\n * Mobile shows a cropped view, PC shows more of the world\r\n *\r\n * Owner: Director\r\n */\r\n\r\nimport { Logger } from './Logger';\r\nimport { Registry } from './Registry';\r\nimport { getWorldWidth, getWorldHeight } from './GameRendererWorldSize';\r\nimport { renderGameLayers } from './GameRendererLayers';\r\nimport {\r\n    updateViewport as updateViewportImpl,\r\n    updateCamera as updateCameraImpl,\r\n    resizeCanvas\r\n} from './GameRendererViewport';\r\nimport { ShadowRenderer } from '../rendering/ShadowRenderer';\r\nimport { EntityRenderService } from '../rendering/EntityRenderService';\r\nimport { RenderProfiler, RenderTiming } from '../rendering/RenderProfiler';\r\nimport { GridRenderer } from '../rendering/GridRenderer';\r\nimport { DebugOverlays } from '../rendering/DebugOverlays';\r\nimport { HomeOutpostRenderer } from '../rendering/HomeOutpostRenderer';\r\nimport { DOMUtils } from './DOMUtils';\r\nimport { IGame, IEntity, ISystem } from '../types/core';\r\n\r\n// Import specific system types\r\nimport { PlatformManager } from './PlatformManager';\r\nimport { VFXController } from '../vfx/VFXController';\r\nimport { CollisionSystem } from '../systems/CollisionSystem';\r\nimport { WorldRenderer } from '../rendering/WorldRenderer';\r\nimport { RoadRenderer } from '../rendering/RoadRenderer';\r\nimport { HeroRenderer } from '../rendering/HeroRenderer';\r\nimport { DinosaurRenderer } from '../rendering/DinosaurRenderer';\r\nimport { ResourceRenderer } from '../rendering/ResourceRenderer';\r\nimport { AmbientSystem } from '../world/AmbientSystem';\r\nimport { FogOfWarSystem } from '../vfx/FogOfWarSystem';\r\nimport { EnvironmentRenderer } from '../rendering/EnvironmentRenderer';\r\nimport { LightingSystem } from '../vfx/LightingSystem';\r\nimport { HomeBase } from '../world/HomeBase';\r\n\r\nconst GameRenderer = {\r\n    canvas: null as HTMLCanvasElement | null,\r\n    ctx: null as CanvasRenderingContext2D | null,\r\n    hero: null as IEntity | null,\r\n    debugMode: false,\r\n    gridMode: false, // Separate toggle for grid overlay\r\n    game: null as IGame | null,\r\n    shadowCanvas: null as HTMLCanvasElement | null,\r\n    shadowCtx: null as CanvasRenderingContext2D | null,\r\n    _worldRenderer: null as WorldRenderer | null,\r\n    _roadRenderer: null as RoadRenderer | null,\r\n    _vfxController: null as typeof VFXController | null,\r\n    _homeBase: null as typeof HomeBase | null,\r\n    _heroRenderer: null as typeof HeroRenderer | null,\r\n    _dinosaurRenderer: null as typeof DinosaurRenderer | null,\r\n    _resourceRenderer: null as typeof ResourceRenderer | null,\r\n    _ambientSystem: null as typeof AmbientSystem | null,\r\n    _fogSystem: null as typeof FogOfWarSystem | null,\r\n    _envRenderer: null as EnvironmentRenderer | null,\r\n    _lightingSystem: null as typeof LightingSystem | null,\r\n    _renderTiming: null as RenderTiming | null, // Profiler data container\r\n\r\n    get worldWidth() {\r\n        return getWorldWidth();\r\n    },\r\n    get worldHeight() {\r\n        return getWorldHeight();\r\n    },\r\n\r\n    // Viewport (what portion of the world is visible)\r\n    viewport: {\r\n        x: 0,\r\n        y: 0,\r\n        width: 450, // Mobile default (9:16 aspect)\r\n        height: 800\r\n    },\r\n\r\n    // GC Optimization: Pre-allocated array for Y-sorting\r\n    _sortableEntities: [] as IEntity[],\r\n\r\n    /**\r\n     * Initialize the renderer\r\n     */\r\n    init(game: IGame) {\r\n        this.game = game;\r\n        this.canvas = document.getElementById('game-canvas') as HTMLCanvasElement;\r\n        if (!this.canvas) {\r\n            Logger.error('[GameRenderer] Canvas not found');\r\n            return false;\r\n        }\r\n\r\n        this.ctx = this.canvas.getContext('2d');\r\n\r\n        // Create Shadow Buffer (Offscreen Canvas)\r\n        this.shadowCanvas = DOMUtils.createCanvas();\r\n        this.shadowCtx = this.shadowCanvas.getContext('2d');\r\n        // Initial size sync\r\n        this.resizeShadowBuffer();\r\n\r\n        // Listen for platform changes\r\n        const platformManager = this.game ? this.game.getSystem<typeof PlatformManager>('PlatformManager') : null;\r\n        if (platformManager) {\r\n            platformManager.on('modechange', () => this.updateViewport());\r\n            this.updateViewport();\r\n        } else {\r\n            this.resize();\r\n        }\r\n\r\n        // Handle window resize\r\n        addEventListener('resize', () => {\r\n            if (this.game) {\r\n                const pm = this.game.getSystem<typeof PlatformManager>('PlatformManager');\r\n                if (pm && pm.isMobile()) {\r\n                    this.updateViewport(); // Recalculate aspect ratio on mobile\r\n                } else {\r\n                    this.resize();\r\n                }\r\n            }\r\n        });\r\n\r\n        // GC Optimization: Cache system references for render loop\r\n        this._worldRenderer = this.game.getSystem<WorldRenderer>('WorldRenderer');\r\n        this._roadRenderer = this.game.getSystem<RoadRenderer>('RoadRenderer');\r\n        this._vfxController = this.game.getSystem<typeof VFXController>('VFXController');\r\n        this._homeBase = this.game.getSystem<typeof HomeBase>('HomeBase');\r\n        this._heroRenderer = this.game.getSystem<typeof HeroRenderer>('HeroRenderer');\r\n        this._dinosaurRenderer = this.game.getSystem<typeof DinosaurRenderer>('DinosaurRenderer');\r\n        this._resourceRenderer = this.game.getSystem<typeof ResourceRenderer>('ResourceRenderer');\r\n        this._ambientSystem = this.game.getSystem<typeof AmbientSystem>('AmbientSystem');\r\n        this._fogSystem = this.game.getSystem<typeof FogOfWarSystem>('FogOfWarSystem');\r\n        this._envRenderer = this.game.getSystem<EnvironmentRenderer>('EnvironmentRenderer');\r\n        this._lightingSystem = this.game.getSystem<typeof LightingSystem>('LightingSystem');\r\n\r\n        Logger.info('[GameRenderer] Initialized');\r\n        return true;\r\n    },\r\n\r\n    resizeShadowBuffer() {\r\n        if (this.shadowCanvas && this.canvas) {\r\n            this.shadowCanvas.width = this.canvas.width;\r\n            this.shadowCanvas.height = this.canvas.height;\r\n        }\r\n    },\r\n\r\n    updateViewport() {\r\n        updateViewportImpl({\r\n            canvas: this.canvas!,\r\n            viewport: this.viewport,\r\n            worldWidth: this.worldWidth,\r\n            worldHeight: this.worldHeight,\r\n            hero: this.hero\r\n        });\r\n        this.resize();\r\n        if (this.ctx) this.render();\r\n    },\r\n\r\n    updateCamera() {\r\n        updateCameraImpl({\r\n            canvas: this.canvas!,\r\n            viewport: this.viewport,\r\n            worldWidth: this.worldWidth,\r\n            worldHeight: this.worldHeight,\r\n            hero: this.hero\r\n        });\r\n    },\r\n\r\n    /**\r\n     * Set the hero reference\r\n     * @param {Hero} hero\r\n     */\r\n    setHero(hero: IEntity) {\r\n        this.hero = hero;\r\n    },\r\n\r\n    /**\r\n     * Convert world coordinates to screen coordinates\r\n     */\r\n    worldToScreen(worldX: number, worldY: number) {\r\n        return {\r\n            x: worldX - this.viewport.x,\r\n            y: worldY - this.viewport.y\r\n        };\r\n    },\r\n\r\n    /**\r\n     * Get the visible world bounds\r\n     */\r\n    getVisibleBounds() {\r\n        return {\r\n            left: this.viewport.x,\r\n            top: this.viewport.y,\r\n            right: this.viewport.x + this.viewport.width,\r\n            bottom: this.viewport.y + this.viewport.height,\r\n            width: this.viewport.width,\r\n            height: this.viewport.height\r\n        };\r\n    },\r\n\r\n    resize() {\r\n        resizeCanvas({ canvas: this.canvas!, viewport: this.viewport });\r\n        this.resizeShadowBuffer();\r\n    },\r\n\r\n    /**\r\n     * Render the composite shadow pass (delegates to ShadowRenderer)\r\n     */\r\n    simpleShadows: false,\r\n\r\n    renderShadowPass(entities: IEntity[]) {\r\n        if (ShadowRenderer) {\r\n            ShadowRenderer.simpleShadows = this.simpleShadows;\r\n            ShadowRenderer.renderShadowPass(\r\n                this.ctx,\r\n                entities,\r\n                this.viewport,\r\n                {\r\n                    heroRenderer: this._heroRenderer,\r\n                    dinosaurRenderer: this._dinosaurRenderer,\r\n                    resourceRenderer: this._resourceRenderer\r\n                },\r\n                this._renderTiming\r\n            );\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Fast simple ellipse shadows (delegates to ShadowRenderer)\r\n     */\r\n    renderSimpleShadows(entities: IEntity[]) {\r\n        if (ShadowRenderer) {\r\n            ShadowRenderer.renderSimpleShadows(this.ctx, entities, this.viewport);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Clear and render all entities\r\n     */\r\n    render(alpha = 1) {\r\n        if (!this.ctx) return;\r\n\r\n        this.updateCamera();\r\n\r\n        renderGameLayers(\r\n            {\r\n                ctx: this.ctx,\r\n                canvas: this.canvas,\r\n                viewport: this.viewport,\r\n                worldWidth: this.worldWidth,\r\n                worldHeight: this.worldHeight,\r\n                hero: this.hero,\r\n                game: this.game,\r\n                debugMode: this.debugMode,\r\n                gridMode: this.gridMode,\r\n                simpleShadows: this.simpleShadows,\r\n                _worldRenderer: this._worldRenderer,\r\n                _roadRenderer: this._roadRenderer,\r\n                _vfxController: this._vfxController,\r\n                _homeBase: this._homeBase,\r\n                _heroRenderer: this._heroRenderer,\r\n                _dinosaurRenderer: this._dinosaurRenderer,\r\n                _resourceRenderer: this._resourceRenderer,\r\n                _ambientSystem: this._ambientSystem,\r\n                _fogSystem: this._fogSystem,\r\n                _envRenderer: this._envRenderer,\r\n                _lightingSystem: this._lightingSystem,\r\n                _renderTiming: this._renderTiming,\r\n                getVisibleBounds: () => this.getVisibleBounds(),\r\n                renderShadowPass: (e) => this.renderShadowPass(e)\r\n            },\r\n            alpha\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Start detailed render profiling (delegates to RenderProfiler)\r\n     */\r\n    startRenderProfile() {\r\n        if (RenderProfiler) {\r\n            this._renderTiming = RenderProfiler.start();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Stop render profiling and print results (delegates to RenderProfiler)\r\n     */\r\n    stopRenderProfile() {\r\n        if (RenderProfiler) {\r\n            RenderProfiler.stop();\r\n        }\r\n        this._renderTiming = null;\r\n    },\r\n\r\n    drawGrid() {\r\n        GridRenderer?.drawGrid(this.ctx, this.viewport, this.canvas, this.game);\r\n    },\r\n    toggleDebug() {\r\n        this.debugMode = !this.debugMode;\r\n        Logger.info(`[GameRenderer] Debug mode: ${this.debugMode}`);\r\n        return this.debugMode;\r\n    },\r\n    toggleGrid() {\r\n        this.gridMode = !this.gridMode;\r\n        Logger.info(`[GameRenderer] Grid mode: ${this.gridMode}`);\r\n        return this.gridMode;\r\n    },\r\n    drawWorldBoundary() {\r\n        DebugOverlays?.drawWorldBoundary(this.ctx, this.viewport, this.worldWidth, this.worldHeight, this.game);\r\n    },\r\n    drawDebugGrid() {\r\n        DebugOverlays?.drawDebugGrid(this.ctx, this.getVisibleBounds());\r\n    },\r\n    drawHomeOutpost() {\r\n        HomeOutpostRenderer?.draw(this.ctx, this.worldWidth, this.worldHeight, this.game);\r\n    }\r\n};\r\n\r\n// Export\r\nif (Registry) Registry.register('GameRenderer', GameRenderer);\r\n\r\n// ES6 Module Export\r\nexport { GameRenderer };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\core\\GameRendererLayers.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ShadowRenderer' is defined but never used.","line":5,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":24,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"ShadowRenderer"},"fix":{"range":[110,171],"text":""},"desc":"Remove unused import declaration."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * GameRendererLayers - Render pass execution for GameRenderer\r\n */\r\nimport { Logger } from './Logger';\r\nimport { ShadowRenderer } from '../rendering/ShadowRenderer';\r\nimport { EntityRenderService } from '../rendering/EntityRenderService';\r\nimport { DebugOverlays } from '../rendering/DebugOverlays';\r\nimport { CollisionSystem } from '../systems/CollisionSystem';\r\nimport type { IEntity, IGame } from '../types/core';\r\nimport type { RenderTiming } from '../rendering/RenderProfiler';\r\nimport type { WorldRenderer } from '../rendering/WorldRenderer';\r\nimport type { RoadRenderer } from '../rendering/RoadRenderer';\r\nimport type { HeroRenderer } from '../rendering/HeroRenderer';\r\nimport type { DinosaurRenderer } from '../rendering/DinosaurRenderer';\r\nimport type { ResourceRenderer } from '../rendering/ResourceRenderer';\r\nimport type { EnvironmentRenderer } from '../rendering/EnvironmentRenderer';\r\n\r\nexport interface GameRendererState {\r\n    ctx: CanvasRenderingContext2D;\r\n    canvas: HTMLCanvasElement;\r\n    viewport: { x: number; y: number; width: number; height: number };\r\n    worldWidth: number;\r\n    worldHeight: number;\r\n    hero: IEntity | null;\r\n    game: IGame | null;\r\n    debugMode: boolean;\r\n    gridMode: boolean;\r\n    simpleShadows: boolean;\r\n    _worldRenderer: WorldRenderer | null;\r\n    _roadRenderer: RoadRenderer | null;\r\n    _vfxController: { bgParticles?: { render: (ctx: CanvasRenderingContext2D) => void }; render?: (ctx: CanvasRenderingContext2D) => void } | null;\r\n    _homeBase: { render: (ctx: CanvasRenderingContext2D) => void } | null;\r\n    _heroRenderer: HeroRenderer | null;\r\n    _dinosaurRenderer: DinosaurRenderer | null;\r\n    _resourceRenderer: ResourceRenderer | null;\r\n    _ambientSystem: { render: (ctx: CanvasRenderingContext2D) => void } | null;\r\n    _fogSystem: { render: (ctx: CanvasRenderingContext2D, viewport: unknown) => void } | null;\r\n    _envRenderer: EnvironmentRenderer | null;\r\n    _lightingSystem: { render: (ctx: CanvasRenderingContext2D) => void } | null;\r\n    _renderTiming: RenderTiming | null;\r\n    getVisibleBounds: () => { left: number; top: number; right: number; bottom: number };\r\n    renderShadowPass: (entities: IEntity[]) => void;\r\n}\r\n\r\nexport function renderGameLayers(state: GameRendererState, alpha: number): void {\r\n    const {\r\n        ctx,\r\n        canvas,\r\n        viewport,\r\n        worldWidth,\r\n        worldHeight,\r\n        debugMode,\r\n        gridMode,\r\n        game,\r\n        _worldRenderer,\r\n        _roadRenderer,\r\n        _vfxController,\r\n        _homeBase,\r\n        _heroRenderer,\r\n        _dinosaurRenderer,\r\n        _resourceRenderer,\r\n        _ambientSystem,\r\n        _fogSystem,\r\n        _envRenderer,\r\n        _lightingSystem,\r\n        _renderTiming,\r\n        getVisibleBounds,\r\n        renderShadowPass\r\n    } = state;\r\n\r\n    const timing = _renderTiming;\r\n    if (timing) timing.frames++;\r\n\r\n    let t0: number;\r\n\r\n    if (timing) t0 = performance.now();\r\n    if (_worldRenderer) {\r\n        _worldRenderer.render(ctx, viewport);\r\n    } else {\r\n        ctx.fillStyle = '#000';\r\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n    }\r\n    if (timing) timing.world += performance.now() - t0;\r\n\r\n    if (timing) t0 = performance.now();\r\n    if (_roadRenderer) {\r\n        ctx.save();\r\n        ctx.translate(-viewport.x, -viewport.y);\r\n        _roadRenderer.render(ctx, viewport);\r\n        ctx.restore();\r\n    }\r\n    if (timing) timing.roads = (timing.roads || 0) + performance.now() - t0;\r\n\r\n    if (timing) t0 = performance.now();\r\n    if (_vfxController?.bgParticles) {\r\n        ctx.save();\r\n        ctx.translate(-viewport.x, -viewport.y);\r\n        _vfxController.bgParticles.render(ctx);\r\n        ctx.restore();\r\n    }\r\n    if (timing) timing.vfxBg += performance.now() - t0;\r\n\r\n    if (timing) t0 = performance.now();\r\n    const sortableEntities = EntityRenderService\r\n        ? EntityRenderService.collectAndSort(getVisibleBounds())\r\n        : [];\r\n    if (timing) timing.entitySort += performance.now() - t0;\r\n\r\n    if (timing) t0 = performance.now();\r\n    renderShadowPass(sortableEntities);\r\n    if (timing) timing.shadows += performance.now() - t0;\r\n\r\n    if (timing) t0 = performance.now();\r\n    ctx.save();\r\n    ctx.translate(-viewport.x, -viewport.y);\r\n\r\n    let tSub: number;\r\n    if (timing) tSub = performance.now();\r\n    if (_homeBase) _homeBase.render(ctx);\r\n    if (timing) timing.entHomeBase = (timing.entHomeBase || 0) + performance.now() - tSub;\r\n\r\n    if (EntityRenderService) {\r\n        const renderers = {\r\n            hero: state.hero,\r\n            heroRenderer: _heroRenderer,\r\n            dinosaurRenderer: _dinosaurRenderer,\r\n            resourceRenderer: _resourceRenderer\r\n        };\r\n        EntityRenderService.renderAll(ctx, sortableEntities, renderers, timing, alpha);\r\n        EntityRenderService.renderUIOverlays(ctx, sortableEntities, timing);\r\n    }\r\n\r\n    ctx.restore();\r\n    if (timing) timing.entities += performance.now() - t0;\r\n\r\n    if (timing) t0 = performance.now();\r\n    if (_ambientSystem) {\r\n        ctx.save();\r\n        ctx.translate(-viewport.x, -viewport.y);\r\n        _ambientSystem.render(ctx);\r\n        ctx.restore();\r\n    }\r\n    if (timing) timing.ambient += performance.now() - t0;\r\n\r\n    if (timing) t0 = performance.now();\r\n    if (_fogSystem) _fogSystem.render(ctx, viewport);\r\n    if (timing) timing.fog += performance.now() - t0;\r\n\r\n    if (timing) t0 = performance.now();\r\n    if (_vfxController?.render) {\r\n        ctx.save();\r\n        ctx.translate(-viewport.x, -viewport.y);\r\n        _vfxController.render(ctx);\r\n        ctx.restore();\r\n    }\r\n    if (timing) timing.vfxFg += performance.now() - t0;\r\n\r\n    if (timing) t0 = performance.now();\r\n    if (_envRenderer) _envRenderer.render(ctx, viewport);\r\n    if (timing) timing.envOverlay += performance.now() - t0;\r\n\r\n    if (timing) t0 = performance.now();\r\n    if (_lightingSystem?.render) {\r\n        try {\r\n            ctx.save();\r\n            ctx.translate(-viewport.x, -viewport.y);\r\n            _lightingSystem.render(ctx);\r\n            ctx.restore();\r\n        } catch (e) {\r\n            ctx.restore();\r\n            Logger.warn('[GameRenderer] LightingSystem render error:', (e as Error).message);\r\n        }\r\n    }\r\n    if (timing) timing.lighting = (timing.lighting || 0) + performance.now() - t0;\r\n\r\n    if (debugMode && DebugOverlays) {\r\n        DebugOverlays.drawWorldBoundary(ctx, viewport, worldWidth, worldHeight, game);\r\n    }\r\n\r\n    const collisionSystem = game?.getSystem<CollisionSystem>('CollisionSystem');\r\n    if (collisionSystem?.renderDebug) {\r\n        ctx.save();\r\n        ctx.translate(-viewport.x, -viewport.y);\r\n        collisionSystem.renderDebug(ctx);\r\n        ctx.restore();\r\n    }\r\n\r\n    if (gridMode && DebugOverlays) {\r\n        ctx.save();\r\n        ctx.translate(-viewport.x, -viewport.y);\r\n        DebugOverlays.drawDebugGrid(ctx, getVisibleBounds());\r\n        ctx.restore();\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\core\\GameRendererViewport.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\core\\GameRendererWorldSize.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\core\\GameState.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getConfig' is defined but never used.","line":10,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":34,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"getConfig"},"fix":{"range":[248,259],"text":""},"desc":"Remove unused variable \"getConfig\"."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * GameState - Global Reactive Store\r\n *\r\n * Centralizes transient game data (Inventory, Gold, Unlocks).\r\n * Decouples UI from Entities.\r\n */\r\n\r\nimport { Logger } from './Logger';\r\nimport { EventBus } from './EventBus';\r\nimport { GameConstants, getConfig } from '@data/GameConstants';\r\nimport { Registry } from './Registry';\r\n\r\ninterface IGameStateData {\r\n    gold: number;\r\n    inventory: Record<string, number>;\r\n    unlocks: string[];\r\n    questId: string | null;\r\n    questProgress: number;\r\n}\r\n\r\nclass GameState {\r\n    data: IGameStateData;\r\n\r\n    constructor() {\r\n        this.data = {\r\n            gold: 0,\r\n            inventory: {},\r\n            unlocks: [],\r\n            questId: null,\r\n            questProgress: 0\r\n        };\r\n\r\n        Logger.info('[GameState] Initialized');\r\n    }\r\n\r\n    /**\r\n     * Initialize state with defaults\r\n     * @param {Partial<IGameStateData> | object} config - Configuration object\r\n     */\r\n    init(config: Partial<IGameStateData> | { constructor?: { name: string } } = {}) {\r\n        // Handle SystemLoader calling init(game)\r\n        // If config is the Game instance, treat as empty config\r\n        if ('constructor' in config && config.constructor && config.constructor.name === 'Game') {\r\n            config = {};\r\n        }\r\n\r\n        const safeConfig = config as Partial<IGameStateData>;\r\n\r\n        // Load defaults from GameConstants if not provided\r\n        const defaultGold =\r\n            GameConstants && GameConstants.Core ? GameConstants.Core.INITIAL_GOLD : 0;\r\n\r\n        const defaults: Partial<IGameStateData> = {\r\n            gold: defaultGold,\r\n            ...safeConfig\r\n        };\r\n\r\n        this.data = { ...this.data, ...defaults };\r\n        Logger.info('[GameState] State initialized. Gold:', this.data.gold);\r\n    }\r\n\r\n    /**\r\n     * Get a value\r\n     * @param {K} key\r\n     */\r\n    get<K extends keyof IGameStateData>(key: K): IGameStateData[K] {\r\n        return this.data[key];\r\n    }\r\n\r\n    /**\r\n     * Set a value and emit change\r\n     * @param {K} key\r\n     * @param {IGameStateData[K]} value\r\n     */\r\n    set<K extends keyof IGameStateData>(key: K, value: IGameStateData[K]) {\r\n        this.data[key] = value;\r\n        this.emitChange(key, value);\r\n    }\r\n\r\n    /**\r\n     * Update inventory and emit specific inventory event\r\n     * @param {string} itemId\r\n     * @param {number} qty\r\n     */\r\n    updateInventory(itemId: string, qty: number) {\r\n        this.data.inventory[itemId] = qty;\r\n\r\n        if (EventBus) {\r\n            EventBus.emit('INVENTORY_UPDATED', this.data.inventory);\r\n        }\r\n    }\r\n\r\n    emitChange<K extends keyof IGameStateData>(key: K, value: IGameStateData[K]) {\r\n        if (EventBus) {\r\n            EventBus.emit('STATE_CHANGED', { key, value });\r\n            // Specific events for convenience\r\n            if (key === 'gold') EventBus.emit('GOLD_CHANGED', value);\r\n        }\r\n    }\r\n}\r\n\r\n// Create singleton and export\r\nconst gameState = new GameState();\r\nif (Registry) Registry.register('GameState', gameState);\r\n\r\nexport { GameState, gameState };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\core\\InputManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\core\\Logger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\core\\MathUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\core\\PlatformManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\core\\Profiler.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Registry' is defined but never used.","line":13,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":18,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"Registry"},"fix":{"range":[400,438],"text":""},"desc":"Remove unused import declaration."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Performance Profiler - In-game FPS and memory stats\r\n *\r\n * Shows real-time performance metrics when enabled.\r\n * Toggle with F3 key or ENV.SHOW_FPS.\r\n */\r\n\r\nimport { Logger } from './Logger';\r\nimport { entityManager } from './EntityManager';\r\nimport { VFXController } from '@vfx/VFXController';\r\nimport { WorldManager } from '../world/WorldManager';\r\nimport { GameInstance } from './Game';\r\nimport { Registry } from './Registry';\r\nimport { DOMUtils } from './DOMUtils';\r\n\r\n// Chrome/Edge Helper for memory stats\r\ninterface PerformanceMemory {\r\n    usedJSHeapSize: number;\r\n    totalJSHeapSize: number;\r\n    jsHeapSizeLimit: number;\r\n}\r\n\r\ninterface ProfilerEnv {\r\n    SHOW_FPS?: boolean;\r\n    DEBUG?: boolean;\r\n}\r\n\r\n// ENV fallback for runtime flags (in production this would be injected)\r\nconst ENV: ProfilerEnv = {\r\n    SHOW_FPS: false,\r\n    DEBUG: false\r\n};\r\n\r\nconst Profiler = {\r\n    enabled: false,\r\n    element: null as HTMLElement | null,\r\n\r\n    // Metrics\r\n    fps: 0,\r\n    frameTime: 0,\r\n    deltaTime: 0,\r\n    memoryUsed: 0,\r\n    entityCount: 0,\r\n    vfxCount: 0,\r\n    currentZone: 'N/A',\r\n    heroPos: { x: 0, y: 0 },\r\n\r\n    // Internals\r\n    frames: 0,\r\n    lastTime: performance.now(),\r\n    lastFrameTime: performance.now(),\r\n\r\n    /**\r\n     * Initialize profiler display\r\n     */\r\n    init() {\r\n        // Check if should auto-enable\r\n        this.enabled = ENV.SHOW_FPS || false;\r\n\r\n        // Create display element\r\n        this.element = DOMUtils.create('div', {\r\n            id: 'profiler',\r\n            cssText: `\r\n            position: fixed;\r\n            top: 50%;\r\n            right: calc(50% + 520px);\r\n            transform: translateY(-50%);\r\n            background: rgba(0, 0, 0, 0.9);\r\n            color: #fff;\r\n            font-family: 'Consolas', monospace;\r\n            font-size: 24px;\r\n            padding: 16px 20px;\r\n            border-radius: 8px;\r\n            border: 1px solid #444;\r\n            z-index: 99999;\r\n            pointer-events: none;\r\n            display: ${this.enabled ? 'block' : 'none'};\r\n            line-height: 1.5;\r\n        `\r\n        });\r\n        document.body.appendChild(this.element);\r\n\r\n        // Toggle with F3\r\n        document.addEventListener('keydown', (e) => {\r\n            if (e.key === 'F3') {\r\n                this.toggle();\r\n                e.preventDefault();\r\n            }\r\n        });\r\n\r\n        Logger.info('[Profiler] Initialized (F3 to toggle)');\r\n    },\r\n\r\n    /**\r\n     * Toggle visibility\r\n     */\r\n    toggle() {\r\n        if (!this.element) return;\r\n        this.enabled = !this.enabled;\r\n        this.element.style.display = this.enabled ? 'block' : 'none';\r\n    },\r\n\r\n    /**\r\n     * Call each frame\r\n     */\r\n    update() {\r\n        if (!this.element) return;\r\n        const now = performance.now();\r\n        this.deltaTime = now - this.lastFrameTime;\r\n        this.lastFrameTime = now;\r\n\r\n        if (!this.enabled) return;\r\n\r\n        this.frames++;\r\n        const delta = now - this.lastTime;\r\n\r\n        // Update every 500ms\r\n        if (delta >= 500) {\r\n            this.fps = Math.round((this.frames * 1000) / delta);\r\n            this.frameTime = parseFloat((delta / this.frames).toFixed(1));\r\n            this.frames = 0;\r\n            this.lastTime = now;\r\n\r\n            // Get memory if available\r\n            const memory = (performance as unknown as { memory?: PerformanceMemory }).memory;\r\n            if (memory) {\r\n                this.memoryUsed = Math.round(memory.usedJSHeapSize / 1048576);\r\n            }\r\n\r\n            // Get entity count\r\n            if (entityManager) {\r\n                this.entityCount = entityManager.getAll().length;\r\n            }\r\n\r\n            // Get VFX/particle count\r\n            if (VFXController && VFXController.getActiveCount) {\r\n                this.vfxCount = VFXController.getActiveCount();\r\n            }\r\n\r\n            // Get current zone\r\n            if (WorldManager && GameInstance?.hero) {\r\n                const hero = GameInstance.hero;\r\n                const island = WorldManager.getIslandAt?.(hero.x, hero.y);\r\n                this.currentZone = island?.name || 'Unknown';\r\n            }\r\n\r\n            // Get hero position\r\n            if (GameInstance?.hero) {\r\n                this.heroPos.x = Math.round(GameInstance.hero.x);\r\n                this.heroPos.y = Math.round(GameInstance.hero.y);\r\n            }\r\n\r\n            this.render();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Render stats\r\n     */\r\n    render() {\r\n        const fpsColor = this.fps >= 55 ? '#4f4' : this.fps >= 30 ? '#ff4' : '#f44';\r\n\r\n        let html = `<div style=\"margin-bottom:4px\"><b>PROFILER</b> <span style=\"font-size:10px;opacity:0.6\">(F3)</span></div>`;\r\n        html += `<div style=\"color:${fpsColor}\">FPS: ${this.fps}</div>`;\r\n        html += `<div>Frame: ${this.frameTime}ms</div>`;\r\n        html += `<div>Delta: ${this.deltaTime.toFixed(1)}ms</div>`;\r\n\r\n        if (this.memoryUsed > 0) {\r\n            html += `<div>Memory: ${this.memoryUsed}MB</div>`;\r\n        }\r\n\r\n        html += `<div style=\"margin-top:8px;border-top:1px solid #444;padding-top:8px\">`;\r\n        html += `<div>Entities: ${this.entityCount}</div>`;\r\n        html += `<div>VFX: ${this.vfxCount}</div>`;\r\n        html += `</div>`;\r\n\r\n        html += `<div style=\"margin-top:8px;border-top:1px solid #444;padding-top:8px\">`;\r\n        html += `<div>Zone: ${this.currentZone}</div>`;\r\n        html += `<div>Pos: ${this.heroPos.x}, ${this.heroPos.y}</div>`;\r\n        html += `</div>`;\r\n\r\n        this.element.innerHTML = html;\r\n    }\r\n};\r\n\r\n// Self-updating loop (no need to call from game loop)\r\nfunction profilerLoop() {\r\n    Profiler.update();\r\n    requestAnimationFrame(profilerLoop);\r\n}\r\n\r\n// Auto-init when DOM ready\r\nif (document.readyState === 'loading') {\r\n    document.addEventListener('DOMContentLoaded', () => {\r\n        Profiler.init();\r\n        profilerLoop();\r\n    });\r\n} else {\r\n    Profiler.init();\r\n    profilerLoop();\r\n}\r\n\r\n// ES6 Module Export\r\nexport { Profiler };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\core\\Quadtree.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\core\\Registry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\core\\ResponsiveManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\core\\SpriteLoader.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\core\\State.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\core\\UIBinder.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\core\\i18n.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\core\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\core\\rendering\\GroundBlendRenderer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\data\\BiomeConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\data\\Dialogues.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\data\\GameConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\data\\GameConstants\\AI.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\data\\GameConstants\\Biome.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\data\\GameConstants\\Combat.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\data\\GameConstants\\Entities.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\data\\GameConstants\\Equipment.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\data\\GameConstants\\Events.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\data\\GameConstants\\Grid.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\data\\GameConstants\\Interaction.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\data\\GameConstants\\PlayerResources.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\data\\GameConstants\\Spawning.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\data\\GameConstants\\UI.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\data\\GameConstants\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\data\\PropConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\data\\RoadsData.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\data\\UIManifest.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\data\\VFXConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\data\\VFX_Categories\\dino.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\data\\VFX_Categories\\hero.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\data\\VFX_Categories\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\data\\VFX_Categories\\magnet.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\data\\VFX_Categories\\projectiles.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\data\\VFX_Categories\\purchase.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\data\\VFX_Categories\\resource.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\data\\VFX_Categories\\unlock.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\data\\VFX_Sequences.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\data\\VFX_Templates.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\data\\WorldData.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\data\\ZoneConfig.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'stringToColor' is defined but never used.","line":28,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":28,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * ZoneConfig - Definition of Paintable Zones\r\n *\r\n * Zones are regional overlays used by the Map Editor to drive\r\n * procedural generation and gameplay logic.\r\n */\r\n\r\nimport { BiomeConfig } from './BiomeConfig';\r\n\r\nexport enum ZoneCategory {\r\n    BIOME = 'biome',\r\n    TERRAIN = 'terrain', // New: Water, Coast, Cliffs\r\n    CIVILIZATION = 'civilization', // New: Outposts, Trenches, Ruins\r\n    ENCOUNTER = 'encounter', // Danger levels\r\n    WEATHER = 'weather', // Atmospheric overrides\r\n    TACTICAL = 'tactical' // Gameplay modifiers (Extraction, No Build)\r\n}\r\n\r\nexport interface ZoneDefinition {\r\n    id: string;\r\n    category: ZoneCategory;\r\n    name: string; // Display Name in Editor\r\n    color: number; // Hex Color for Editor Overlay (0xRRGGBB)\r\n    description?: string;\r\n}\r\n\r\n// Helper to generate color from string hash (for consistent auto-colors)\r\nfunction stringToColor(str: string): number {\r\n    let hash = 0;\r\n    for (let i = 0; i < str.length; i++) {\r\n        hash = str.charCodeAt(i) + ((hash << 5) - hash);\r\n    }\r\n    const c = (hash & 0x00ffffff).toString(16).toUpperCase();\r\n    return parseInt('00000'.substring(0, 6 - c.length) + c, 16);\r\n}\r\n\r\n// Biome mappings (Synched with BiomeConfig)\r\nconst biomeZones: Record<string, ZoneDefinition> = Object.values(BiomeConfig.types).reduce(\r\n    (acc, biome) => {\r\n        // Convert theme hex string to number\r\n        const colorStr = biome.visualTheme.groundColor.replace('#', '0x');\r\n        const color = parseInt(colorStr, 16) || 0x00ff00;\r\n\r\n        acc[biome.id] = {\r\n            id: biome.id,\r\n            category: ZoneCategory.BIOME,\r\n            name: biome.name,\r\n            color: color,\r\n            description: biome.description\r\n        };\r\n        return acc;\r\n    },\r\n    {} as Record<string, ZoneDefinition>\r\n);\r\n\r\nexport const ZoneConfig: Record<string, ZoneDefinition> = {\r\n    ...biomeZones,\r\n    // --- TERRAIN ZONES (Overrides Biomes) ---\r\n    terrain_deep_water: {\r\n        id: 'terrain_deep_water',\r\n        category: ZoneCategory.TERRAIN,\r\n        name: 'Deep Water',\r\n        color: 0x1a5276\r\n    }, // Dark blue (lowest)\r\n    terrain_water: {\r\n        id: 'terrain_water',\r\n        category: ZoneCategory.TERRAIN,\r\n        name: 'Water',\r\n        color: 0x2980b9\r\n    }, // Blue\r\n    terrain_coast: {\r\n        id: 'terrain_coast',\r\n        category: ZoneCategory.TERRAIN,\r\n        name: 'Coastal Grass',\r\n        color: 0xf39c12\r\n    }, // Sand Orange\r\n    terrain_dirtbank: {\r\n        id: 'terrain_dirtbank',\r\n        category: ZoneCategory.TERRAIN,\r\n        name: 'Dirtbank',\r\n        color: 0x8b6914\r\n    }, // Dirt brown\r\n    terrain_river: {\r\n        id: 'terrain_river',\r\n        category: ZoneCategory.TERRAIN,\r\n        name: 'River',\r\n        color: 0x3498db\r\n    }, // River blue (mapgen4)\r\n    terrain_lowland: {\r\n        id: 'terrain_lowland',\r\n        category: ZoneCategory.TERRAIN,\r\n        name: 'Lowland',\r\n        color: 0x7cb342\r\n    }, // Bright green (flat, near sea)\r\n    terrain_land: {\r\n        id: 'terrain_land',\r\n        category: ZoneCategory.TERRAIN,\r\n        name: 'Land',\r\n        color: 0x6b8e23\r\n    }, // Olive green (plains)\r\n    terrain_highland: {\r\n        id: 'terrain_highland',\r\n        category: ZoneCategory.TERRAIN,\r\n        name: 'Highland',\r\n        color: 0x8b9a46\r\n    }, // Yellow-green (elevated plains)\r\n    terrain_hill: {\r\n        id: 'terrain_hill',\r\n        category: ZoneCategory.TERRAIN,\r\n        name: 'Hill',\r\n        color: 0x8b7355\r\n    }, // Brown (rolling hills)\r\n    terrain_midmountain: {\r\n        id: 'terrain_midmountain',\r\n        category: ZoneCategory.TERRAIN,\r\n        name: 'Mid-Mountain',\r\n        color: 0x6d6d6d\r\n    }, // Grey (mid-elevation)\r\n    terrain_mountain: {\r\n        id: 'terrain_mountain',\r\n        category: ZoneCategory.TERRAIN,\r\n        name: 'Mountain',\r\n        color: 0x4a4a4a\r\n    }, // Dark grey (peaks)\r\n\r\n    // --- CIVILIZATION ZONES (WW1 Theme) ---\r\n    civ_outpost: {\r\n        id: 'civ_outpost',\r\n        category: ZoneCategory.CIVILIZATION,\r\n        name: 'Outpost (Safe-ish)',\r\n        color: 0x3498db\r\n    }, // Blue\r\n    civ_trench: {\r\n        id: 'civ_trench',\r\n        category: ZoneCategory.CIVILIZATION,\r\n        name: 'Trench Line',\r\n        color: 0x7f8c8d\r\n    }, // Grey\r\n    civ_noman: {\r\n        id: 'civ_noman',\r\n        category: ZoneCategory.CIVILIZATION,\r\n        name: \"No Man's Land\",\r\n        color: 0x2c3e50\r\n    }, // Dark Grey\r\n    civ_ruins: {\r\n        id: 'civ_ruins',\r\n        category: ZoneCategory.CIVILIZATION,\r\n        name: 'Ruins',\r\n        color: 0x8e44ad\r\n    }, // Purple\r\n    civ_supply: {\r\n        id: 'civ_supply',\r\n        category: ZoneCategory.CIVILIZATION,\r\n        name: 'Supply Depot',\r\n        color: 0xe67e22\r\n    }, // Orange\r\n    civ_town: {\r\n        id: 'civ_town',\r\n        category: ZoneCategory.CIVILIZATION,\r\n        name: 'Town',\r\n        color: 0xcd853f\r\n    }, // Peru/orange-brown (stand out from terrain)\r\n    civ_bridge: {\r\n        id: 'civ_bridge',\r\n        category: ZoneCategory.CIVILIZATION,\r\n        name: 'Bridge',\r\n        color: 0x5d4e37\r\n    }, // Wood/stone bridge (road over river)\r\n\r\n    // --- ENCOUNTER ZONES ---\r\n    enc_safe: {\r\n        id: 'enc_safe',\r\n        category: ZoneCategory.ENCOUNTER,\r\n        name: 'Safe Zone (No Spawn)',\r\n        color: 0x2ecc71\r\n    },\r\n    enc_boss: {\r\n        id: 'enc_boss',\r\n        category: ZoneCategory.ENCOUNTER,\r\n        name: 'Boss Arena',\r\n        color: 0xe74c3c\r\n    },\r\n    enc_elite: {\r\n        id: 'enc_elite',\r\n        category: ZoneCategory.ENCOUNTER,\r\n        name: 'High Danger Level',\r\n        color: 0xc0392b\r\n    },\r\n\r\n    // --- WEATHER ZONES (Atmospheric) ---\r\n    weather_clear: {\r\n        id: 'weather_clear',\r\n        category: ZoneCategory.WEATHER,\r\n        name: 'Forced Clear',\r\n        color: 0xf1c40f\r\n    }, // Sun Yellow\r\n    weather_fog: {\r\n        id: 'weather_fog',\r\n        category: ZoneCategory.WEATHER,\r\n        name: 'Mustard Fog (Hazard)',\r\n        color: 0xd4ac0d\r\n    }, // Mustard Yellow\r\n    weather_smog: {\r\n        id: 'weather_smog',\r\n        category: ZoneCategory.WEATHER,\r\n        name: 'Artillery Smog',\r\n        color: 0x5d6d7e\r\n    }, // Smog Grey\r\n    weather_ash: {\r\n        id: 'weather_ash',\r\n        category: ZoneCategory.WEATHER,\r\n        name: 'Ash Fall',\r\n        color: 0xc0392b\r\n    }, // Ember Red\r\n    weather_storm: {\r\n        id: 'weather_storm',\r\n        category: ZoneCategory.WEATHER,\r\n        name: 'Heavy Storm',\r\n        color: 0x1f618d\r\n    }, // Dark Blue\r\n\r\n    // --- TACTICAL ZONES ---\r\n    tac_extraction: {\r\n        id: 'tac_extraction',\r\n        category: ZoneCategory.TACTICAL,\r\n        name: 'Extraction Zone',\r\n        color: 0x27ae60\r\n    }, // Green\r\n    tac_killbox: {\r\n        id: 'tac_killbox',\r\n        category: ZoneCategory.TACTICAL,\r\n        name: 'Artillery Killbox',\r\n        color: 0xc0392b\r\n    }, // Red\r\n    tac_nobuild: {\r\n        id: 'tac_nobuild',\r\n        category: ZoneCategory.TACTICAL,\r\n        name: 'No Build Zone',\r\n        color: 0x95a5a6\r\n    } // Concrete\r\n};\r\n\r\nexport const ZoneCategories = Object.values(ZoneCategory);\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\data\\ZonePalette.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\EntityLoader.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\EntityLoaderBroadcast.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\EntityLoaderLookup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\EntityLoaderProcess.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\bosses\\boss_dinosaur_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\bosses\\boss_dinosaur_t1_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\bosses\\boss_dinosaur_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\bosses\\boss_dinosaur_t2_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\bosses\\boss_dinosaur_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\bosses\\boss_dinosaur_t3_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\bosses\\boss_dinosaur_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\bosses\\boss_dinosaur_t4_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\bosses\\boss_dinosaur_t4_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\bosses\\boss_herbivore_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\bosses\\boss_herbivore_t4_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\bosses\\boss_human_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\bosses\\boss_human_t1_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\bosses\\boss_human_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\bosses\\boss_human_t2_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\bosses\\boss_human_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\bosses\\boss_human_t3_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\bosses\\boss_human_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\bosses\\boss_human_t4_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\bosses\\boss_human_t4_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\bosses\\boss_saurian_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\bosses\\boss_saurian_t1_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\bosses\\boss_saurian_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\bosses\\boss_saurian_t2_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\bosses\\boss_saurian_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\bosses\\boss_saurian_t3_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\bosses\\boss_saurian_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\bosses\\boss_saurian_t4_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_dinosaur_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_dinosaur_t1_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_dinosaur_t1_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_dinosaur_t1_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_dinosaur_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_dinosaur_t2_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_dinosaur_t2_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_dinosaur_t2_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_dinosaur_t2_05.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_dinosaur_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_dinosaur_t3_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_dinosaur_t3_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_dinosaur_t3_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_dinosaur_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_dinosaur_t4_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_dinosaur_t4_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_herbivore_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_herbivore_t1_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_herbivore_t1_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_herbivore_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_herbivore_t2_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_herbivore_t2_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_herbivore_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_herbivore_t3_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_herbivore_t3_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_herbivore_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_herbivore_t4_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_herbivore_t4_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_human_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_human_t1_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_human_t1_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_human_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_human_t2_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_human_t2_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_human_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_human_t3_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_human_t3_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_human_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_human_t4_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_human_t4_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_saurian_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_saurian_t1_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_saurian_t1_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_saurian_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_saurian_t2_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_saurian_t2_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_saurian_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_saurian_t3_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_saurian_t3_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_saurian_t3_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_saurian_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_saurian_t4_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\enemies\\enemy_saurian_t4_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\arch_barricade_all.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\arch_bridge_badlands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\arch_bridge_desert.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\arch_bridge_grasslands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\arch_bridge_tundra.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\arch_fence_all.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\arch_fence_badlands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\arch_fence_desert.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\arch_fence_grasslands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\arch_fence_tundra.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\arch_gate_badlands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\arch_gate_desert.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\arch_gate_grasslands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\arch_gate_tundra.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\arch_ladder_all.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\arch_post_badlands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\arch_post_desert.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\arch_post_grasslands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\arch_post_tundra.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\arch_railtrack_all.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\arch_road_badlands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\arch_road_cobble.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\arch_road_desert.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\arch_road_grasslands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\arch_road_tundra.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\arch_trench_all.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\arch_wall_badlands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\arch_wall_desert.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\arch_wall_grasslands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\arch_wall_tundra.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\bg_zone_bone_valley.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\bg_zone_crossroads.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\bg_zone_dead_woods.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\bg_zone_home.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\bg_zone_iron_ridge.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\bg_zone_mud_flats.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\bg_zone_quarry_fields.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\bg_zone_scrap_yard.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\bg_zone_the_ruins.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\building_guard_tower_badlands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\building_minaret_tower_desert.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\building_outpost_tower_tundra.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\building_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\building_t1_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\building_watchtower_grasslands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\flora_branch_all.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\flora_cactus_desert.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\flora_cactus_small_desert.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\flora_fern_grasslands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\flora_flower_badlands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\flora_flower_desert.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\flora_flower_grasslands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\flora_flower_tundra.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\flora_grass_badlands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\flora_grass_desert.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\flora_grass_grasslands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\flora_grass_tundra.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\flora_log_badlands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\flora_log_desert.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\flora_log_grasslands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\flora_log_tundra.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\flora_moss_tundra.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\flora_mushroom_badlands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\flora_mushroom_grasslands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\flora_mushroom_tundra.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\flora_rock_badlands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\flora_rock_desert.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\flora_rock_grasslands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\flora_rock_tundra.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\flora_roots_all.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\flora_shrub_badlands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\flora_shrub_desert.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\flora_shrub_grasslands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\flora_shrub_tundra.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\flora_stump_badlands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\flora_stump_desert.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\flora_stump_grasslands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\flora_stump_tundra.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\flora_vine_all.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\flora_weed_all.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\furniture_bed_badlands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\furniture_bed_desert.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\furniture_bed_grasslands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\furniture_bed_tundra.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\furniture_cabinet_badlands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\furniture_cabinet_desert.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\furniture_cabinet_grasslands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\furniture_cabinet_tundra.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\furniture_chair_badlands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\furniture_chair_desert.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\furniture_chair_grasslands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\furniture_chair_tundra.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\furniture_shelf_badlands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\furniture_shelf_desert.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\furniture_shelf_grasslands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\furniture_shelf_tundra.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\furniture_table_badlands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\furniture_table_desert.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\furniture_table_grasslands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\furniture_table_tundra.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_anvil_all.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_barrel_badlands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_barrel_desert.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_barrel_grasslands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_barrel_tundra.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_barrel_water.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_bench_all.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_campfire_badlands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_campfire_desert.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_campfire_grasslands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_campfire_tundra.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_cannon_all.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_cart_badlands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_cart_desert.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_cart_grasslands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_cart_tundra.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_crate_badlands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_crate_desert.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_crate_grasslands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_crate_medical.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_crate_tundra.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_debris_badlands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_debris_desert.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_debris_grasslands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_debris_tundra.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_flagpole_all.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_forge_all.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_lamp_badlands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_lamp_desert.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_lamp_grasslands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_lamp_tundra.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_munitions_all.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_rack_weapons.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_sack_all.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_sandbags_badlands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_sandbags_desert.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_sandbags_grasslands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_sandbags_tundra.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_statue_badlands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_statue_desert.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_statue_grasslands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_statue_tundra.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_stretcher_all.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_table_all.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_tent_badlands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_tent_desert.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_tent_grasslands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\environment\\prop_tent_tundra.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\body_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\body_t1_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\body_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\body_t2_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\body_t2_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\body_t2_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\body_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\feet_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\feet_t1_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\feet_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\feet_t2_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\feet_t2_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\feet_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\hands_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\hands_t1_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\hands_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\hands_t2_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\hands_t2_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\hands_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\head_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\head_t1_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\head_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\head_t2_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\head_t2_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\head_t2_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\head_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\legs_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\legs_t1_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\legs_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\legs_t2_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\legs_t2_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\legs_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\tools\\fishing\\tool_fishing_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\tools\\fishing\\tool_fishing_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\tools\\fishing\\tool_fishing_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\tools\\fishing\\tool_fishing_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\tools\\harvesting\\tool_harvesting_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\tools\\harvesting\\tool_harvesting_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\tools\\harvesting\\tool_harvesting_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\tools\\harvesting\\tool_harvesting_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\tools\\mining\\tool_mining_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\tools\\mining\\tool_mining_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\tools\\mining\\tool_mining_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\tools\\mining\\tool_mining_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\tools\\shovel\\tool_shovel_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\tools\\shovel\\tool_shovel_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\tools\\shovel\\tool_shovel_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\tools\\shovel\\tool_shovel_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\tools\\woodcutting\\tool_woodcutting_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\tools\\woodcutting\\tool_woodcutting_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\tools\\woodcutting\\tool_woodcutting_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\tools\\woodcutting\\tool_woodcutting_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\axe\\weapon_melee_axe_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\axe\\weapon_melee_axe_t1_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\axe\\weapon_melee_axe_t1_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\axe\\weapon_melee_axe_t1_05.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\axe\\weapon_melee_axe_t1_06.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\axe\\weapon_melee_axe_t1_07.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\axe\\weapon_melee_axe_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\axe\\weapon_melee_axe_t2_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\axe\\weapon_melee_axe_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\axe\\weapon_melee_axe_t3_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\axe\\weapon_melee_axe_t3_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\axe\\weapon_melee_axe_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\axe\\weapon_melee_axe_t4_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\bazooka\\weapon_ranged_bazooka_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\bazooka\\weapon_ranged_bazooka_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\bazooka\\weapon_ranged_bazooka_t2_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\bazooka\\weapon_ranged_bazooka_t2_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\bazooka\\weapon_ranged_bazooka_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\bazooka\\weapon_ranged_bazooka_t3_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\bazooka\\weapon_ranged_bazooka_t3_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\bazooka\\weapon_ranged_bazooka_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\flail\\weapon_melee_flail_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\flail\\weapon_melee_flail_t1_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\flail\\weapon_melee_flail_t1_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\flail\\weapon_melee_flail_t1_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\flail\\weapon_melee_flail_t1_05.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\flail\\weapon_melee_flail_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\flail\\weapon_melee_flail_t2_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\flail\\weapon_melee_flail_t2_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\flail\\weapon_melee_flail_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\flail\\weapon_melee_flail_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\flail\\weapon_melee_flail_t4_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\flamethrower\\weapon_ranged_flamethrower_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\flamethrower\\weapon_ranged_flamethrower_t1_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\flamethrower\\weapon_ranged_flamethrower_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\flamethrower\\weapon_ranged_flamethrower_t2_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\flamethrower\\weapon_ranged_flamethrower_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\flamethrower\\weapon_ranged_flamethrower_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\greatsword\\weapon_melee_greatsword_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\greatsword\\weapon_melee_greatsword_t1_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\greatsword\\weapon_melee_greatsword_t1_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\greatsword\\weapon_melee_greatsword_t1_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\greatsword\\weapon_melee_greatsword_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\greatsword\\weapon_melee_greatsword_t2_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\greatsword\\weapon_melee_greatsword_t2_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\greatsword\\weapon_melee_greatsword_t2_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\greatsword\\weapon_melee_greatsword_t2_05.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\greatsword\\weapon_melee_greatsword_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\greatsword\\weapon_melee_greatsword_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\greatsword\\weapon_melee_greatsword_t4_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\greatsword\\weapon_melee_greatsword_t4_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\halberd\\weapon_melee_halberd_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\halberd\\weapon_melee_halberd_t1_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\halberd\\weapon_melee_halberd_t1_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\halberd\\weapon_melee_halberd_t1_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\halberd\\weapon_melee_halberd_t1_05.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\halberd\\weapon_melee_halberd_t1_06.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\halberd\\weapon_melee_halberd_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\halberd\\weapon_melee_halberd_t2_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\halberd\\weapon_melee_halberd_t2_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\halberd\\weapon_melee_halberd_t2_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\halberd\\weapon_melee_halberd_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\halberd\\weapon_melee_halberd_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\halberd\\weapon_melee_halberd_t4_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\knife\\weapon_melee_knife_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\knife\\weapon_melee_knife_t1_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\knife\\weapon_melee_knife_t1_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\knife\\weapon_melee_knife_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\knife\\weapon_melee_knife_t2_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\knife\\weapon_melee_knife_t2_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\knife\\weapon_melee_knife_t2_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\knife\\weapon_melee_knife_t2_05.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\knife\\weapon_melee_knife_t2_06.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\knife\\weapon_melee_knife_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\knife\\weapon_melee_knife_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\knife\\weapon_melee_knife_t4_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\knife\\weapon_melee_knife_t4_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\lance\\weapon_melee_lance_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\lance\\weapon_melee_lance_t1_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\lance\\weapon_melee_lance_t1_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\lance\\weapon_melee_lance_t1_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\lance\\weapon_melee_lance_t1_05.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\lance\\weapon_melee_lance_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\lance\\weapon_melee_lance_t2_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\lance\\weapon_melee_lance_t2_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\lance\\weapon_melee_lance_t2_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\lance\\weapon_melee_lance_t2_05.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\lance\\weapon_melee_lance_t2_06.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\lance\\weapon_melee_lance_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\lance\\weapon_melee_lance_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\lance\\weapon_melee_lance_t4_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\mace\\weapon_melee_mace_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\mace\\weapon_melee_mace_t1_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\mace\\weapon_melee_mace_t1_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\mace\\weapon_melee_mace_t1_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\mace\\weapon_melee_mace_t1_05.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\mace\\weapon_melee_mace_t1_06.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\mace\\weapon_melee_mace_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\mace\\weapon_melee_mace_t2_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\mace\\weapon_melee_mace_t2_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\mace\\weapon_melee_mace_t2_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\mace\\weapon_melee_mace_t2_05.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\mace\\weapon_melee_mace_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\mace\\weapon_melee_mace_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\mace\\weapon_melee_mace_t4_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\mace\\weapon_melee_mace_t4_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\machine_gun\\weapon_ranged_machine_gun_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\machine_gun\\weapon_ranged_machine_gun_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\machine_gun\\weapon_ranged_machine_gun_t2_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\machine_gun\\weapon_ranged_machine_gun_t2_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\machine_gun\\weapon_ranged_machine_gun_t2_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\machine_gun\\weapon_ranged_machine_gun_t2_05.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\machine_gun\\weapon_ranged_machine_gun_t2_06.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\machine_gun\\weapon_ranged_machine_gun_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\machine_gun\\weapon_ranged_machine_gun_t3_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\machine_gun\\weapon_ranged_machine_gun_t3_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\machine_gun\\weapon_ranged_machine_gun_t3_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\machine_gun\\weapon_ranged_machine_gun_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\machine_gun\\weapon_ranged_machine_gun_t4_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\machine_gun\\weapon_ranged_machine_gun_t4_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\pistol\\weapon_ranged_pistol_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\pistol\\weapon_ranged_pistol_t1_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\pistol\\weapon_ranged_pistol_t1_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\pistol\\weapon_ranged_pistol_t1_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\pistol\\weapon_ranged_pistol_t1_05.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\pistol\\weapon_ranged_pistol_t1_06.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\pistol\\weapon_ranged_pistol_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\pistol\\weapon_ranged_pistol_t2_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\pistol\\weapon_ranged_pistol_t2_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\pistol\\weapon_ranged_pistol_t2_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\pistol\\weapon_ranged_pistol_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\pistol\\weapon_ranged_pistol_t3_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\pistol\\weapon_ranged_pistol_t3_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\pistol\\weapon_ranged_pistol_t3_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\pistol\\weapon_ranged_pistol_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\pistol\\weapon_ranged_pistol_t4_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\rifle\\weapon_ranged_rifle_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\rifle\\weapon_ranged_rifle_t1_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\rifle\\weapon_ranged_rifle_t1_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\rifle\\weapon_ranged_rifle_t1_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\rifle\\weapon_ranged_rifle_t1_05.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\rifle\\weapon_ranged_rifle_t1_06.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\rifle\\weapon_ranged_rifle_t1_07.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\rifle\\weapon_ranged_rifle_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\rifle\\weapon_ranged_rifle_t2_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\rifle\\weapon_ranged_rifle_t2_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\rifle\\weapon_ranged_rifle_t2_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\rifle\\weapon_ranged_rifle_t2_05.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\rifle\\weapon_ranged_rifle_t2_06.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\rifle\\weapon_ranged_rifle_t2_07.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\rifle\\weapon_ranged_rifle_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\rifle\\weapon_ranged_rifle_t3_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\rifle\\weapon_ranged_rifle_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\rifle\\weapon_ranged_rifle_t4_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\shotgun\\weapon_ranged_shotgun_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\shotgun\\weapon_ranged_shotgun_t1_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\shotgun\\weapon_ranged_shotgun_t1_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\shotgun\\weapon_ranged_shotgun_t1_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\shotgun\\weapon_ranged_shotgun_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\shotgun\\weapon_ranged_shotgun_t2_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\shotgun\\weapon_ranged_shotgun_t2_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\shotgun\\weapon_ranged_shotgun_t2_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\shotgun\\weapon_ranged_shotgun_t2_05.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\shotgun\\weapon_ranged_shotgun_t2_06.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\shotgun\\weapon_ranged_shotgun_t2_07.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\shotgun\\weapon_ranged_shotgun_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\shotgun\\weapon_ranged_shotgun_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\sniper_rifle\\weapon_ranged_sniper_rifle_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\sniper_rifle\\weapon_ranged_sniper_rifle_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\sniper_rifle\\weapon_ranged_sniper_rifle_t2_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\sniper_rifle\\weapon_ranged_sniper_rifle_t2_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\sniper_rifle\\weapon_ranged_sniper_rifle_t2_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\sniper_rifle\\weapon_ranged_sniper_rifle_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\sniper_rifle\\weapon_ranged_sniper_rifle_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\spear\\weapon_melee_spear_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\spear\\weapon_melee_spear_t1_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\spear\\weapon_melee_spear_t1_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\spear\\weapon_melee_spear_t1_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\spear\\weapon_melee_spear_t1_05.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\spear\\weapon_melee_spear_t1_06.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\spear\\weapon_melee_spear_t1_07.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\spear\\weapon_melee_spear_t1_08.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\spear\\weapon_melee_spear_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\spear\\weapon_melee_spear_t2_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\spear\\weapon_melee_spear_t2_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\spear\\weapon_melee_spear_t2_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\spear\\weapon_melee_spear_t2_05.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\spear\\weapon_melee_spear_t2_06.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\spear\\weapon_melee_spear_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\spear\\weapon_melee_spear_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\spear\\weapon_melee_spear_t4_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\spear\\weapon_melee_spear_t4_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\submachine_gun\\weapon_ranged_submachine_gun_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\submachine_gun\\weapon_ranged_submachine_gun_t1_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\submachine_gun\\weapon_ranged_submachine_gun_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\submachine_gun\\weapon_ranged_submachine_gun_t2_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\submachine_gun\\weapon_ranged_submachine_gun_t2_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\submachine_gun\\weapon_ranged_submachine_gun_t2_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\submachine_gun\\weapon_ranged_submachine_gun_t2_05.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\submachine_gun\\weapon_ranged_submachine_gun_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\submachine_gun\\weapon_ranged_submachine_gun_t3_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\submachine_gun\\weapon_ranged_submachine_gun_t3_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\submachine_gun\\weapon_ranged_submachine_gun_t3_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\submachine_gun\\weapon_ranged_submachine_gun_t3_05.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\submachine_gun\\weapon_ranged_submachine_gun_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\sword\\weapon_melee_sword_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\sword\\weapon_melee_sword_t1_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\sword\\weapon_melee_sword_t1_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\sword\\weapon_melee_sword_t1_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\sword\\weapon_melee_sword_t1_05.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\sword\\weapon_melee_sword_t1_06.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\sword\\weapon_melee_sword_t1_07.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\sword\\weapon_melee_sword_t1_08.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\sword\\weapon_melee_sword_t1_09.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\sword\\weapon_melee_sword_t1_10.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\sword\\weapon_melee_sword_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\sword\\weapon_melee_sword_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\sword\\weapon_melee_sword_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\sword\\weapon_melee_sword_t4_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\sword\\weapon_melee_sword_t4_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\sword\\weapon_melee_sword_t4_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\war_axe\\weapon_melee_war_axe_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\war_axe\\weapon_melee_war_axe_t1_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\war_axe\\weapon_melee_war_axe_t1_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\war_axe\\weapon_melee_war_axe_t1_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\war_axe\\weapon_melee_war_axe_t1_05.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\war_axe\\weapon_melee_war_axe_t1_06.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\war_axe\\weapon_melee_war_axe_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\war_axe\\weapon_melee_war_axe_t2_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\war_axe\\weapon_melee_war_axe_t2_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\war_axe\\weapon_melee_war_axe_t2_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\war_axe\\weapon_melee_war_axe_t2_05.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\war_axe\\weapon_melee_war_axe_t2_06.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\war_axe\\weapon_melee_war_axe_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\war_axe\\weapon_melee_war_axe_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\war_axe\\weapon_melee_war_axe_t4_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\war_axe\\weapon_melee_war_axe_t4_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\war_hammer\\weapon_melee_war_hammer_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\war_hammer\\weapon_melee_war_hammer_t1_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\war_hammer\\weapon_melee_war_hammer_t1_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\war_hammer\\weapon_melee_war_hammer_t1_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\war_hammer\\weapon_melee_war_hammer_t1_05.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\war_hammer\\weapon_melee_war_hammer_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\war_hammer\\weapon_melee_war_hammer_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\war_hammer\\weapon_melee_war_hammer_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\war_hammer\\weapon_melee_war_hammer_t4_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\equipment\\weapons\\war_hammer\\weapon_melee_war_hammer_t4_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\base\\ground_base_cracked_earth_badlands_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\base\\ground_base_cracked_earth_badlands_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\base\\ground_base_cracked_earth_badlands_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\base\\ground_base_dirt_badlands_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\base\\ground_base_dirt_badlands_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\base\\ground_base_dirt_badlands_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\base\\ground_base_grass_badlands_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\base\\ground_base_grass_badlands_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\base\\ground_base_grass_badlands_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\base\\ground_base_grass_badlands_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\base\\ground_base_gravel_badlands_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\base\\ground_base_gravel_badlands_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\base\\ground_base_rock_badlands_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\base\\ground_base_rock_badlands_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\base\\ground_base_rock_badlands_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\base\\ground_base_sand_badlands_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\base\\ground_base_sand_badlands_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\damage\\ground_damage_churned_badlands_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\damage\\ground_damage_churned_badlands_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\damage\\ground_damage_cratered_badlands_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\damage\\ground_damage_scorched_badlands_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\damage\\ground_damage_scorched_badlands_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\interior\\ground_interior_cobblestone_badlands_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\interior\\ground_interior_cobblestone_badlands_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\interior\\ground_interior_concrete_badlands_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\interior\\ground_interior_concrete_badlands_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\interior\\ground_interior_flagstone_badlands_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\interior\\ground_interior_flagstone_badlands_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\interior\\ground_interior_metal_plate_badlands_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\interior\\ground_interior_metal_plate_badlands_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\interior\\ground_interior_planks_badlands_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\interior\\ground_interior_planks_badlands_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\interior\\ground_interior_planks_badlands_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\overgrown\\ground_overgrown_flowers_badlands_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\overgrown\\ground_overgrown_flowers_badlands_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\overgrown\\ground_overgrown_forest_floor_badlands_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\overgrown\\ground_overgrown_forest_floor_badlands_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\overgrown\\ground_overgrown_forest_floor_badlands_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\overgrown\\ground_overgrown_leaves_badlands_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\overgrown\\ground_overgrown_leaves_badlands_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\overgrown\\ground_overgrown_leaves_badlands_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\overgrown\\ground_overgrown_moss_badlands_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\overgrown\\ground_overgrown_moss_badlands_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\overgrown\\ground_overgrown_roots_badlands_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\overgrown\\ground_overgrown_roots_badlands_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\vertical\\ground_vertical_cliff_rock_badlands_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\vertical\\ground_vertical_cliff_rock_badlands_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\vertical\\ground_vertical_cliff_rock_badlands_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\vertical\\ground_vertical_earth_bank_badlands_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\vertical\\ground_vertical_earth_bank_badlands_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\badlands\\vertical\\ground_vertical_earth_bank_badlands_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\base\\ground_base_dirt_desert_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\base\\ground_base_dirt_desert_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\base\\ground_base_dirt_desert_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\base\\ground_base_dunes_desert_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\base\\ground_base_dunes_desert_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\base\\ground_base_grass_desert_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\base\\ground_base_grass_desert_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\base\\ground_base_grass_desert_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\base\\ground_base_grass_desert_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\base\\ground_base_gravel_desert_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\base\\ground_base_gravel_desert_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\base\\ground_base_rock_desert_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\base\\ground_base_rock_desert_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\base\\ground_base_rock_desert_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\base\\ground_base_sand_desert_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\base\\ground_base_sand_desert_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\base\\ground_base_sand_desert_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\damage\\ground_damage_churned_desert_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\damage\\ground_damage_churned_desert_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\damage\\ground_damage_cratered_desert_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\damage\\ground_damage_scorched_desert_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\damage\\ground_damage_scorched_desert_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\interior\\ground_interior_cobblestone_desert_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\interior\\ground_interior_cobblestone_desert_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\interior\\ground_interior_concrete_desert_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\interior\\ground_interior_concrete_desert_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\interior\\ground_interior_flagstone_desert_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\interior\\ground_interior_flagstone_desert_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\interior\\ground_interior_metal_plate_desert_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\interior\\ground_interior_metal_plate_desert_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\interior\\ground_interior_planks_desert_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\interior\\ground_interior_planks_desert_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\interior\\ground_interior_planks_desert_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\overgrown\\ground_overgrown_flowers_desert_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\overgrown\\ground_overgrown_flowers_desert_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\overgrown\\ground_overgrown_forest_floor_desert_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\overgrown\\ground_overgrown_forest_floor_desert_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\overgrown\\ground_overgrown_forest_floor_desert_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\overgrown\\ground_overgrown_leaves_desert_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\overgrown\\ground_overgrown_leaves_desert_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\overgrown\\ground_overgrown_leaves_desert_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\overgrown\\ground_overgrown_moss_desert_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\overgrown\\ground_overgrown_moss_desert_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\overgrown\\ground_overgrown_roots_desert_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\overgrown\\ground_overgrown_roots_desert_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\vertical\\ground_vertical_cliff_rock_desert_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\vertical\\ground_vertical_cliff_rock_desert_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\vertical\\ground_vertical_cliff_rock_desert_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\vertical\\ground_vertical_earth_bank_desert_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\vertical\\ground_vertical_earth_bank_desert_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\desert\\vertical\\ground_vertical_earth_bank_desert_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\base\\ground_base_dirt_grasslands_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\base\\ground_base_dirt_grasslands_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\base\\ground_base_dirt_grasslands_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\base\\ground_base_grass_grasslands_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\base\\ground_base_grass_grasslands_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\base\\ground_base_grass_grasslands_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\base\\ground_base_grass_grasslands_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\base\\ground_base_gravel_grasslands_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\base\\ground_base_gravel_grasslands_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\base\\ground_base_rock_grasslands_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\base\\ground_base_rock_grasslands_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\base\\ground_base_rock_grasslands_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\base\\ground_base_sand_grasslands_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\base\\ground_base_sand_grasslands_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\damage\\ground_damage_churned_grasslands_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\damage\\ground_damage_churned_grasslands_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\damage\\ground_damage_cratered_grasslands_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\damage\\ground_damage_scorched_grasslands_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\damage\\ground_damage_scorched_grasslands_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\interior\\ground_interior_cobblestone_grasslands_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\interior\\ground_interior_cobblestone_grasslands_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\interior\\ground_interior_concrete_grasslands_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\interior\\ground_interior_concrete_grasslands_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\interior\\ground_interior_flagstone_grasslands_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\interior\\ground_interior_flagstone_grasslands_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\interior\\ground_interior_metal_plate_grasslands_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\interior\\ground_interior_metal_plate_grasslands_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\interior\\ground_interior_planks_grasslands_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\interior\\ground_interior_planks_grasslands_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\interior\\ground_interior_planks_grasslands_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\overgrown\\ground_overgrown_flowers_grasslands_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\overgrown\\ground_overgrown_flowers_grasslands_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\overgrown\\ground_overgrown_forest_floor_grasslands_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\overgrown\\ground_overgrown_forest_floor_grasslands_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\overgrown\\ground_overgrown_forest_floor_grasslands_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\overgrown\\ground_overgrown_leaves_grasslands_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\overgrown\\ground_overgrown_leaves_grasslands_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\overgrown\\ground_overgrown_leaves_grasslands_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\overgrown\\ground_overgrown_moss_grasslands_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\overgrown\\ground_overgrown_moss_grasslands_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\overgrown\\ground_overgrown_roots_grasslands_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\overgrown\\ground_overgrown_roots_grasslands_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\vertical\\ground_vertical_cliff_rock_grasslands_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\vertical\\ground_vertical_cliff_rock_grasslands_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\vertical\\ground_vertical_cliff_rock_grasslands_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\vertical\\ground_vertical_earth_bank_grasslands_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\vertical\\ground_vertical_earth_bank_grasslands_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\grasslands\\vertical\\ground_vertical_earth_bank_grasslands_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\base\\ground_base_dirt_tundra_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\base\\ground_base_dirt_tundra_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\base\\ground_base_dirt_tundra_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\base\\ground_base_grass_tundra_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\base\\ground_base_grass_tundra_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\base\\ground_base_grass_tundra_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\base\\ground_base_grass_tundra_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\base\\ground_base_gravel_tundra_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\base\\ground_base_gravel_tundra_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\base\\ground_base_rock_tundra_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\base\\ground_base_rock_tundra_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\base\\ground_base_rock_tundra_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\base\\ground_base_snow_tundra_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\base\\ground_base_snow_tundra_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\base\\ground_base_snow_tundra_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\damage\\ground_damage_churned_tundra_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\damage\\ground_damage_churned_tundra_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\damage\\ground_damage_cratered_tundra_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\damage\\ground_damage_scorched_tundra_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\damage\\ground_damage_scorched_tundra_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\interior\\ground_interior_cobblestone_tundra_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\interior\\ground_interior_cobblestone_tundra_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\interior\\ground_interior_concrete_tundra_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\interior\\ground_interior_concrete_tundra_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\interior\\ground_interior_flagstone_tundra_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\interior\\ground_interior_flagstone_tundra_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\interior\\ground_interior_metal_plate_tundra_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\interior\\ground_interior_metal_plate_tundra_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\interior\\ground_interior_planks_tundra_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\interior\\ground_interior_planks_tundra_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\interior\\ground_interior_planks_tundra_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\overgrown\\ground_overgrown_flowers_tundra_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\overgrown\\ground_overgrown_flowers_tundra_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\overgrown\\ground_overgrown_forest_floor_tundra_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\overgrown\\ground_overgrown_forest_floor_tundra_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\overgrown\\ground_overgrown_forest_floor_tundra_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\overgrown\\ground_overgrown_leaves_tundra_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\overgrown\\ground_overgrown_leaves_tundra_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\overgrown\\ground_overgrown_leaves_tundra_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\overgrown\\ground_overgrown_moss_tundra_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\overgrown\\ground_overgrown_moss_tundra_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\overgrown\\ground_overgrown_roots_tundra_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\overgrown\\ground_overgrown_roots_tundra_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\vertical\\ground_vertical_cliff_rock_tundra_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\vertical\\ground_vertical_cliff_rock_tundra_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\vertical\\ground_vertical_cliff_rock_tundra_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\vertical\\ground_vertical_earth_bank_tundra_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\vertical\\ground_vertical_earth_bank_tundra_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ground\\tundra\\vertical\\ground_vertical_earth_bank_tundra_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\hero\\hero_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\items\\bone_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\items\\bone_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\items\\bone_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\items\\bone_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\items\\leather_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\items\\leather_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\items\\leather_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\items\\leather_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\items\\mechanical_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\items\\mechanical_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\items\\mechanical_t2_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\items\\mechanical_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\items\\mechanical_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\items\\metal_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\items\\metal_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\items\\metal_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\items\\metal_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\items\\wood_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\items\\wood_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\items\\wood_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\items\\wood_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\manifest.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\manifest\\manifest_enemies.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\manifest\\manifest_environment.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\manifest\\manifest_equipment.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\manifest\\manifest_ground.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\manifest\\manifest_items.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\manifest\\manifest_nodes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\manifest\\manifest_resources.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\nodes\\node_fishing_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\nodes\\node_harvesting_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\nodes\\node_harvesting_t1_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\nodes\\node_harvesting_t1_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\nodes\\node_harvesting_t2_05.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\nodes\\node_harvesting_t3_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\nodes\\node_harvesting_t3_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\nodes\\node_mining_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\nodes\\node_mining_t1_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\nodes\\node_mining_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\nodes\\node_mining_t2_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\nodes\\node_mining_t2_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\nodes\\node_mining_t2_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\nodes\\node_mining_t2_06.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\nodes\\node_mining_t2_07.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\nodes\\node_mining_t2_08.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\nodes\\node_mining_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\nodes\\node_mining_t3_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\nodes\\node_mining_t3_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\nodes\\node_mining_t3_05.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\nodes\\node_mining_t3_06.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\nodes\\node_mining_t3_07.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\nodes\\node_mining_t3_08.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\nodes\\node_mining_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\nodes\\node_mining_t4_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\nodes\\node_woodcutting_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\nodes\\node_woodcutting_t1_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\nodes\\node_woodcutting_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\nodes\\node_woodcutting_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\nodes\\node_woodcutting_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\npcs\\npc_merchant_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\npcs\\npc_merchant_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\npcs\\npc_merchant_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\npcs\\npc_merchant_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\npcs\\npc_merchant_05.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\npcs\\npc_merchant_06.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\npcs\\npc_merchant_07.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\npcs\\npc_merchant_08.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\food_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\food_t1_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\food_t1_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\food_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\food_t2_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\food_t2_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\food_t2_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\food_t2_05.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\food_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\food_t3_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\food_t3_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\food_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\minerals_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\minerals_t1_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\minerals_t1_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\minerals_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\minerals_t2_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\minerals_t2_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\minerals_t2_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\minerals_t2_05.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\minerals_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\minerals_t3_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\minerals_t3_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\minerals_t3_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\minerals_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\salvage_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\salvage_t1_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\salvage_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\salvage_t2_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\salvage_t2_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\salvage_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\scraps_t1_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\scraps_t1_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\scraps_t1_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\scraps_t2_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\scraps_t2_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\scraps_t2_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\scraps_t2_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\scraps_t2_05.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\scraps_t2_06.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\scraps_t3_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\scraps_t3_02.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\scraps_t3_03.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\scraps_t3_04.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\resources\\scraps_t4_01.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\stat_armor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\stat_attack_speed.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\stat_crit_chance.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\stat_crit_damage.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\stat_damage.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\stat_efficiency.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\stat_health.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\stat_range.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\stat_speed.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\stat_stamina.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\ui_icon_accessory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\ui_icon_armor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\ui_icon_axe.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\ui_icon_back.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\ui_icon_boots.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\ui_icon_chest.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\ui_icon_equip.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\ui_icon_fishing.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\ui_icon_forge.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\ui_icon_gloves.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\ui_icon_harvesting.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\ui_icon_helmet.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\ui_icon_inventory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\ui_icon_items.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\ui_icon_knife.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\ui_icon_lock.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\ui_icon_mace.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\ui_icon_magnet.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\ui_icon_map.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\ui_icon_orders.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\ui_icon_pistol.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\ui_icon_resources.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\ui_icon_rest.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\ui_icon_rifle.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\ui_icon_settings.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\ui_icon_shop.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\ui_icon_shotgun.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\ui_icon_spear.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\ui_icon_speech_bubble.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\ui_icon_swap.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\ui_icon_sword.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\ui_icon_tool.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\ui_icon_weapon.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\ui_icon_wood_axe.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\ui_res_gem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\ui_res_gold.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\entities\\ui\\ui_res_token.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\gameplay\\BalanceManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\gameplay\\Boss.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getConfig' is defined but never used.","line":11,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":34,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"getConfig"},"fix":{"range":[274,285],"text":""},"desc":"Remove unused variable \"getConfig\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Registry' is defined but never used.","line":18,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":18,"endColumn":18,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"Registry"},"fix":{"range":[567,609],"text":""},"desc":"Remove unused import declaration."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Boss - Powerful biome boss entity\n *\n * Larger, stronger, and has special abilities.\n * Respawns on a timer after death.\n *\n * Work Package: 09-boss-system.md\n */\nimport { Logger } from '@core/Logger';\nimport { EventBus } from '@core/EventBus';\nimport { GameConstants, getConfig } from '@data/GameConstants';\nimport { EntityTypes } from '@config/EntityTypes';\nimport { BiomeConfig } from '@data/BiomeConfig';\nimport { EnemyAI } from '../ai/behaviors/enemies/EnemyAI';\nimport type { HealthComponent } from '../types/core';\n\nimport { Enemy } from './EnemyCore';\nimport { Registry } from '@core/Registry';\nimport { EntityRegistry } from '@entities/EntityLoader';\nimport type { IEntity } from '../types/core';\n\nclass Boss extends Enemy {\n    // Boss property declarations\n    isBoss: boolean = true;\n    bossType: string = 'unknown_boss';\n    bossName: string = 'Unknown Boss';\n    abilities: Array<{ id: string; name: string; cooldown?: number; [key: string]: unknown }> = [];\n    glowColor: string = '#FF4500';\n    scale: number = 1.2;\n\n    /**\n     * Create a boss entity\n     * @param {object} config - Boss configuration\n     */\n    constructor(config: { bossType?: string; x?: number; y?: number; [key: string]: unknown } = {}) {\n        // Get boss config hierarchy: defaults -> type config -> instance config\n        // Get boss config from EntityRegistry\n        const defaults = EntityRegistry.defaults?.boss || {};\n        const typeConfig = config.bossType ? EntityRegistry.bosses?.[config.bossType] || {} : {};\n\n        // Merge configs (instance overrides type overrides defaults)\n        const finalConfig = { ...defaults, ...typeConfig, ...config };\n\n        // Call Enemy constructor with merged config\n        super({\n            ...finalConfig,\n            enemyType: config.bossType,\n            forceNormal: true // Bosses don't roll for elite - they are already special\n        });\n\n        // Boss Identity\n        this.isBoss = true;\n        this.bossType = config.bossType || 'unknown_boss';\n        this.bossName = finalConfig.name || 'Unknown Boss';\n        this.abilities = finalConfig.abilities || [];\n        this.lootTableId = finalConfig.lootTableId || `boss_${config.biomeId || 'common'}`;\n\n        // Override entity type marker (still an enemy for targeting)\n        this.entityType = EntityTypes.ENEMY || 'enemy';\n\n        // Boss-specific respawn time (longer than regular enemies)\n        this.respawnTime =\n            finalConfig.respawnTime || BiomeConfig.Biome?.BOSS_RESPAWN_DEFAULT || 300;\n\n        // Visual enhancements\n        this.glowColor = finalConfig.glowColor || '#FF4500'; // Boss glow\n        this.scale = finalConfig.scale || 1.2; // Slightly larger render\n\n        // Increased threat level for bosses\n        this.threatLevel = finalConfig.threatLevel || 5;\n\n        Logger.info(`[Boss] Created ${this.bossName} in ${config.biomeId || 'unknown'}`);\n    }\n\n    /**\n     * Override render to add boss name plate\n     */\n    render(ctx: CanvasRenderingContext2D) {\n        if (!this.active) return;\n\n        // Call parent render (draws sprite/color + health bar + threat indicator)\n        super.render(ctx);\n\n        // Boss name plate\n        this.renderNamePlate(ctx);\n    }\n\n    /**\n     * Render boss name plate above health bar\n     */\n    renderNamePlate(ctx: CanvasRenderingContext2D) {\n        ctx.save();\n        ctx.font = 'bold 14px monospace';\n        ctx.textAlign = 'center';\n        ctx.fillStyle = this.glowColor;\n        ctx.shadowColor = '#000';\n        ctx.shadowBlur = 3;\n\n        const offset = GameConstants.Boss.NAME_PLATE_Y_OFFSET;\n        const nameY = this.y - this.height / 2 - offset;\n        ctx.fillText(this.bossName, this.x, nameY);\n        ctx.restore();\n    }\n\n    /**\n     * Override die to emit boss-specific death event\n     */\n    die(killer: IEntity | null = null) {\n        // Call parent die\n        super.die(killer);\n\n        // Emit boss-specific death event\n        if (EventBus && GameConstants.Events) {\n            EventBus.emit(GameConstants.Events.BOSS_KILLED, {\n                boss: this,\n                biomeId: this.biomeId,\n                bossType: this.bossType,\n                xpReward: this.xpReward,\n                respawnIn: this.respawnTime\n            });\n        }\n\n        Logger.info(`[Boss] ${this.bossName} defeated! Respawns in ${this.respawnTime}s`);\n    }\n\n    update(dt: number) {\n        if (!this.active || this.isDead) {\n            if (this.isDead) {\n                const ms = GameConstants.Timing.MS_PER_SECOND;\n                this.respawnTimer -= dt / ms;\n                if (this.respawnTimer <= 0) {\n                    this.respawn();\n                }\n            }\n            return;\n        }\n\n        // Sync HealthComponent (Fix for HP Bar)\n        if (this.components.health) {\n            this.health = (this.components.health as unknown as HealthComponent).health;\n        }\n\n        if (this.attackCooldown > 0) {\n            const ms = GameConstants.Timing.MS_PER_SECOND;\n            this.attackCooldown -= dt / ms;\n        }\n\n        if (EnemyAI) {\n            EnemyAI.updateState(this, dt);\n        }\n\n        this.updateAnimation(dt);\n    }\n\n    /**\n     * Override respawn to emit boss-specific spawn event\n     */\n    respawn() {\n        super.respawn();\n\n        if (EventBus && GameConstants.Events) {\n            EventBus.emit(GameConstants.Events.BOSS_SPAWNED, {\n                boss: this,\n                biomeId: this.biomeId,\n                bossType: this.bossType\n            });\n        }\n\n        Logger.info(`[Boss] ${this.bossName} has respawned!`);\n    }\n}\n\n// ES6 Module Export\nexport { Boss };\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\gameplay\\CraftingManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'UIManager' is defined but never used.","line":16,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":16,"endColumn":19,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"UIManager"},"fix":{"range":[510,552],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'dt' is defined but never used. Allowed unused args must match /^_/u.","line":202,"column":12,"nodeType":"Identifier","messageId":"unusedVar","endLine":202,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * CraftingManager - Manages recipes, slots, and production logic\r\n *\r\n * Logic:\r\n * - 12 Slots total (only #1 unlocked initially)\r\n * - Crafting consumes resources immediately\r\n * - Production takes time\r\n * - Finished items must be claimed (or auto-added, for now auto-add/notify)\r\n */\r\n\r\nimport { Logger } from '@core/Logger';\r\nimport { Registry } from '@core/Registry';\r\nimport { EventBus } from '@core/EventBus';\r\nimport { GameState } from '@core/State';\r\nimport { GameInstance } from '@core/Game';\r\nimport { UIManager } from '@ui/UIManager';\r\nimport { spawnCraftedItem } from './SpawnHelper';\r\nimport { WorldManager } from '../world/WorldManager';\r\n\r\nimport { GameConstants } from '@data/GameConstants';\r\nimport { economySystem as EconomySystem } from '@systems/EconomySystem';\r\n\r\nexport interface CraftingRecipe {\r\n    id: string;\r\n    name: string;\r\n    description: string;\r\n    type: string;\r\n    fuelCost: number;\r\n    ingredients: Record<string, number>;\r\n    duration: number; // in seconds\r\n    sellPrice: number;\r\n    outputIcon: string;\r\n}\r\n\r\nexport interface CraftingSlot {\r\n    id: number;\r\n    unlocked: boolean;\r\n    status: 'idle' | 'crafting' | 'complete';\r\n    recipeId: string | null;\r\n    quantity: number;\r\n    startTime: number;\r\n    duration: number;\r\n    item: unknown | null; // Placeholder for future item object\r\n}\r\n\r\nconst CraftingManager = {\r\n    // Configuration\r\n    maxSlots: 12,\r\n    unlockedSlots: 1, // Start with 1, others purchased\r\n\r\n    // State\r\n    slots: [] as CraftingSlot[],\r\n\r\n    // Recipe Registry (Using entity IDs from src/entities/)\r\n    recipes: [\r\n        {\r\n            id: 'metal_t1_01',\r\n            name: 'Scrap Plate',\r\n            description: 'Basic armor plating salvaged from debris.',\r\n            type: 'trade_good',\r\n            fuelCost: 1,\r\n            ingredients: { scraps_t1_01: 2 },\r\n            duration: 5,\r\n            sellPrice: 4,\r\n            outputIcon: 'metal_t1_01'\r\n        },\r\n        {\r\n            id: 'metal_t2_01',\r\n            name: 'Iron Ingot',\r\n            description: 'Refined iron, heavy and reliable.',\r\n            type: 'trade_good',\r\n            fuelCost: 3,\r\n            ingredients: { minerals_t1_01: 2 },\r\n            duration: 20,\r\n            sellPrice: 15,\r\n            outputIcon: 'metal_t2_01'\r\n        },\r\n        {\r\n            id: 'mechanical_t1_01',\r\n            name: 'Trench Tool',\r\n            description: 'Standard issue digging implement.',\r\n            type: 'equipment',\r\n            fuelCost: 5,\r\n            ingredients: { scraps_t1_01: 1, minerals_t1_01: 3 },\r\n            duration: 45,\r\n            sellPrice: 40,\r\n            outputIcon: 'mechanical_t1_01'\r\n        }\r\n    ] as CraftingRecipe[],\r\n\r\n    init() {\r\n        // Load from GameState\r\n        if (GameState) {\r\n            this.unlockedSlots = GameState.get('forge_unlocked_slots') || 1;\r\n        }\r\n        this.initializeSlots();\r\n        Logger.info(`[CraftingManager] Initialized with ${this.unlockedSlots} slots`);\r\n    },\r\n\r\n    initializeSlots() {\r\n        this.slots = [];\r\n        for (let i = 0; i < this.maxSlots; i++) {\r\n            this.slots.push({\r\n                id: i,\r\n                unlocked: i < this.unlockedSlots,\r\n                status: 'idle', // idle, crafting\r\n                recipeId: null,\r\n                quantity: 0,\r\n                startTime: 0,\r\n                duration: 0,\r\n                item: null\r\n            });\r\n        }\r\n    },\r\n\r\n    getRecipe(id: string): CraftingRecipe | undefined {\r\n        return this.recipes.find((r) => r.id === id);\r\n    },\r\n\r\n    /**\r\n     * Unlock a specific slot\r\n     */\r\n    unlockSlot(slotId: number): boolean {\r\n        if (slotId < 0 || slotId >= this.maxSlots) return false;\r\n\r\n        const cost = GameConstants.Crafting.FORGE_SLOT_UNLOCK_COST;\r\n\r\n        if (!GameState) return false;\r\n        const gold = (GameState.get('gold') as number) || 0;\r\n\r\n        if (gold < cost) return false;\r\n\r\n        // Deduct Gold\r\n        // Deduct Gold\r\n        if (EconomySystem) {\r\n            if (!EconomySystem.spendGold(cost)) return false;\r\n        } else {\r\n            GameState.set('gold', gold - cost);\r\n        }\r\n\r\n        // Unlock\r\n        this.unlockedSlots++;\r\n        GameState.set('forge_unlocked_slots', this.unlockedSlots);\r\n\r\n        // Update slot object\r\n        const slot = this.slots[slotId];\r\n        if (slot) slot.unlocked = true;\r\n\r\n        Logger.info(`[Crafting] Unlocked Slot ${slotId}`);\r\n        return true;\r\n    },\r\n\r\n    /**\r\n     * Start crafting process\r\n     */\r\n    startCrafting(slotId: number, recipeId: string, quantity: number): boolean {\r\n        const slot = this.slots[slotId];\r\n        if (!slot) {\r\n            Logger.error(`[Crafting] Invalid slot ${slotId}`);\r\n            return false;\r\n        }\r\n        if (!slot.unlocked) {\r\n            Logger.error(`[Crafting] Slot ${slotId} is locked`);\r\n            return false;\r\n        }\r\n        if (slot.status !== 'idle') {\r\n            Logger.error(`[Crafting] Slot ${slotId} is busy: ${slot.status}`);\r\n            return false;\r\n        }\r\n\r\n        const recipe = this.getRecipe(recipeId);\r\n        if (!recipe) {\r\n            Logger.error(`[Crafting] Unknown recipe ${recipeId}`);\r\n            return false;\r\n        }\r\n\r\n        // Check costs\r\n        if (!this.canAfford(recipe, quantity)) {\r\n            Logger.warn(`[Crafting] Cannot afford ${quantity}x ${recipe.id}`);\r\n            return false;\r\n        }\r\n\r\n        // Consume resources\r\n        this.consumeResources(recipe, quantity);\r\n\r\n        // Update Slot State\r\n        slot.status = 'crafting';\r\n        slot.recipeId = recipeId;\r\n        slot.quantity = quantity;\r\n        const ms = GameConstants.Timing.MS_PER_SECOND;\r\n        slot.duration = recipe.duration * ms; // Duration PER ITEM\r\n        slot.startTime = Date.now();\r\n\r\n        Logger.info(`[Crafting] Started queue of ${quantity}x ${recipe.name} in Slot ${slotId}`);\r\n        return true;\r\n    },\r\n\r\n    /**\r\n     * Update loop (called by Game.js)\r\n     * Handles timer completion\r\n     */\r\n    update(dt: number) {\r\n        const now = Date.now();\r\n\r\n        for (const slot of this.slots) {\r\n            if (slot.status === 'crafting') {\r\n                const elapsed = now - slot.startTime;\r\n\r\n                if (elapsed >= slot.duration) {\r\n                    this.completeCrafting(slot);\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    completeCrafting(slot: CraftingSlot) {\r\n        const recipe = this.getRecipe(slot.recipeId);\r\n        if (!recipe) return;\r\n\r\n        // 1. Logic: Add item to inventory\r\n        if (GameInstance && GameInstance.hero) {\r\n            const inv = GameInstance.hero.inventory;\r\n            inv[recipe.id] = (inv[recipe.id] || 0) + 1;\r\n\r\n            // Update UI via EventBus\r\n            if (EventBus) {\r\n                EventBus.emit('INVENTORY_UPDATED', inv);\r\n            }\r\n        }\r\n\r\n        Logger.info(`[Crafting] Crafted 1x ${recipe.name}, Remaining: ${slot.quantity - 1}`);\r\n\r\n        // 2. Visuals: Spawn via SpawnHelper\r\n        let spawnX = 0;\r\n        let spawnY = 0;\r\n        if (WorldManager) {\r\n            const spawn = WorldManager.getHeroSpawnPosition();\r\n            spawnX = spawn ? spawn.x + 100 : 80000;\r\n            spawnY = spawn ? spawn.y + 100 : 80000;\r\n        } else {\r\n            spawnX = 80000;\r\n            spawnY = 80000;\r\n        }\r\n        spawnCraftedItem(spawnX, spawnY, recipe.id, {\r\n            amount: 1,\r\n            icon: recipe.outputIcon\r\n        });\r\n\r\n        // 3. Queue Logic\r\n        slot.quantity--;\r\n\r\n        if (slot.quantity > 0) {\r\n            // Next item\r\n            slot.startTime = Date.now(); // Reset timer\r\n            // Keep status 'crafting'\r\n        } else {\r\n            // Done\r\n            slot.status = 'idle';\r\n            slot.recipeId = null;\r\n            slot.quantity = 0;\r\n            slot.startTime = 0;\r\n            slot.duration = 0;\r\n        }\r\n    },\r\n\r\n    canAfford(recipe: CraftingRecipe, quantity: number): boolean {\r\n        // Dependencies\r\n        if (!GameInstance || !GameInstance.hero || !GameInstance.hero.inventory) {\r\n            // Fallback\r\n            return false;\r\n        }\r\n\r\n        const inv = GameInstance.hero.inventory;\r\n\r\n        const woodNeeded = recipe.fuelCost * quantity;\r\n        const woodHave = inv['wood_t1_01'] || 0;\r\n        if (woodHave < woodNeeded) return false;\r\n\r\n        for (const [ingId, count] of Object.entries(recipe.ingredients) as [string, number][]) {\r\n            const needed = count * quantity;\r\n            const have = inv[ingId] || 0;\r\n            if (have < needed) return false;\r\n        }\r\n\r\n        return true;\r\n    },\r\n\r\n    consumeResources(recipe: CraftingRecipe, quantity: number) {\r\n        if (!GameInstance || !GameInstance.hero || !GameInstance.hero.inventory) return;\r\n\r\n        const inv = GameInstance.hero.inventory;\r\n\r\n        // Remove Fuel\r\n        inv['wood_t1_01'] -= recipe.fuelCost * quantity;\r\n\r\n        // Remove Ingredients\r\n        for (const [ingId, count] of Object.entries(recipe.ingredients) as [string, number][]) {\r\n            inv[ingId] -= count * quantity;\r\n        }\r\n\r\n        // Refresh UI via event (InventoryUI listens to this)\r\n        if (EventBus) {\r\n            EventBus.emit('INVENTORY_UPDATED', inv);\r\n        }\r\n    },\r\n\r\n    getMaxCraftable(recipe: CraftingRecipe): number {\r\n        if (!GameInstance || !GameInstance.hero || !GameInstance.hero.inventory) return 0;\r\n\r\n        const inv = GameInstance.hero.inventory;\r\n\r\n        // Limit by wood\r\n        let max = Math.floor((inv['wood_t1_01'] || 0) / recipe.fuelCost);\r\n\r\n        // Limit by ingredients\r\n        for (const [ingId, count] of Object.entries(recipe.ingredients) as [string, number][]) {\r\n            const possible = Math.floor((inv[ingId] || 0) / count);\r\n            max = Math.min(max, possible);\r\n        }\r\n\r\n        return max;\r\n    }\r\n};\r\n\r\n// Export\r\nif (Registry) Registry.register('CraftingManager', CraftingManager);\r\n\r\n// ES6 Module Export\r\nexport { CraftingManager };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\gameplay\\Dinosaur.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Registry' is defined but never used.","line":20,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":20,"endColumn":18,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"Registry"},"fix":{"range":[871,913],"text":""},"desc":"Remove unused import declaration."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Dinosaur - AI-controlled entity that wanders and drops loot\r\n *\r\n * Spawns on dinosaur islands, moves randomly, freezes when attacked.\r\n *\r\n * Owner: Director (engine), Gameplay Designer (stats)\r\n */\r\nimport { Entity } from '@core/Entity';\r\nimport type { IEntity } from '../types/core';\r\nimport { Logger } from '@core/Logger';\r\nimport { AssetLoader } from '@core/AssetLoader';\r\nimport { GameConstants } from '@data/GameConstants';\r\nimport { EntityRegistry } from '@entities/EntityLoader';\r\nimport { DinosaurRenderer } from '../rendering/DinosaurRenderer';\r\nimport { EntityTypes } from '@config/EntityTypes';\r\nimport { SpeciesScaleConfig } from '@config/SpeciesScaleConfig';\r\nimport { HealthComponent } from '../components/HealthComponent';\r\nimport { StatsComponent } from '../components/StatsComponent';\r\nimport { AIComponent } from '../components/AIComponent';\r\nimport { Registry } from '@core/Registry';\r\n\r\nclass Dinosaur extends Entity {\r\n    // Entity type and identity\r\n    dinoType: string = 'enemy_herbivore_t1_01';\r\n    lootTable: Array<{ item: string; chance: number; min: number; max: number }> | null = null;\r\n    xpReward: number = 10;\r\n    resourceType: string = 'food_t1_01';\r\n    amount: number = 1;\r\n\r\n    // Component system\r\n    components: {\r\n        health?: HealthComponent;\r\n        stats?: StatsComponent;\r\n        ai?: AIComponent;\r\n        [key: string]: unknown;\r\n    } = {};\r\n\r\n    // Health and state\r\n    maxHealth: number = 60;\r\n    health: number = 60;\r\n    state: string = 'alive';\r\n    respawnTimer: number = 0;\r\n    maxRespawnTime: number = 30;\r\n\r\n\r\n    // Combat flags\r\n    isBeingAttacked: boolean = false;\r\n\r\n    // Animation\r\n    frameIndex: number = 0;\r\n    frameTimer: number = 0;\r\n    frameInterval: number = 200;\r\n    walkFrames: HTMLImageElement[] = [];\r\n    spriteId: string = '';\r\n    _sprite: HTMLImageElement | null = null;\r\n    _spriteLoaded: boolean = false;\r\n    _shadowImg?: HTMLImageElement | HTMLCanvasElement;\r\n\r\n    constructor(config: { dinoType?: string; x?: number; y?: number;[key: string]: unknown } = {}) {\r\n        // 1. Load Config from EntityRegistry (modern: use dinoType to look up herbivore entities)\r\n\r\n        // Look up entity config from EntityRegistry using dinoType (e.g., 'enemy_herbivore_t1_01')\r\n        const entityConfig = config.dinoType ? EntityRegistry.enemies?.[config.dinoType] || {} : {};\r\n\r\n        // Merge: Entity JSON < Constructor\r\n        const finalConfig = { ...entityConfig, ...config };\r\n\r\n        // Get size from SpeciesScaleConfig (runtime lookup by species)\r\n        const defaultSize = GameConstants.Dinosaur.DEFAULT_SIZE;\r\n        const sizeInfo = SpeciesScaleConfig.getSize(entityConfig, false) || {\r\n            width: defaultSize,\r\n            height: defaultSize,\r\n            scale: 1.0\r\n        };\r\n\r\n        // Debug\r\n        const scaleValue = sizeInfo.scale;\r\n        if (scaleValue !== 1.0) {\r\n            Logger.info(\r\n                `[Dinosaur] ${config.dinoType}: species=${entityConfig.species}, scale=${scaleValue}, size=${sizeInfo.width}x${sizeInfo.height}`\r\n            );\r\n        }\r\n\r\n        // IMPORTANT: Apply ...config first, then override with species sizing\r\n        super({\r\n            ...config,\r\n            entityType: EntityTypes.DINOSAUR,\r\n            color: '#2ECC71',\r\n            width: sizeInfo.width,\r\n            height: sizeInfo.height,\r\n            collision: finalConfig.collision // Pass merged collision config\r\n        });\r\n\r\n        // Modern: Store entity type for sprite loading\r\n        this.dinoType = config.dinoType || 'enemy_herbivore_t1_01';\r\n\r\n        // Loot: prioritize config.lootTable (from ResourceSpawner) > entityConfig.lootTable (from EntityLoader)\r\n        this.lootTable = config.lootTable || entityConfig.lootTable || null;\r\n        this.xpReward = entityConfig.xpReward ?? GameConstants.Dinosaur.DEFAULT_XP_REWARD;\r\n\r\n        // Gameplay Props\r\n        this.resourceType = config.resourceType || 'food_t1_01';\r\n        this.amount = finalConfig.amount || 1;\r\n\r\n        // Components\r\n        this.components = {};\r\n        const dinoMaxHp = GameConstants.Dinosaur.DEFAULT_MAX_HEALTH;\r\n        if (HealthComponent) {\r\n            this.components.health = new HealthComponent(this, {\r\n                maxHealth: finalConfig.maxHealth || dinoMaxHp,\r\n                health: finalConfig.maxHealth || dinoMaxHp\r\n            });\r\n        }\r\n\r\n        this.maxHealth = this.components.health ? this.components.health.maxHealth : dinoMaxHp;\r\n        this.health = this.maxHealth;\r\n\r\n        this.state = 'alive'; // alive, dead\r\n        this.respawnTimer = 0;\r\n        this.maxRespawnTime = finalConfig.respawnTime ?? GameConstants.Dinosaur.DEFAULT_RESPAWN_TIME;\r\n\r\n\r\n        // Initialize Respawn Time from Upgrades\r\n        this.recalculateRespawnTimer();\r\n\r\n        // Components (Game Logic)\r\n        if (StatsComponent) {\r\n            // Convert legacy moveSpeed (px/frame @ 60fps) to px/sec\r\n            // Logic was: moveSpeed * 60 (essentially).\r\n            // Default speed config is typically 30 (px/sec).\r\n            // finalConfig.speed is usually 30.\r\n            const speed = finalConfig.speed ?? GameConstants.Dinosaur.DEFAULT_SPEED;\r\n            const maxStamina = GameConstants.Dinosaur.DEFAULT_STAMINA;\r\n            this.components.stats = new StatsComponent(this, {\r\n                speed: speed,\r\n                maxStamina: maxStamina\r\n            });\r\n        }\r\n\r\n        // AI (New Phase 17)\r\n        if (AIComponent) {\r\n            const wMin = GameConstants.Dinosaur.WANDER_INTERVAL_MIN;\r\n            const wMax = GameConstants.Dinosaur.WANDER_INTERVAL_MAX;\r\n            this.components.ai = new AIComponent(this, {\r\n                state: 'WANDER',\r\n                wanderIntervalMin: wMin,\r\n                wanderIntervalMax: wMax\r\n            });\r\n            // Init random direction\r\n            this.components.ai.randomizeWander();\r\n        }\r\n\r\n        // Legacy / Sync Properties (for now, mainly used by System until refactor catch-up)\r\n        this.isBeingAttacked = false; // Set by Game.js / Combat Logic\r\n\r\n        // Animation Props\r\n\r\n        // Animation Props\r\n        this.frameIndex = 0;\r\n        this.frameTimer = 0;\r\n        this.frameInterval = finalConfig.frameInterval ?? GameConstants.Dinosaur.FRAME_INTERVAL;\r\n        this.walkFrames = [];\r\n\r\n        // Sprite Setup - Use dinoType directly as asset key (matches AssetLoader keys)\r\n        this.spriteId = this.dinoType; // e.g., 'enemy_herbivore_t1_01'\r\n\r\n        // Single sprite loading (modern approach)\r\n        this._sprite = null;\r\n        this._spriteLoaded = false;\r\n        this._loadSprite();\r\n    }\r\n\r\n    /**\r\n     * Load sprite using dinoType as asset key (matches Enemy class pattern)\r\n     */\r\n    _loadSprite() {\r\n        if (!AssetLoader) {\r\n            Logger.warn(`[Dinosaur] AssetLoader not available for: ${this.dinoType}`);\r\n            return;\r\n        }\r\n\r\n        // Use dinoType directly as asset key (e.g., 'enemy_herbivore_t1_01')\r\n        const path = AssetLoader.getImagePath(this.dinoType);\r\n\r\n        if (!path || path.includes('PH.png')) {\r\n            Logger.warn(`[Dinosaur] No sprite found for: ${this.dinoType}, path: ${path}`);\r\n            return;\r\n        }\r\n\r\n        Logger.info(`[Dinosaur] Loading sprite: ${this.dinoType} -> ${path}`);\r\n\r\n        this._sprite = AssetLoader.createImage(path, () => {\r\n            this._spriteLoaded = true;\r\n            Logger.info(`[Dinosaur] Sprite loaded: ${this.dinoType}`);\r\n        });\r\n        this._sprite.onerror = (e: Event | string) => {\r\n            Logger.error(`[Dinosaur] Failed to load sprite: ${this.dinoType}, path: ${path}`, e);\r\n            this._spriteLoaded = false;\r\n        };\r\n    }\r\n\r\n    recalculateRespawnTimer() {\r\n        this.maxRespawnTime = 20;\r\n    }\r\n\r\n    /**\r\n     * Update entity state\r\n     * Logic moved to HerbivoreSystem.ts (ECS)\r\n     * @param {number} dt - Delta time in ms\r\n     */\r\n    update(_dt: number) {\r\n        // Handled by HerbivoreSystem\r\n    }\r\n\r\n    /**\r\n     * Pick a new random direction\r\n     * Logic moved to HerbivoreSystem.ts\r\n     */\r\n    changeDirection() {\r\n        // Handled by HerbivoreSystem\r\n    }\r\n\r\n    /**\r\n     * Check if in range for interaction (e.g. gun range checked by Hero/Game)\r\n     * For Entity base compat\r\n     */\r\n    isInRange(hero: IEntity) {\r\n        if (!this.active || !hero) return false;\r\n        if (this.state === 'dead') return false;\r\n        // Use config value for interaction range\r\n        const range = 120;\r\n        return this.distanceTo(hero) < range;\r\n    }\r\n\r\n    render(_ctx: CanvasRenderingContext2D) {\r\n        // Handled by DinosaurRenderer\r\n    }\r\n\r\n    renderUI(ctx: CanvasRenderingContext2D) {\r\n        // Delegated to System\r\n        if (DinosaurRenderer) {\r\n            DinosaurRenderer.renderUI(ctx, this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Legacy Accessor for moveSpeed (used by HerbivoreSystem currently)\r\n     * Returns speed in px/frame (approx) to match old logic until System is updated\r\n     */\r\n    get moveSpeed() {\r\n        // Old: speed / 60\r\n        // New: stats.speed (px/sec) / 60\r\n        return this.components.stats ? this.components.stats.speed / 60 : 0.5;\r\n    }\r\n\r\n    // --- Accessors for AIComponent ---\r\n    get wanderDirection() {\r\n        return this.components.ai ? this.components.ai.wanderDirection : { x: 0, y: 0 };\r\n    }\r\n    set wanderDirection(val) {\r\n        if (this.components.ai) this.components.ai.wanderDirection = val;\r\n    }\r\n\r\n    get wanderTimer() {\r\n        return this.components.ai ? this.components.ai.wanderTimer : 0;\r\n    }\r\n    set wanderTimer(val) {\r\n        if (this.components.ai) this.components.ai.wanderTimer = val;\r\n    }\r\n\r\n    /**\r\n     * Refresh configuration from EntityRegistry\r\n     * Called by EntityLoader on live update\r\n     */\r\n    refreshConfig() {\r\n        // Look up fresh config from registry\r\n        const registryConfig = this.dinoType ? EntityRegistry.enemies?.[this.dinoType] || {} : {};\r\n\r\n        // Re-calculate size using SpeciesScaleConfig\r\n        // This will pick up new width/height/sizeScale from registryConfig\r\n        const isBoss = registryConfig.isBoss || registryConfig.entityType === 'Boss';\r\n        const sizeInfo = SpeciesScaleConfig.getSize(registryConfig, isBoss);\r\n\r\n        if (sizeInfo) {\r\n            this.width = sizeInfo.width;\r\n            this.height = sizeInfo.height;\r\n            // Note: Dinosaur doesn't use this.scale for rendering key, but we can set it if needed\r\n            // this.scale = sizeInfo.scale; \r\n        }\r\n\r\n        // Sync Collision\r\n        if (this.collision && this.collision.bounds) {\r\n            this.collision.bounds.width = this.width;\r\n            this.collision.bounds.height = this.height;\r\n        }\r\n    }\r\n}\r\n\r\n// ES6 Module Export\r\nexport { Dinosaur };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\gameplay\\DroppedItem.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Registry' is defined but never used.","line":15,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":18,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"Registry"},"fix":{"range":[552,594],"text":""},"desc":"Remove unused import declaration."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * DroppedItem - Collectible loot entity spawned when resources are destroyed\r\n *\r\n * Hero must walk near to pick up.\r\n *\r\n * Owner: Director (engine), Gameplay Designer (values)\r\n */\r\nimport { Entity } from '@core/Entity';\r\nimport { Tween } from '../animation/Tween';\r\nimport { VFXController } from '@vfx/VFXController';\r\nimport { ResourceRenderer } from '../rendering/ResourceRenderer';\r\nimport { Resource } from './Resource';\r\nimport { EntityTypes } from '@config/EntityTypes';\r\nimport { GameConstants, getConfig } from '@data/GameConstants';\r\nimport { Registry } from '@core/Registry';\r\nimport { EntityRegistry } from '@entities/EntityLoader';\r\nimport { Logger } from '@core/Logger';\r\nimport { EntityScaling } from '../utils/EntityScaling';\r\nimport type { IEntity } from '../types/core';\r\n\r\nclass DroppedItem extends Entity {\r\n    // Item identity\r\n    resourceType: string = 'scraps_t1_01';\r\n    amount: number = 1;\r\n    pickupRadius: number = 140;\r\n    customIcon: string | null = null;\r\n    rarity: string = 'common';\r\n    rarityColor: string = '#BDC3C7';\r\n    scale: number = 1.0;\r\n\r\n    // Visual state\r\n    pulseTime: number = 0;\r\n\r\n    // Flight animation\r\n    isFlying: boolean = false;\r\n    flightProgress: number = 0;\r\n    z: number = 0;\r\n    maxHeight: number = 40;\r\n\r\n    // Magnet behavior\r\n    isMagnetized: boolean = false;\r\n    magnetTarget: IEntity | null = null;\r\n    magnetSpeed: number = 100;\r\n    magnetAcceleration: number = 500;\r\n\r\n    // Trail effect\r\n    trailHistory: Array<{ x: number; y: number }> = [];\r\n    maxTrailLength: number = 15;\r\n\r\n    // Pickup timing\r\n    age: number = 0;\r\n    landedTime: number | null = null;\r\n    postLandDelay: number = 0.5;\r\n    minPickupTime: number = 0.8;\r\n\r\n    constructor(config: { itemId?: string; amount?: number; x?: number; y?: number; [key: string]: unknown } = {}) {\r\n        // 1. Load Config\r\n        const typeConfig = EntityRegistry.items?.[config.resourceType] || {};\r\n\r\n        // Calculate size directly using utility (Item defaults: 96x96, smaller than entities)\r\n        const size = EntityScaling.calculateSize(config, typeConfig, { width: 96, height: 96 });\r\n\r\n        // Defaults for dropped items\r\n        const defaults = {\r\n            gridSize: 0.75,\r\n            pickupRadius: 120\r\n        };\r\n        const finalConfig = { ...defaults, ...typeConfig, ...config };\r\n\r\n        super({\r\n            entityType: EntityTypes.DROPPED_ITEM,\r\n            width: size.width,\r\n            height: size.height,\r\n            ...config\r\n        });\r\n\r\n        this.scale = size.scale;\r\n\r\n        this.resourceType = config.resourceType || 'scraps_t1_01';\r\n        this.amount = config.amount || 1;\r\n        this.pickupRadius =\r\n            finalConfig.pickupRadius || getConfig().Interaction?.DROPPED_ITEM_PICKUP_RADIUS || 50;\r\n        this.customIcon = config.customIcon || null;\r\n\r\n        // Visual pulse timer\r\n        this.pulseTime = 0;\r\n\r\n        // Set color based on type (same as resource)\r\n        this.color = Resource && Resource.COLORS ? Resource.COLORS[this.resourceType] : '#888888';\r\n\r\n        // Determine rarity\r\n        this.rarity = typeConfig.rarity || 'common';\r\n\r\n        this.rarityColor =\r\n            Resource && Resource.RARITY_COLORS ? Resource.RARITY_COLORS[this.rarity] : '#BDC3C7';\r\n\r\n        // Flight animation props\r\n        this.isFlying = false;\r\n        this.flightProgress = 0; // 0 to 1\r\n        this.z = 0; // Height off ground\r\n        this.maxHeight = 40; // Peak flight height\r\n\r\n        // Magnet behavior\r\n        this.isMagnetized = false;\r\n        this.magnetTarget = null;\r\n\r\n        // REWRITE: Gentle pull (visual collect)\r\n        this.magnetSpeed = finalConfig.magnetSpeed ?? GameConstants.DroppedItem.MAGNET_SPEED;\r\n        this.magnetAcceleration = finalConfig.magnetAcceleration ?? GameConstants.DroppedItem.MAGNET_ACCELERATION;\r\n\r\n        this.trailHistory = []; // [ {x, y, z} ]\r\n        this.maxTrailLength = 15;\r\n\r\n        // Pickup Delay\r\n        this.age = 0;\r\n        this.landedTime = null; // Set when flight finishes\r\n        this.postLandDelay = GameConstants.DroppedItem.POST_LAND_DELAY;\r\n        // Use config (SpawnManager) or default\r\n        this.minPickupTime = config.minPickupTime !== undefined ? config.minPickupTime : GameConstants.DroppedItem.MIN_PICKUP_TIME;\r\n    }\r\n\r\n    /**\r\n     * Start flying towards a target (magnet effect)\r\n     * @param {Entity} target\r\n     */\r\n    magnetize(target: IEntity) {\r\n        if (!this.active || this.isMagnetized) return;\r\n        this.isMagnetized = true;\r\n        this.magnetTarget = target;\r\n        // visual pop - lift off ground immediately\r\n        this.z = 20;\r\n        this.trailHistory = []; // Reset trail\r\n    }\r\n\r\n    /**\r\n     * Start flight animation from current pos to target\r\n     * @param {number} targetX\r\n     * @param {number} targetY\r\n     */\r\n    flyTo(targetX: number, targetY: number) {\r\n        this.isFlying = true;\r\n        this.flightProgress = 0;\r\n\r\n        // Tween position and progress\r\n        if (Tween) {\r\n            Tween.to(\r\n                this,\r\n                {\r\n                    x: targetX,\r\n                    y: targetY,\r\n                    flightProgress: 1\r\n                },\r\n                GameConstants.DroppedItem.FLY_TWEEN_DURATION_MS,\r\n                {\r\n                    easing: 'linear',\r\n                    onComplete: () => this.onLand()\r\n                }\r\n            );\r\n        } else {\r\n            // Fallback if no tween system (snap to end)\r\n            this.x = targetX;\r\n            this.y = targetY;\r\n            this.onLand();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle landing logic\r\n     */\r\n    onLand() {\r\n        this.isFlying = false;\r\n        this.z = 0;\r\n        this.landedTime = this.age; // Mark landing time\r\n\r\n        if (VFXController) {\r\n            // 1. Dust Cloud (Background)\r\n            VFXController.playBackground(this.x, this.y, {\r\n                color: '#B0A090',\r\n                count: 8,\r\n                lifetime: 700,\r\n                speed: 3.5,\r\n                drag: 0.9,\r\n                gravity: -0.02,\r\n                bias: 'up',\r\n                size: 7\r\n            });\r\n\r\n            // 2. Resource Debris (Foreground)\r\n            VFXController.playForeground(this.x, this.y, {\r\n                color: this.color,\r\n                type: 'debris',\r\n                count: 10,\r\n                lifetime: 600,\r\n                speed: 5.5,\r\n                drag: 0.96,\r\n                gravity: 0.25,\r\n                bias: 'up',\r\n                size: 5\r\n            });\r\n\r\n            // 3. Small Spark/Highlight (Foreground)\r\n            VFXController.playForeground(this.x, this.y, {\r\n                color: '#FFFFFF',\r\n                type: 'spark',\r\n                count: 5,\r\n                lifetime: 250,\r\n                speed: 7,\r\n                drag: 0.9,\r\n                size: 4\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update item (pulse animation)\r\n     * @param {number} dt - Delta time in ms\r\n     */\r\n    update(dt: number) {\r\n        super.update(dt); // Call parent update for active/inactive logic\r\n\r\n        // REWRITE: Robust dt handling (data-driven from GameConstants)\r\n        let safeDt = dt;\r\n        if (!safeDt || isNaN(safeDt) || safeDt <= 0) safeDt = GameConstants.Timing.DT_FALLBACK_MS;\r\n        if (safeDt > GameConstants.Timing.DT_LAG_CAP_MS) safeDt = GameConstants.Timing.DT_LAG_CAP_MS;\r\n\r\n        const dtSec = safeDt / GameConstants.Timing.MS_PER_SECOND;\r\n\r\n        this.pulseTime += dtSec;\r\n        this.age += dtSec;\r\n\r\n        // Magnet Logic\r\n        if (this.isMagnetized && this.magnetTarget) {\r\n            const dx = this.magnetTarget.x - this.x;\r\n            const dy = this.magnetTarget.y - this.y;\r\n            const dist = Math.sqrt(dx * dx + dy * dy);\r\n\r\n            // Add current pos to history before moving\r\n            this.trailHistory.push({ x: this.x, y: this.y, z: this.z });\r\n            if (this.trailHistory.length > this.maxTrailLength) {\r\n                this.trailHistory.shift();\r\n            }\r\n\r\n            if (dist < 20) {\r\n                // Strict arrival threshold\r\n                // Acknowledge arrival logic\r\n                // Usually InteractionSystem collects it, but we snap here visually\r\n                this.x = this.magnetTarget.x;\r\n                this.y = this.magnetTarget.y;\r\n            } else {\r\n                // Move towards target\r\n                const angle = Math.atan2(dy, dx);\r\n\r\n                // REWRITE: Physics integration\r\n                // v = v0 + a*t\r\n                this.magnetSpeed += this.magnetAcceleration * dtSec;\r\n                // d = v*t\r\n                let moveDist = this.magnetSpeed * dtSec;\r\n\r\n                // FIX: Cap movement to remaining distance to prevent overshooting\r\n                if (moveDist > dist) {\r\n                    moveDist = dist;\r\n                }\r\n\r\n                this.x += Math.cos(angle) * moveDist;\r\n                this.y += Math.sin(angle) * moveDist;\r\n\r\n                // REWRITE: Fixed Z height - no more hopping/bobbing\r\n                // Smoothly lerp z to target height (20) if not there\r\n                const targetZ = 20;\r\n                this.z += (targetZ - this.z) * 10 * dtSec;\r\n            }\r\n            return; // Skip normal update flight logic if magnetized\r\n        }\r\n\r\n        // Calculate height arc if flying (parabolic spawn flight)\r\n        if (this.isFlying) {\r\n            // Parabolic arc: sin(0..PI) * maxHeight\r\n            this.z = Math.sin(this.flightProgress * Math.PI) * this.maxHeight;\r\n        } else {\r\n            // Rest on ground\r\n            this.z = 0;\r\n        }\r\n    }\r\n\r\n    /** Check if item should start flying to hero (auto-pickup range) */\r\n    shouldAutoMagnetize(hero: IEntity) {\r\n        if (!this.active || !hero) return false;\r\n        if (this.isMagnetized || this.isFlying) return false;\r\n\r\n        // Passive pickup follows delay (player walking near)\r\n        // Must be landed for at least postLandDelay\r\n        if (this.landedTime === null || this.age < this.landedTime + this.postLandDelay)\r\n            return false;\r\n\r\n        return this.distanceTo(hero) < this.pickupRadius;\r\n    }\r\n\r\n    /** Check if hero can finalize pickup (must be strictly close) */\r\n    canBePickedUpBy(hero: IEntity) {\r\n        if (!this.active || !hero) return false;\r\n\r\n        // 1. Check flight status\r\n        if (this.isFlying && !this.isMagnetized) return false; // Wait for initial fly animation\r\n\r\n        // 2. Check minimum age (Manual pickup only)\r\n        // Magnets bypass this delay\r\n        if (\r\n            !this.isMagnetized &&\r\n            (this.landedTime === null || this.age < this.landedTime + this.postLandDelay)\r\n        )\r\n            return false;\r\n\r\n        // Strict proximity\r\n        return this.distanceTo(hero) < 20;\r\n    }\r\n\r\n    /** Render dropped item */\r\n    render(ctx: CanvasRenderingContext2D) {\r\n        if (!this.active) return;\r\n\r\n        // Delegate to System\r\n        if (ResourceRenderer && typeof ResourceRenderer.renderDroppedItem === 'function') {\r\n            ResourceRenderer.renderDroppedItem(ctx, this);\r\n        } else {\r\n            // Fallback (Minimal) if System not ready\r\n            ctx.save();\r\n            ctx.fillStyle = this.color || '#fff';\r\n            ctx.beginPath();\r\n            ctx.arc(this.x, this.y, 10, 0, Math.PI * 2);\r\n            ctx.fill();\r\n            ctx.restore();\r\n        }\r\n    }\r\n\r\n    /** Refresh configuration from EntityRegistry */\r\n    refreshConfig() {\r\n        const typeConfig = EntityRegistry.items?.[this.resourceType] || {};\r\n\r\n        Logger.info(`[DroppedItem] Refreshing config for ${this.resourceType}`);\r\n\r\n        // Update dimensions using standard utility\r\n        EntityScaling.applyToEntity(this, {}, typeConfig, { width: 96, height: 96 });\r\n    }\r\n}\r\n\r\n// ES6 Module Export\r\nexport { DroppedItem };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\gameplay\\EnemyBehavior.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'dt' is defined but never used. Allowed unused args must match /^_/u.","line":99,"column":55,"nodeType":"Identifier","messageId":"unusedVar","endLine":99,"endColumn":57}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * EnemyBehavior - Enemy AI and combat behavior methods\r\n * Extends Enemy.prototype. Path/UI in EnemyBehaviorPath, EnemyBehaviorUI.\r\n */\r\n\r\nimport { Entity } from '@core/Entity';\r\nimport { Enemy } from './EnemyCore';\r\nimport { Logger } from '@core/Logger';\r\nimport { entityManager as EntityManager } from '@core/EntityManager';\r\nimport { EventBus } from '@core/EventBus';\r\nimport { GameConstants, getConfig } from '@data/GameConstants';\r\nimport { BiomeConfig } from '@data/BiomeConfig';\r\nimport { AudioManager } from '../audio/AudioManager';\r\nimport { VFXController } from '@vfx/VFXController';\r\nimport { VFXConfig } from '@data/VFXConfig';\r\nimport { EntityTypes } from '@config/EntityTypes';\r\nimport { spawnDrop } from './SpawnHelper';\r\nimport { GameInstance } from '@core/Game';\r\nimport type { IEntity } from '../types/core';\r\nimport { MathUtils } from '@core/MathUtils';\r\nimport { setupEnemyPathBehavior } from './EnemyBehaviorPath';\r\nimport { setupEnemyUIBehavior } from './EnemyBehaviorUI';\r\n\r\nsetupEnemyPathBehavior();\r\nsetupEnemyUIBehavior();\r\n\r\n/**\r\n * Basic wander behavior with aggro detection\r\n */\r\nEnemy.prototype.updateWander = function (this: Enemy, dt: number) {\r\n    const hero = EntityManager?.getByType('Hero')?.[0] || GameInstance?.hero;\r\n    if (hero && !hero.isDead) {\r\n        const dist = MathUtils.distance(this.x, this.y, hero.x, hero.y);\r\n\r\n        if (dist <= this.aggroRange) {\r\n            this.target = hero;\r\n            this.state = 'chase';\r\n\r\n            if (AudioManager) {\r\n                const aggroSfx = this.sfx?.aggro || 'sfx_enemy_aggro';\r\n                AudioManager.playSFX(aggroSfx);\r\n            }\r\n\r\n            Logger.info(`[Enemy] ${this.enemyName} aggro on hero at distance ${dist.toFixed(0)}`);\r\n            return;\r\n        }\r\n    }\r\n\r\n    this.wanderTimer += dt;\r\n\r\n    if (!this.wanderTarget || this.wanderTimer >= this.wanderInterval) {\r\n        const angle = Math.random() * Math.PI * 2;\r\n        const radius = this.patrolRadius ?? getConfig().AI?.PATROL_AREA_RADIUS ?? GameConstants.AI.PATROL_AREA_RADIUS;\r\n        const dist = Math.random() * radius * 0.5;\r\n        this.wanderTarget = {\r\n            x: this.spawnX + Math.cos(angle) * dist,\r\n            y: this.spawnY + Math.sin(angle) * dist\r\n        };\r\n        this.wanderTimer = 0;\r\n        const minTime = getConfig().AI?.WANDER_TIMER_MIN ?? GameConstants.AI.WANDER_TIMER_MIN;\r\n        const maxTime = getConfig().AI?.WANDER_TIMER_MAX ?? GameConstants.AI.WANDER_TIMER_MAX;\r\n        this.wanderInterval = minTime + Math.random() * (maxTime - minTime);\r\n    }\r\n\r\n    if (this.wanderTarget) {\r\n        this.moveAlongPath(this.wanderTarget.x, this.wanderTarget.y, this.speed * 0.3, dt);\r\n    }\r\n};\r\n\r\n/**\r\n * Chase behavior\r\n */\r\nEnemy.prototype.updateChase = function (this: Enemy, dt: number) {\r\n    if (!this.target) {\r\n        this.state = 'returning';\r\n        return;\r\n    }\r\n\r\n    const dist = MathUtils.distance(this.x, this.y, this.target.x, this.target.y);\r\n\r\n    const spawnDist = MathUtils.distance(this.x, this.y, this.spawnX, this.spawnY);\r\n    if (spawnDist > this.leashDistance) {\r\n        this.state = 'returning';\r\n        this.target = null;\r\n        return;\r\n    }\r\n\r\n    if (dist <= this.attackRange) {\r\n        this.state = 'attack';\r\n        return;\r\n    }\r\n\r\n    this.moveAlongPath(this.target.x, this.target.y, this.speed, dt);\r\n};\r\n\r\n/**\r\n * Attack behavior\r\n */\r\nEnemy.prototype.updateAttack = function (this: Enemy, dt: number) {\r\n    if (!this.target) {\r\n        this.state = 'wander';\r\n        return;\r\n    }\r\n\r\n    const dist = this.distanceTo(this.target);\r\n\r\n    if (dist > this.attackRange * 1.2) {\r\n        this.state = 'chase';\r\n        return;\r\n    }\r\n\r\n    if (this.attackCooldown <= 0) {\r\n        this.performAttack();\r\n        this.attackCooldown = 1 / this.attackRate;\r\n    }\r\n};\r\n\r\n/**\r\n * Perform attack on target\r\n */\r\nEnemy.prototype.performAttack = function (this: Enemy) {\r\n    if (!this.target) return;\r\n\r\n    if (EventBus && GameConstants?.Events) {\r\n        EventBus.emit('ENEMY_ATTACK', {\r\n            attacker: this,\r\n            target: this.target,\r\n            damage: this.damage,\r\n            attackType: this.attackType\r\n        });\r\n    }\r\n\r\n    if (AudioManager) {\r\n        const attackSfx = this.sfx?.attack || 'sfx_enemy_attack';\r\n        AudioManager.playSFX(attackSfx);\r\n    }\r\n\r\n    const target = this.target as IEntity & { takeDamage?(amount: number, source?: IEntity): void };\r\n    if (target?.takeDamage) {\r\n        target.takeDamage(this.damage, this);\r\n    }\r\n};\r\n\r\n/**\r\n * Return to spawn point\r\n */\r\nEnemy.prototype.updateReturning = function (this: Enemy, dt: number) {\r\n    const dx = this.spawnX - this.x;\r\n    const dy = this.spawnY - this.y;\r\n    const dist = Math.sqrt(dx * dx + dy * dy);\r\n\r\n    const returnArrival = GameConstants.AI.PATH_ARRIVAL_DIST;\r\n    if (dist < returnArrival) {\r\n        this.state = 'wander';\r\n        this.target = null;\r\n        this.wanderTarget = null;\r\n        this.wanderTimer = 0;\r\n        this.health = this.maxHealth;\r\n        Logger.info(`[Enemy] ${this.enemyName} returned to patrol, ready to aggro again`);\r\n        return;\r\n    }\r\n\r\n    this.moveAlongPath(this.spawnX, this.spawnY, this.speed * 0.8, dt);\r\n};\r\n\r\n/**\r\n * Take damage from an attack\r\n */\r\nEnemy.prototype.takeDamage = function (this: Enemy, amount: number, source: Entity | null = null) {\r\n    if (this.isDead) return false;\r\n\r\n    this.health -= amount;\r\n    Logger.info(\r\n        `[Enemy] ${this.enemyName} took ${amount} damage! HP: ${this.health}/${this.maxHealth}`\r\n    );\r\n\r\n    if (EventBus) {\r\n        EventBus.emit('ENEMY_DAMAGED', {\r\n            enemy: this,\r\n            damage: amount,\r\n            source: source,\r\n            remaining: this.health\r\n        });\r\n    }\r\n\r\n    // Blood VFX - Multi-layered realistic gore\r\n    if (VFXController && VFXConfig?.DINO) {\r\n        // Primary blood spray\r\n        VFXController.playForeground(this.x, this.y, VFXConfig.DINO.BLOOD_SPLATTER);\r\n        // Blood mist\r\n        VFXController.playForeground(this.x, this.y, VFXConfig.DINO.BLOOD_MIST);\r\n        // Blood droplets\r\n        VFXController.playForeground(this.x, this.y, VFXConfig.DINO.BLOOD_DROPS);\r\n        // Meat chunks on heavy hits\r\n        if (amount > 10) {\r\n            VFXController.playForeground(this.x, this.y, VFXConfig.DINO.MEAT_CHUNKS);\r\n        }\r\n    }\r\n\r\n    if (AudioManager) {\r\n        const hurtSfx = this.sfx?.hurt || 'sfx_enemy_hurt';\r\n        AudioManager.playSFX(hurtSfx);\r\n    }\r\n\r\n    if (this.packAggro && this.groupId && source) {\r\n        this.triggerPackAggro(source);\r\n    }\r\n\r\n    if (this.health <= 0) {\r\n        this.die(source);\r\n    } else if (source && this.state !== 'attack') {\r\n        this.target = source;\r\n        this.state = 'chase';\r\n    }\r\n};\r\n\r\n/**\r\n * Trigger pack aggro for group members\r\n */\r\nEnemy.prototype.triggerPackAggro = function (this: Enemy, target: Entity) {\r\n    if (!EntityManager || !this.groupId) return;\r\n\r\n    const packRadius =\r\n        BiomeConfig?.patrolDefaults?.packAggroRadius ||\r\n        GameConstants?.Biome?.PACK_AGGRO_RADIUS ||\r\n        150;\r\n\r\n    const enemies = EntityManager.getByType(EntityTypes.ENEMY_DINOSAUR).concat(\r\n        EntityManager.getByType(EntityTypes.ENEMY_SOLDIER)\r\n    );\r\n\r\n    for (const enemy of enemies) {\r\n        if (enemy === this || enemy.groupId !== this.groupId) continue;\r\n        if (enemy.isDead || !enemy.packAggro) continue;\r\n\r\n        const dist = this.distanceTo(enemy);\r\n        if (dist <= packRadius) {\r\n            enemy.target = target;\r\n            enemy.state = 'chase';\r\n        }\r\n    }\r\n\r\n    if (AudioManager) {\r\n        AudioManager.playSFX('sfx_pack_aggro');\r\n    }\r\n};\r\n\r\n/**\r\n * Handle enemy death\r\n */\r\nEnemy.prototype.die = function (this: Enemy, killer: Entity | null = null) {\r\n    this.isDead = true;\r\n    this.active = false;\r\n    this.state = 'dead';\r\n    this.health = 0;\r\n    this.respawnTimer = this.respawnTime;\r\n\r\n    if (this.lootTable && Array.isArray(this.lootTable)) {\r\n        for (const entry of this.lootTable) {\r\n            if (Math.random() > (entry.chance || 1)) continue;\r\n\r\n            let amount = 1;\r\n            if (Array.isArray(entry.amount)) {\r\n                amount = Math.floor(\r\n                    entry.amount[0] + Math.random() * (entry.amount[1] - entry.amount[0] + 1)\r\n                );\r\n            } else if (typeof entry.amount === 'object' && entry.amount.min !== undefined) {\r\n                amount = Math.floor(\r\n                    entry.amount.min + Math.random() * (entry.amount.max - entry.amount.min + 1)\r\n                );\r\n            } else if (entry.amount) {\r\n                amount = entry.amount;\r\n            }\r\n\r\n            if (this.isElite) {\r\n                amount = Math.ceil(amount * (this.lootMultiplier || 2));\r\n            }\r\n\r\n            spawnDrop(this.x, this.y, entry.item, amount);\r\n        }\r\n    }\r\n\r\n    if (EventBus) {\r\n        EventBus.emit('ENEMY_DIED', {\r\n            enemy: this,\r\n            killer: killer,\r\n            xpReward: this.xpReward,\r\n            isElite: this.isElite,\r\n            biomeId: this.biomeId,\r\n            groupId: this.groupId,\r\n            waveId: this.waveId\r\n        });\r\n    }\r\n\r\n    if (AudioManager) {\r\n        const deathSfx = this.sfx?.death || 'sfx_enemy_death';\r\n        AudioManager.playSFX(deathSfx);\r\n    }\r\n\r\n    Logger.info(`[Enemy] ${this.enemyName} died. Respawn in ${this.respawnTime}s`);\r\n};\r\n\r\n/**\r\n * Respawn the enemy\r\n */\r\nEnemy.prototype.respawn = function (this: Enemy) {\r\n    this.x = this.spawnX;\r\n    this.y = this.spawnY;\r\n    this.health = this.maxHealth;\r\n    this.isDead = false;\r\n    this.active = true;\r\n    this.state = 'wander';\r\n    this.target = null;\r\n\r\n    if (EventBus) {\r\n        EventBus.emit('ENEMY_RESPAWNED', {\r\n            enemy: this,\r\n            biomeId: this.biomeId,\r\n            groupId: this.groupId,\r\n            waveId: this.waveId\r\n        });\r\n    }\r\n\r\n    Logger.info(`[Enemy] ${this.enemyName} respawned`);\r\n};\r\n\r\nLogger.info('[EnemyBehavior] Behavior methods added to Enemy prototype');\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\gameplay\\EnemyBehaviorPath.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\gameplay\\EnemyBehaviorUI.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\gameplay\\EnemyCore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\gameplay\\EnemyCoreConfig.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'config' is defined but never used. Allowed unused args must match /^_/u.","line":79,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":79,"endColumn":11}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * EnemyCoreConfig  Config merging, elite and biome multipliers for Enemy.\r\n */\r\nimport { EnemyConfig } from '@config/EnemyConfig';\r\nimport { EntityRegistry } from '@entities/EntityLoader';\r\nimport { GameConstants } from '@data/GameConstants';\r\nimport { BiomeConfig } from '@data/BiomeConfig';\r\nimport { EntityTypes } from '@config/EntityTypes';\r\nimport { SpeciesScaleConfig } from '@config/SpeciesScaleConfig';\r\nimport { getConfig } from '@data/GameConstants';\r\nimport type { EntityConfig } from '../types/core';\r\n\r\nexport interface EnemyConfigResult {\r\n    finalConfig: EntityConfig;\r\n    typeConfig: EntityConfig;\r\n    isElite: boolean;\r\n    entityType: string;\r\n    sizeInfo: { width: number; height: number };\r\n}\r\n\r\nexport function buildEnemyConfig(config: EntityConfig): EnemyConfigResult {\r\n    const defaults = (EnemyConfig.defaults as Record<string, unknown>) || {};\r\n    let typeConfig: EntityConfig = {};\r\n    if (config.enemyType) {\r\n        typeConfig = EntityRegistry.enemies?.[config.enemyType] || {};\r\n    }\r\n\r\n    const finalConfig = { ...defaults, ...typeConfig, ...config };\r\n\r\n    const eliteChance =\r\n        (EnemyConfig.eliteSpawnChance as number) ?? BiomeConfig.Biome?.ELITE_SPAWN_CHANCE ?? 0.05;\r\n    const isElite = config.isElite || (!config.forceNormal && Math.random() < eliteChance);\r\n\r\n    if (isElite) {\r\n        const mult = (EnemyConfig.eliteMultipliers as { health: number; damage: number; xpReward: number; lootDrops: number }) || {\r\n            health: 2.0,\r\n            damage: 2.0,\r\n            xpReward: 3.0,\r\n            lootDrops: 3.0\r\n        };\r\n        const eliteFallback = GameConstants.Enemy.ELITE_FALLBACK_HEALTH;\r\n        finalConfig.health = (Number(finalConfig.health) || eliteFallback) * mult.health;\r\n        finalConfig.maxHealth = (Number(finalConfig.maxHealth) || finalConfig.health) * mult.health;\r\n        finalConfig.damage = (Number(finalConfig.damage) || GameConstants.Enemy.DEFAULT_DAMAGE) * mult.damage;\r\n        finalConfig.xpReward = (Number(finalConfig.xpReward) || GameConstants.Enemy.DEFAULT_XP_REWARD) * mult.xpReward;\r\n    }\r\n\r\n    if (config.biomeId && (BiomeConfig.types as Record<string, { difficulty?: string }>)?.[config.biomeId]) {\r\n        const biome = (BiomeConfig.types as Record<string, { difficulty?: string }>)[config.biomeId];\r\n        const diffMult = (BiomeConfig.difficultyMultipliers as Record<string, { health?: number; damage?: number; xp?: number }>)?.[biome.difficulty] || {\r\n            health: 1,\r\n            damage: 1,\r\n            xp: 1,\r\n            loot: 1\r\n        };\r\n        finalConfig.health = (finalConfig.health || 0) * (diffMult.health ?? 1);\r\n        finalConfig.maxHealth = finalConfig.health;\r\n        finalConfig.damage = (finalConfig.damage || 0) * (diffMult.damage ?? 1);\r\n        finalConfig.xpReward = (finalConfig.xpReward || 0) * (diffMult.xp ?? 1);\r\n    }\r\n\r\n    let entityType = finalConfig.entityType;\r\n    if (!entityType) {\r\n        const sourceFile = (typeConfig.sourceFile || config.enemyType || '').toLowerCase();\r\n        if (sourceFile.includes('soldier') || sourceFile.includes('human')) entityType = EntityTypes.ENEMY_SOLDIER;\r\n        else if (sourceFile.includes('saurian')) entityType = EntityTypes.ENEMY_SAURIAN;\r\n        else entityType = EntityTypes.ENEMY_DINOSAUR;\r\n    }\r\n\r\n    const isBoss = typeConfig.isBoss || typeConfig.entityType === 'Boss';\r\n    const defaultSize = GameConstants.Enemy.DEFAULT_SIZE;\r\n    const sizeInfo = SpeciesScaleConfig.getSize(typeConfig, isBoss) || { width: defaultSize, height: defaultSize };\r\n\r\n    return { finalConfig, typeConfig, isElite, entityType, sizeInfo };\r\n}\r\n\r\nexport function getPatrolConfig(\r\n    finalConfig: EntityConfig,\r\n    config: EntityConfig\r\n): { patrolRadius: number; leashDistance: number; aggroRange: number } {\r\n    const Biome = GameConstants.Biome;\r\n    return {\r\n        patrolRadius:\r\n            finalConfig.patrolRadius ??\r\n            getConfig().AI?.PATROL_AREA_RADIUS ??\r\n            BiomeConfig.patrolDefaults?.areaRadius ??\r\n            Biome.PATROL_AREA_RADIUS,\r\n        leashDistance:\r\n            finalConfig.leashDistance ??\r\n            getConfig().Biome?.LEASH_DISTANCE ??\r\n            BiomeConfig.patrolDefaults?.leashDistance ??\r\n            Biome.LEASH_DISTANCE,\r\n        aggroRange:\r\n            finalConfig.aggroRange ??\r\n            getConfig().Biome?.AGGRO_RANGE ??\r\n            BiomeConfig.patrolDefaults?.aggroRange ??\r\n            Biome.AGGRO_RANGE\r\n    };\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\gameplay\\EnemyCoreRefresh.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\gameplay\\EnemyRender.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\gameplay\\Hero.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Registry' is defined but never used.","line":20,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":20,"endColumn":18,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"Registry"},"fix":{"range":[872,914],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'EquipmentItem' is defined but never used.","line":23,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":23,"endColumn":28,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"EquipmentItem"},"fix":{"range":[1036,1085],"text":""},"desc":"Remove unused import declaration."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Hero - Player-controlled character\n *\n * Owner: Director (engine), Gameplay Designer (stats)\n */\nimport { Entity } from '@core/Entity';\nimport { RenderConfig } from '@config/RenderConfig';\nimport { EquipmentManager } from '@systems/EquipmentManager';\nimport { GameConstants, getConfig } from '@data/GameConstants';\nimport { EntityRegistry } from '@entities/EntityLoader';\nimport { GameInstance } from '@core/Game';\nimport { EntityTypes } from '@config/EntityTypes';\nimport { HealthComponent } from '../components/HealthComponent';\nimport { InventoryComponent } from '../components/InventoryComponent';\nimport { CombatComponent } from '../components/CombatComponent';\nimport { StatsComponent } from '../components/StatsComponent';\nimport { HeroDefaults } from '@config/HeroDefaults';\nimport { EventBus } from '@core/EventBus';\nimport { Logger } from '@core/Logger';\nimport { Registry } from '@core/Registry';\nimport { EquipmentManager } from '@systems/EquipmentManager';\nimport type { IComponents, IEntity } from '../types/core';\nimport type { EquipmentItem } from '../types/ui';\n\n// Unmapped modules - need manual import\n\ninterface HeroConfig {\n    width?: number;\n    height?: number;\n    color?: string;\n    maxHealth?: number;\n    health?: number;\n    gold?: number;\n    speed?: number;\n    maxStamina?: number;\n    stamina?: number;\n    level?: number;\n    xp?: number;\n    xpToNextLevel?: number;\n    xpScaling?: number;\n    attack?: {\n        damage?: number;\n        rate?: number;\n        range?: {\n            default?: number;\n        };\n        staminaCost?: number;\n    };\n    defense?: number;\n    critChance?: number;\n    critMultiplier?: number;\n    [key: string]: unknown;\n}\n\nclass Hero extends Entity {\n    // Class properties\n    components: IComponents;\n    equipment: EquipmentManager;\n    isAtHomeOutpost: boolean = false;\n    locked: boolean = false;\n    isAttacking: boolean = false;\n    hand1Attacking: boolean = false;\n    hand2Attacking: boolean = false;\n    targetResource: IEntity | null = null;\n\n    footstepTimer: number;\n    footstepInterval: number;\n    attackTimer: number;\n    selectedSkin: string | null = null;\n    inputMove: { x: number; y: number } = { x: 0, y: 0 };\n\n    /** Check if hero is dead */\n    isDead(): boolean {\n        return this.health <= 0;\n    }\n\n    constructor(config: HeroConfig = {}) {\n        // 1. Load Config from EntityRegistry (v2 architecture) or fallback\n        const baseConfig = GameInstance?.hero || {};\n        // Merge: Config < Constructor Args\n        const finalConfig = { ...baseConfig, ...config };\n\n        super({\n            id: 'hero',\n            entityType: EntityTypes.HERO,\n            width: finalConfig.width || RenderConfig.Hero.WIDTH,\n            height: finalConfig.height || RenderConfig.Hero.HEIGHT,\n            color: finalConfig.color || RenderConfig.Hero.COLOR,\n            collision: {\n                bounds: { x: 0, y: 0, width: 32, height: 32 },\n                layer: 0x0002, // HERO\n                mask: 0x0001 | 0x0010 | 0x0004 | 0x0008, // WORLD | TRIGGER | ENEMY | BOSS\n                isTrigger: false\n            },\n            ...config\n        });\n\n        // 2. Initialize Components\n        this.components = {};\n\n        // Health\n        if (HealthComponent) {\n            this.components.health = new HealthComponent(this, {\n                maxHealth: finalConfig.maxHealth,\n                health: finalConfig.health\n            });\n        }\n\n        // Inventory\n        if (InventoryComponent) {\n            const resources = getConfig().PlayerResources;\n            this.components.inventory = new InventoryComponent(this, {\n                capacity: 20,\n                items: {\n                    gold: finalConfig.gold || resources.INITIAL_GOLD || 0,\n                    scraps_t1_01: resources.INITIAL_SCRAPS || 10,\n                    minerals_t1_01: resources.INITIAL_MINERALS || 10,\n                    minerals_t2_01: resources.INITIAL_MINERALS || 10,\n                    wood_t1_01: resources.INITIAL_WOOD || 10,\n                    food_t1_01: resources.INITIAL_FOOD || 10\n                }\n            });\n        }\n\n        // Combat\n        if (CombatComponent) {\n            this.components.combat = new CombatComponent(this, {\n                damage: finalConfig.attack ? finalConfig.attack.damage : 10,\n                rate: finalConfig.attack ? finalConfig.attack.rate : 2,\n                range: finalConfig.attack ? finalConfig.attack.range.default : 125,\n                staminaCost:\n                    finalConfig.attack && finalConfig.attack.staminaCost !== undefined\n                        ? finalConfig.attack.staminaCost\n                        : 1\n            });\n        }\n\n        // Stats (New Phase 17, expanded 03-hero-stats)\n        if (StatsComponent) {\n            const HD = GameConstants.HeroDefaults;\n            this.components.stats = new StatsComponent(this, {\n                speed: finalConfig.speed ?? getConfig().Hero.SPEED,\n                maxStamina: finalConfig.maxStamina ?? HD.MAX_STAMINA_FALLBACK,\n                stamina: finalConfig.stamina,\n                attack: finalConfig.attack?.damage ?? HD.DEFAULT_ATTACK,\n                defense: finalConfig.defense || 0,\n                critChance: finalConfig.critChance || 0.05,\n                critMultiplier: finalConfig.critMultiplier || 1.5,\n                level: finalConfig.level || 1,\n                xp: finalConfig.xp || 0,\n                xpToNextLevel: finalConfig.xpToNextLevel ?? HD.XP_TO_NEXT_LEVEL,\n                xpScaling: finalConfig.xpScaling ?? HD.XP_SCALING\n            });\n        }\n\n        // Equipment Manager (Phase 18 - Equipment System)\n        if (EquipmentManager) {\n            this.equipment = new EquipmentManager(this);\n\n            // Equip default items from HeroDefaults config\n            if (HeroDefaults && getConfig().Equipment && EntityRegistry?.equipment) {\n                for (const [slot, entityId] of Object.entries(HeroDefaults.equipment)) {\n                    if (entityId && EntityRegistry.equipment[entityId as string]) {\n                        this.equipment.equip(slot, EntityRegistry.equipment[entityId as string]);\n                    }\n                }\n            }\n        }\n\n        // Legacy/Sync Properties (Getters/Setters)\n        // This ensures compatibility with HeroSystem/RestSystem without refactoring them yet\n\n        // Legacy/Sync Properties (Getters/Setters)\n        // We now rely on getters to fetch truth from components.\n        // this.health, this.maxHealth, this.inventory are now virtual.\n\n        // State Flags\n        this.isAtHomeOutpost = false;\n        this.locked = false;\n        this.active = true;\n\n        // Ranges are now read dynamically via getters below\n\n        // Visual State (Used by HeroRenderer/HeroSystem)\n        this.prevX = this.x;\n        this.prevY = this.y;\n        this.footstepTimer = 0;\n        this.footstepInterval = GameConstants.HeroDefaults.FOOTSTEP_INTERVAL;\n        this.attackTimer = 0;\n    }\n\n    // --- Accessors for Components ---\n\n    // Health\n    get health() {\n        return this.components.health ? this.components.health.health : 0;\n    }\n    set health(val) {\n        if (this.components.health) this.components.health.health = val;\n    }\n\n    get maxHealth() {\n        return this.components.health ? this.components.health.maxHealth : GameConstants.HeroDefaults.MAX_HEALTH_FALLBACK;\n    }\n    set maxHealth(val) {\n        if (this.components.health) this.components.health.maxHealth = val;\n    }\n\n    // Inventory\n    get inventory() {\n        return this.components.inventory ? this.components.inventory.items : {};\n    }\n    set inventory(val) {\n        // Warning: Setting inventory directly is discouraged, use component methods\n        if (this.components.inventory) this.components.inventory.items = val;\n    }\n\n    // Stats - Read directly from global GameConstants for HMR reactivity\n    get speed() {\n        // Use getConfig() helper for HMR-safe access\n        return getConfig().Hero.SPEED;\n    }\n    set speed(val) {\n        // Speed is now controlled by GameConstants, this setter is for backwards compatibility\n        Logger.warn(\n            '[Hero] speed setter called but value is controlled by getConfig().Hero.SPEED'\n        );\n    }\n\n    get stamina() {\n        return this.components.stats ? this.components.stats.stamina : 0;\n    }\n    set stamina(val) {\n        if (this.components.stats) this.components.stats.stamina = val;\n    }\n\n    get maxStamina() {\n        return this.components.stats ? this.components.stats.maxStamina : GameConstants.HeroDefaults.MAX_STAMINA_FALLBACK;\n    }\n    set maxStamina(val) {\n        if (this.components.stats) this.components.stats.maxStamina = val;\n    }\n\n    // Level/XP (03-hero-stats)\n    get level() {\n        return this.components.stats?.level || 1;\n    }\n    set level(val) {\n        if (this.components.stats) this.components.stats.level = val;\n    }\n\n    get xp() {\n        return this.components.stats?.xp || 0;\n    }\n    set xp(val) {\n        if (this.components.stats) this.components.stats.xp = val;\n    }\n\n    // Combat (03-hero-stats) - getters delegate to effective stat methods\n    get attack() {\n        return this.components.stats?.getAttack() ?? GameConstants.HeroDefaults.DEFAULT_ATTACK;\n    }\n    get defense() {\n        return this.components.stats?.getDefense() || 0;\n    }\n\n    // Stats component accessor (for HeroCombatService etc)\n    get stats() {\n        return this.components.stats;\n    }\n\n    // Combat ranges - read from config for HMR reactivity\n    get miningRange() {\n        return getConfig().Combat.DEFAULT_MINING_RANGE;\n    }\n\n    get gunRange() {\n        return getConfig().Combat.DEFAULT_GUN_RANGE;\n    }\n\n    /**\n     * Helper to restore stamina (used by RestSystem legacy calls)\n     */\n    restStamina() {\n        if (this.components.stats && EventBus) {\n            EventBus.emit(GameConstants.Events.REQUEST_STAMINA_RESTORE, { hero: this, amount: this.maxStamina });\n        }\n    }\n}\n\n// ES6 Module Export\nexport { Hero };\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\gameplay\\IslandUpgrades.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\gameplay\\Merchant.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Registry' is defined but never used.","line":14,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":18,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"Registry"},"fix":{"range":[553,595],"text":""},"desc":"Remove unused import declaration."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Merchant - NPC entity on each island for purchasing upgrades\r\n *\r\n * Owner: Director (engine), Gameplay Designer (values)\r\n */\r\nimport { Entity } from '@core/Entity';\r\nimport type { IEntity } from '../types/core';\r\nimport { Logger } from '@core/Logger';\r\nimport { MaterialLibrary } from '@vfx/MaterialLibrary';\r\nimport { AssetLoader } from '@core/AssetLoader';\r\nimport { environmentRenderer } from '../rendering/EnvironmentRenderer';\r\nimport { EntityTypes } from '@config/EntityTypes';\r\nimport { EntityRegistry } from '@entities/EntityLoader';\r\nimport { Registry } from '@core/Registry';\r\nimport { getConfig } from '@data/GameConstants';\r\nimport { EntityScaling } from '../utils/EntityScaling';\r\n\r\n// Unmapped modules - need manual import\r\n\r\nclass Merchant extends Entity {\r\n    // Merchant properties\r\n    registryId: string = 'npc_merchant'; // Required for EntityLoader hot-reload\r\n    zoneId: string = 'unknown';\r\n    zoneName: string = 'Unknown Zone';\r\n    interactRadius: number = 140;\r\n    bobTime: number = 0;\r\n    scale: number = 1.0;\r\n\r\n    // Sprite caching\r\n    _img: HTMLImageElement | null = null;\r\n    _shadowImg: HTMLImageElement | HTMLCanvasElement | null = null;\r\n    _imgAssetId: string | null = null;\r\n    _cachedSpriteId: string | null = null;\r\n    _iconImg: HTMLImageElement | null = null;\r\n\r\n    constructor(config: { x?: number; y?: number;[key: string]: unknown } = {}) {\r\n        // 1. Load Config\r\n        const defaults = {\r\n            gridSize: 1.5,\r\n            width: 192,\r\n            height: 192,\r\n            interactRadius: 140,\r\n            color: '#8E44AD'\r\n        };\r\n\r\n        // Determine correct Registry ID based on Zone Name (same logic as Sprite ID)\r\n        const zoneName = config.zoneName || 'Unknown Zone';\r\n\r\n        // If config provides specific ID, use it. Otherwise derive from zone.\r\n        let registryId = config.registryId;\r\n        if (!registryId) {\r\n            const name = zoneName.toLowerCase();\r\n            if (name.includes('quarry')) registryId = 'npc_merchant_01';\r\n            else if (name.includes('iron')) registryId = 'npc_merchant_02';\r\n            else if (name.includes('dead')) registryId = 'npc_merchant_03';\r\n            else if (name.includes('cross')) registryId = 'npc_merchant_04';\r\n            else if (name.includes('scrap')) registryId = 'npc_merchant_05';\r\n            else if (name.includes('mud')) registryId = 'npc_merchant_06';\r\n            else if (name.includes('bone')) registryId = 'npc_merchant_07';\r\n            else if (name.includes('ruins')) registryId = 'npc_merchant_08';\r\n            else registryId = 'npc_merchant_04'; // Default\r\n        }\r\n\r\n        // Lookup with correct ID\r\n        const typeConfig = EntityRegistry.npcs?.[registryId] || EntityRegistry.environment?.[registryId] || {};\r\n\r\n        if (!EntityRegistry.npcs?.[registryId]) {\r\n            Logger.warn(`[Merchant] Registry Lookup FAILED for '${registryId}'. Falling back to defaults.`);\r\n        } else {\r\n            Logger.info(`[Merchant] Registry Lookup SUCCESS for '${registryId}'. Scale: ${typeConfig.scale}`);\r\n        }\r\n\r\n        // Calculate size using standard utility\r\n        const size = EntityScaling.calculateSize(config, typeConfig, { width: 192, height: 192 });\r\n\r\n        const finalConfig = { ...defaults, ...typeConfig, ...config };\r\n\r\n        super({\r\n            entityType: EntityTypes.MERCHANT,\r\n            width: size.width,\r\n            height: size.height,\r\n            color: finalConfig.color || '#8E44AD', // Purple - merchant color\r\n            ...config\r\n        });\r\n\r\n        this.scale = size.scale;\r\n        this.registryId = registryId;\r\n        this.zoneId = config.zoneId || 'unknown';\r\n        this.zoneName = zoneName;\r\n        this.interactRadius = finalConfig.interactRadius || 140;\r\n\r\n        // Animation timer\r\n        this.bobTime = 0;\r\n    }\r\n\r\n    /**\r\n     * Update merchant (idle animation)\r\n     * @param {number} dt - Delta time in ms\r\n     */\r\n    update(dt: number) {\r\n        this.bobTime += dt / 1000;\r\n    }\r\n\r\n    /**\r\n     * Check if hero is in range to interact\r\n     * @param {Hero} hero\r\n     * @returns {boolean}\r\n     */\r\n    isInRange(hero: IEntity) {\r\n        if (!this.active || !hero) return false;\r\n        // Read from config for live dashboard updates\r\n        const radius = getConfig().Interaction?.MERCHANT_RADIUS || this.interactRadius;\r\n        return this.distanceTo(hero) < radius;\r\n    }\r\n\r\n    /**\r\n     * Get the sprite asset ID based on zone theme\r\n     * Maps to numbered IDs: npc_merchant_01 through npc_merchant_08\r\n     */\r\n    getSpriteId() {\r\n        if (!this.zoneName) return 'npc_merchant_04'; // Default: Crossroads\r\n        const name = this.zoneName.toLowerCase();\r\n\r\n        // Biome to numbered ID mapping\r\n        if (name.includes('home'))\r\n            return 'npc_merchant_04'; // No home merchant, use crossroads\r\n        else if (name.includes('quarry')) return 'npc_merchant_01';\r\n        else if (name.includes('iron')) return 'npc_merchant_02';\r\n        else if (name.includes('dead')) return 'npc_merchant_03';\r\n        else if (name.includes('cross')) return 'npc_merchant_04';\r\n        else if (name.includes('scrap')) return 'npc_merchant_05';\r\n        else if (name.includes('mud')) return 'npc_merchant_06';\r\n        else if (name.includes('bone')) return 'npc_merchant_07';\r\n        else if (name.includes('ruins')) return 'npc_merchant_08';\r\n\r\n        return 'npc_merchant_04'; // Default: Crossroads\r\n    }\r\n\r\n    /**\r\n     * Draw shadow for merchant (called by GameRenderer shadow pass)\r\n     */\r\n    /**\r\n     * Draw shadow for merchant (called by GameRenderer shadow pass)\r\n     */\r\n    drawShadow(ctx: CanvasRenderingContext2D, forceOpaque = false) {\r\n        if (!this.active || !this._img) return;\r\n\r\n        // Standard Shadow config\r\n        const env = environmentRenderer;\r\n        let scaleY = 0.3;\r\n        let alpha = 0.3;\r\n        if (env) {\r\n            scaleY = env.shadowScaleY;\r\n            alpha = env.shadowAlpha;\r\n        }\r\n\r\n        const size = this.width; // Use actual entity width\r\n\r\n        // 1. Static Contact Shadow\r\n        ctx.save();\r\n        ctx.translate(this.x, this.y + size / 2 - 6);\r\n\r\n        if (forceOpaque) {\r\n            ctx.fillStyle = 'black';\r\n            ctx.globalAlpha = 1.0;\r\n        } else {\r\n            ctx.fillStyle = 'black';\r\n            ctx.globalAlpha = alpha;\r\n        }\r\n\r\n        const contactWidth = size * 0.4;\r\n        const contactHeight = size * 0.1;\r\n\r\n        ctx.beginPath();\r\n        ctx.ellipse(0, 0, contactWidth / 2, contactHeight / 2, 0, 0, Math.PI * 2);\r\n        ctx.fill();\r\n        ctx.restore();\r\n\r\n        // 2. Dynamic Shadow\r\n        ctx.save();\r\n        ctx.translate(this.x, this.y + size / 2 - 6);\r\n\r\n        const skew = env ? env.shadowSkew || 0 : 0;\r\n        ctx.transform(1, 0, skew, 1, 0, 0);\r\n\r\n        ctx.scale(1, -scaleY);\r\n\r\n        if (forceOpaque) {\r\n            ctx.globalAlpha = 1.0;\r\n        } else {\r\n            ctx.globalAlpha = alpha;\r\n        }\r\n\r\n        // PERF: Cache shadow image on entity (retry until successful)\r\n        if (!this._shadowImg) {\r\n            if (!this._imgAssetId) {\r\n                this._imgAssetId = this.getSpriteId();\r\n            }\r\n            if (MaterialLibrary && this._imgAssetId) {\r\n                this._shadowImg = MaterialLibrary.get(this._imgAssetId, 'shadow', {});\r\n            }\r\n        }\r\n\r\n        if (this._shadowImg) {\r\n            ctx.drawImage(this._shadowImg, -size / 2, -size, size, size);\r\n        }\r\n        // No fallback - skip rendering until shadow loads\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    /**\r\n     * Render merchant\r\n     * @param {CanvasRenderingContext2D} ctx\r\n     */\r\n    render(ctx: CanvasRenderingContext2D) {\r\n        if (!this.active) return;\r\n\r\n        const bob = Math.sin(this.bobTime * 2) * 3;\r\n\r\n        // Try to draw sprite\r\n        if (AssetLoader) {\r\n            // PERF: Cache sprite ID on first call (avoid string ops per frame)\r\n            if (!this._cachedSpriteId) {\r\n                this._cachedSpriteId = this.getSpriteId();\r\n            }\r\n            const id = this._cachedSpriteId;\r\n\r\n            // PERF: Only load image once\r\n            if (!this._img) {\r\n                const path = AssetLoader.getImagePath(id);\r\n                if (path) {\r\n                    this._img = AssetLoader.createImage(path);\r\n                    this._imgAssetId = id;\r\n                }\r\n            }\r\n\r\n            if (this._img && this._img.complete && this._img.naturalWidth) {\r\n                // Use entity dimensions (baked scale)\r\n                const width = this.width;\r\n                const height = this.height;\r\n\r\n                ctx.save();\r\n\r\n                // Sprite (centered)\r\n                // Use height for Y centering to support non-square types\r\n                ctx.drawImage(this._img, this.x - width / 2, this.y - height / 2 + bob, width, height);\r\n\r\n                ctx.restore();\r\n\r\n                // PERF: Cache speech bubble icon (only load once)\r\n                if (!this._iconImg) {\r\n                    const iconPath = AssetLoader.getImagePath('ui_icon_speech_bubble');\r\n                    if (iconPath) {\r\n                        this._iconImg = AssetLoader.createImage(iconPath);\r\n                    }\r\n                }\r\n\r\n                if (this._iconImg && this._iconImg.complete && this._iconImg.naturalWidth) {\r\n                    const iconSize = 64;\r\n                    const hoverOffset = Math.sin(this.bobTime * 3) * 5;\r\n                    // Fix: Use 'height' or 'width' for positioning, 'size' var is gone\r\n                    const iconY = this.y - height / 2 - iconSize + 20 + hoverOffset;\r\n                    ctx.drawImage(this._iconImg, this.x - iconSize / 2, iconY, iconSize, iconSize);\r\n                }\r\n                return;\r\n            }\r\n        }\r\n\r\n        // No fallback - skip rendering until sprite loads\r\n    }\r\n    /**\r\n     * Refresh configuration from EntityRegistry\r\n     */\r\n    refreshConfig() {\r\n        // Find config (Merchants might use island-based logic, or generic NPC logic)\r\n        // For now, look up by generic 'npc_merchant' key or fallback to defaults\r\n        const registryId = this.registryId || 'npc_merchant';\r\n        const typeConfig = EntityRegistry.npcs?.[registryId] || EntityRegistry.environment?.[registryId] || {};\r\n\r\n        Logger.info(`[Merchant] Refreshing config for ${registryId}`);\r\n\r\n        // Update dimensions using standard utility\r\n        EntityScaling.applyToEntity(this, {}, typeConfig, { width: 192, height: 192 });\r\n    }\r\n}\r\n\r\n// ES6 Module Export\r\nexport { Merchant };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\gameplay\\ProgressionSystem.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getConfig' is defined but never used.","line":11,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":34,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"getConfig"},"fix":{"range":[324,335],"text":""},"desc":"Remove unused variable \"getConfig\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'enemy' is assigned a value but never used.","line":33,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":33,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'oldLevel' is assigned a value but never used.","line":46,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":46,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * ProgressionSystem\r\n * Handles XP gain, leveling, and stat increases.\r\n *\r\n * Owner: Gameplay Designer\r\n */\r\nimport { Registry } from '@core/Registry';\r\nimport { EntityRegistry } from '@entities/EntityLoader';\r\nimport { Logger } from '@core/Logger';\r\nimport { EventBus } from '@core/EventBus';\r\nimport { GameConstants, getConfig } from '@data/GameConstants';\r\nimport { IGame, IEntity } from '@app-types/core';\r\n\r\n// Helper to access Events from GameConstants\r\nconst Events = GameConstants.Events;\r\n\r\nconst ProgressionSystem = {\r\n    game: null as IGame | null,\r\n\r\n    init(game: IGame) {\r\n        this.game = game;\r\n        this.initListeners();\r\n        Logger.info('[ProgressionSystem] Initialized');\r\n    },\r\n\r\n    initListeners() {\r\n        if (EventBus) {\r\n            EventBus.on(Events.ENEMY_DIED, (data: { entity?: IEntity; xpReward?: number; [key: string]: unknown }) => this.onEnemyKilled(data));\r\n        }\r\n    },\r\n\r\n    onEnemyKilled(data: { enemy: IEntity; xpReward: number }) {\r\n        const { enemy, xpReward } = data;\r\n        if (!xpReward || !this.game?.hero) return;\r\n\r\n        this.grantXP(this.game.hero, xpReward);\r\n    },\r\n\r\n    /**\r\n     * Grant XP to hero\r\n     */\r\n    grantXP(hero: IEntity, amount: number) {\r\n        const stats = hero.components?.stats;\r\n        if (!stats) return;\r\n\r\n        const oldLevel = stats.level;\r\n        stats.xp += amount;\r\n\r\n        // Emit XP gain event\r\n        if (EventBus) {\r\n            EventBus.emit(Events.XP_GAINED, {\r\n                hero,\r\n                amount,\r\n                total: stats.xp,\r\n                level: stats.level\r\n            });\r\n        }\r\n\r\n        // Check for level up(s) - multiple levels can be gained from one kill\r\n        // Ensure getXPForLevel exists or use safe fallback logic\r\n        const prog = GameConstants?.Progression;\r\n        const getXP = (lvl: number) => {\r\n            const base = prog.XP_BASE;\r\n            const scaling = prog.XP_SCALING;\r\n            return stats.getXPForLevel ? stats.getXPForLevel(lvl) : base * Math.pow(scaling, lvl - 1);\r\n        };\r\n\r\n        let nextLevelXP = getXP(stats.level);\r\n        while (stats.xp >= nextLevelXP) {\r\n            stats.xp -= nextLevelXP;\r\n            stats.level++;\r\n            this.onLevelUp(hero, stats.level);\r\n            nextLevelXP = getXP(stats.level);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Handle level up bonuses\r\n     */\r\n    onLevelUp(hero: IEntity, newLevel: number) {\r\n        const stats = hero.components?.stats;\r\n        const health = hero.components?.health;\r\n\r\n        // Stat increases per level (config-driven)\r\n        // Check hero registry (skin) or use defaults\r\n        const perLevel = EntityRegistry.hero?.['hero']?.levelBonuses || {\r\n            maxHealth: 10,\r\n            attack: 2,\r\n            defense: 1,\r\n            maxStamina: 5\r\n        };\r\n\r\n        // Apply stat gains\r\n        if (health) {\r\n            health.maxHealth += perLevel.maxHealth;\r\n            health.health = health.maxHealth; // Full heal on level\r\n        }\r\n\r\n        if (stats) {\r\n            stats.attack = (stats.attack || 10) + perLevel.attack;\r\n            stats.defense = (stats.defense || 0) + perLevel.defense;\r\n            stats.maxStamina += perLevel.maxStamina;\r\n            stats.stamina = stats.maxStamina; // Full restore\r\n        }\r\n\r\n        if (EventBus) {\r\n            EventBus.emit(Events.HERO_LEVEL_UP, { hero, oldLevel: newLevel - 1, newLevel, levelsGained: 1 });\r\n        }\r\n        Logger.info(`[ProgressionSystem] Hero leveled up to ${newLevel}!`);\r\n    },\r\n\r\n    /**\r\n     * Get XP required for specific level\r\n     */\r\n    getXPForLevel(level: number): number {\r\n        const prog = GameConstants?.Progression;\r\n        const base = EntityRegistry.hero?.['hero']?.xpToNextLevel ?? prog.XP_BASE;\r\n        const scaling = EntityRegistry.hero?.['hero']?.xpScaling ?? prog.XP_SCALING;\r\n        return Math.floor(base * Math.pow(scaling, level - 1));\r\n    },\r\n\r\n    /**\r\n     * Get hero's current XP progress as percentage\r\n     */\r\n    getXPProgress(hero: IEntity): number {\r\n        const stats = hero?.components?.stats;\r\n        if (!stats) return 0;\r\n        // Use local helper or component method if available?\r\n        // Component method is standard if it exists.\r\n        // Assuming component has getXPForLevel?\r\n        // Let's use internal calculator if component doesn't have it, to be safe.\r\n        // But logic above used stats.getXPForLevel...\r\n        // Let's assume stats component matches the logic or we use ours.\r\n        const required = stats.getXPForLevel ? stats.getXPForLevel(stats.level) : this.getXPForLevel(stats.level);\r\n        return stats.xp / required;\r\n    },\r\n\r\n    // Legacy compatibility\r\n    meetsRequirements(requirements: Record<string, unknown> = {}): boolean {\r\n        const hero = this.game?.hero;\r\n        if (!hero) return true;\r\n\r\n        const stats = hero.components?.stats;\r\n        if (requirements.level && stats && stats.level < requirements.level) return false;\r\n        return true;\r\n    },\r\n\r\n    getAvailableUnlocks(): Array<{ id: string; [key: string]: unknown }> {\r\n        return [];\r\n    }\r\n};\r\n\r\nif (Registry) Registry.register('ProgressionSystem', ProgressionSystem);\r\n\r\n// ES6 Module Export\r\nexport { ProgressionSystem };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\gameplay\\QuestManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'dt' is defined but never used. Allowed unused args must match /^_/u.","line":75,"column":12,"nodeType":"Identifier","messageId":"unusedVar","endLine":75,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * QuestManagerService\n * Handles active quests, progress tracking, and completion events.\n * Refactored to Class pattern for consistency.\n */\n\n// Globals: Logger, UIManager, VFXController, AudioManager, Registry are declared in global.d.ts\n\nimport { Logger } from '@core/Logger';\nimport { GameConstants } from '@data/GameConstants';\nimport { EventBus } from '@core/EventBus';\nimport { Registry } from '@core/Registry';\n\ninterface QuestConfig {\n    id: string;\n    type: string;\n    resource: string;\n    target: number;\n    description: string;\n}\n\ninterface ActiveQuest extends QuestConfig {\n    current: number;\n}\n\nclass QuestManagerService {\n    // Property declarations\n    activeQuest: ActiveQuest | null;\n    quests: QuestConfig[];\n    questIndex: number;\n\n    constructor() {\n        this.activeQuest = null;\n\n        // Configurable quest line (using entity IDs)\n        this.quests = [\n            {\n                id: 'q1',\n                type: 'collect',\n                resource: 'wood_t1_01',\n                target: 5,\n                description: 'Gather 5 Wood'\n            },\n            {\n                id: 'q2',\n                type: 'collect',\n                resource: 'scraps_t1_01',\n                target: 3,\n                description: 'Gather 3 Scrap Metal'\n            },\n            {\n                id: 'q3',\n                type: 'collect',\n                resource: 'minerals_t1_01',\n                target: 2,\n                description: 'Gather 2 Iron Ore'\n            }\n        ];\n        this.questIndex = 0;\n\n        Logger.info('[QuestManager] Initialized Service');\n    }\n\n    init() {\n        Logger.info('[QuestManager] Starting Quest Chain...');\n        this.startQuest(this.quests[0]);\n    }\n\n    /**\n     * Update loop (required for System registration)\n     */\n    /**\n     * Update loop (required for System registration)\n     */\n    update(dt: number) {\n        // Quest update logic if needed\n    }\n\n    /**\n     * Start a specific quest\n     */\n    startQuest(questConfig: QuestConfig | null) {\n        if (!questConfig) {\n            Logger.info('[QuestManager] No more quests!');\n            this.activeQuest = null;\n            if (EventBus && GameConstants?.Events) {\n                EventBus.emit(GameConstants.Events.QUEST_UPDATED, { quest: null, animate: false });\n            }\n            return;\n        }\n\n        this.activeQuest = {\n            ...questConfig,\n            current: 0\n        };\n\n        Logger.info(`[QuestManager] Started Quest: ${this.activeQuest.description}`);\n        this.updateUI();\n    }\n\n    /**\n     * Handle resource collection event\n     */\n    /**\n     * Handle resource collection event\n     */\n    onCollect(resourceType: string, amount: number) {\n        if (!this.activeQuest) return;\n\n        // Check if collected resource matches quest requirement\n        if (this.activeQuest.type === 'collect' && this.activeQuest.resource === resourceType) {\n            const oldCurrent = this.activeQuest.current;\n            this.activeQuest.current += amount;\n\n            // Cap at target\n            if (this.activeQuest.current > this.activeQuest.target) {\n                this.activeQuest.current = this.activeQuest.target;\n            }\n\n            Logger.info(\n                `[QuestManager] Progress: ${this.activeQuest.current}/${this.activeQuest.target}`\n            );\n            this.updateUI(true); // true = animate\n\n            // Check completion\n            if (\n                this.activeQuest.current >= this.activeQuest.target &&\n                oldCurrent < this.activeQuest.target\n            ) {\n                this.completeQuest();\n            }\n        }\n    }\n\n    /**\n     * Complete the current quest\n     */\n    completeQuest() {\n        Logger.info('[QuestManager] Quest Complete!');\n\n        // VFX: Quest Complete Popup\n        const VFXController = Registry?.get('VFXController');\n        const UIManagerVFX = Registry?.get('UIManager');\n        if (VFXController && UIManagerVFX) {\n            // Find UI element for Quest Panel to explode it\n            const panel = document.getElementById('ui-quest-panel');\n            if (panel && VFXController.triggerUIExplosion) {\n                VFXController.triggerUIExplosion(panel, '#FFFF00');\n            }\n        }\n\n        // SFX\n        const AudioManager = Registry?.get('AudioManager');\n        if (AudioManager) {\n            AudioManager.playSFX('sfx_ui_unlock'); // Reusing unlock sound\n        }\n\n        // Delay next quest\n        setTimeout(() => {\n            this.questIndex++;\n            this.startQuest(this.quests[this.questIndex]);\n        }, GameConstants.Quest.NEXT_QUEST_DELAY_MS);\n    }\n\n    /**\n     * Update UI elements (emits event; UIManager subscribes and updates quest panel)\n     */\n    updateUI(animate: boolean = false) {\n        if (EventBus && GameConstants?.Events) {\n            EventBus.emit(GameConstants.Events.QUEST_UPDATED, {\n                quest: this.activeQuest,\n                animate\n            });\n        }\n    }\n}\n\n// Ambient declarations for not-yet-migrated modules\n\nconst QuestManager = new QuestManagerService();\nif (Registry) Registry.register('QuestManager', QuestManager);\n\nexport { QuestManager, QuestManagerService };\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\gameplay\\Resource.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Registry' is defined but never used.","line":19,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":18,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"Registry"},"fix":{"range":[759,801],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'mapGenParams' is assigned a value but never used.","line":112,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":112,"endColumn":35}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Resource - Collectible resource entity with health\r\n *\r\n * Per GDD: Player spends stamina to damage resource, depleting health to collect.\r\n *\r\n * Owner: Director (engine), Gameplay Designer (values), Lore Writer (names)\r\n */\r\nimport { Entity } from '@core/Entity';\r\nimport { Logger } from '@core/Logger';\r\nimport { WorldManager } from '../world/WorldManager';\r\nimport { AudioManager } from '../audio/AudioManager';\r\nimport { VFXController } from '@vfx/VFXController';\r\nimport { IEntity } from '../types/core';\r\nimport { spawnResourceDrops } from './ResourceDrops';\r\nimport { ProgressBarRenderer } from '@vfx/ProgressBarRenderer';\r\nimport { GameConstants, getConfig } from '@data/GameConstants';\r\nimport { EntityTypes } from '@config/EntityTypes';\r\n\r\nimport { Registry } from '@core/Registry';\r\nimport { EntityRegistry } from '@entities/EntityLoader';\r\nimport { EntityScaling } from '../utils/EntityScaling';\r\nimport { RESOURCE_COLORS, RESOURCE_RARITY, RESOURCE_RARITY_COLORS } from './ResourceConstants';\r\n\r\nclass Resource extends Entity {\r\n    // Resource identity\r\n    registryId: string | null = null; // Set in constructor\r\n    resourceType: string = 'scraps_t1_01';\r\n    nodeSubtype: string | null = null;\r\n    amount: number = 1;\r\n    interactRadius: number = 145;\r\n    scale: number = 1.0;\r\n\r\n    // Health system\r\n    maxHealth: number = 30;\r\n    health: number = 30;\r\n\r\n    // State\r\n    state: string = 'ready';\r\n    respawnTimer: number = 0;\r\n    maxRespawnTime: number = 30;\r\n\r\n\r\n    // Respawn tracking\r\n    currentRespawnDuration: number = 30;\r\n\r\n    /**\r\n     * Create a resource\r\n     * @param {object} config\r\n     */\r\n    constructor(config: { resourceType?: string; x?: number; y?: number;[key: string]: unknown } = {}) {\r\n        // 1. Load Config from EntityRegistry (nodes or resources)\r\n        const nodeConfig = EntityRegistry.nodes?.[config.resourceType];\r\n        const resConfig = EntityRegistry.resources?.[config.resourceType];\r\n\r\n        const typeConfig = nodeConfig || resConfig || {};\r\n\r\n        if (!nodeConfig && !resConfig) {\r\n            Logger.warn(`[Resource] Registry Lookup FAILED for '${config.resourceType}'`);\r\n        }\r\n        // Calculate size using standard utility\r\n        const size = EntityScaling.calculateSize(config, typeConfig, { width: 150, height: 150 });\r\n        // Merge\r\n        const finalConfig = { ...typeConfig, ...config };\r\n\r\n        super({\r\n            entityType: EntityTypes.RESOURCE,\r\n            width: size.width,\r\n            height: size.height,\r\n            collision: finalConfig.collision, // Pass merged collision config\r\n            ...config\r\n        });\r\n\r\n        // Store scale\r\n        this.scale = size.scale;\r\n\r\n        this.resourceType = config.resourceType || 'scraps_t1_01';\r\n        this.registryId = this.resourceType; // Enable standardized EntityLoader matching\r\n\r\n        // Extract nodeSubtype from config or parse from resourceType (node_mining_t1_01 ? mining)\r\n        if (finalConfig.nodeSubtype) {\r\n            this.nodeSubtype = finalConfig.nodeSubtype;\r\n        } else if (this.resourceType.startsWith('node_')) {\r\n            // Parse from ID like node_mining_t1_01 ? mining\r\n            const match = this.resourceType.match(/^node_([a-z]+)_t\\d/);\r\n            this.nodeSubtype = match ? match[1] : 'mining';\r\n        } else {\r\n            this.nodeSubtype = null;\r\n        }\r\n\r\n        this.amount = finalConfig.amount || 1;\r\n        this.interactRadius =\r\n            finalConfig.interactRadius || getConfig().Combat?.DEFAULT_MINING_RANGE || 150;\r\n\r\n        // Health system\r\n        this.maxHealth = finalConfig.maxHealth || 30;\r\n        this.health = this.maxHealth;\r\n\r\n        // Set color based on type\r\n        this.color = finalConfig.color || '#888888';\r\n\r\n        // State: 'ready' or 'depleted'\r\n        this.state = 'ready';\r\n        this.respawnTimer = 0;\r\n        this.maxRespawnTime = finalConfig.respawnTime || 30;\r\n\r\n        // Domain Rule: Home Island (Starter Zone) strictly allows only Wood\r\n        // Map-placed entities (from map editor) bypass this rule - user explicitly placed them\r\n        const isMapPlaced = !!config.isMapPlaced;\r\n        if (!isMapPlaced) {\r\n            let onHome = false;\r\n            if (WorldManager) {\r\n                const mapGenParams = WorldManager.getMapgen4Param();\r\n                // To maintain parity, we can assume town index 0 is \"home\" conceptually,\r\n                // or just allow all nodes. We'll simply let all map nodes spawn.\r\n                onHome = true;\r\n            }\r\n\r\n            // Home island allows T1 nodes (trees in starter area)\r\n            const isT1Node = this.resourceType.includes('_t1_');\r\n            if (onHome && !isT1Node) {\r\n                this.active = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update resource state\r\n     * Logic moved to ResourceSystem.js (ECS)\r\n     * @param {number} dt\r\n     */\r\n    update(_dt: number) {\r\n        // Handled by ResourceSystem\r\n    }\r\n\r\n    /**\r\n     * Respawn the resource\r\n     * Logic moved to ResourceSystem.js\r\n     */\r\n    respawn() {\r\n        // Handled by ResourceSystem\r\n    }\r\n\r\n    /**\r\n     * Check if hero is close enough to interact\r\n     * @param {Hero} hero\r\n     * @returns {boolean}\r\n     */\r\n    isInRange(hero: IEntity) {\r\n        return this.active && this.state === 'ready' && this.distanceTo(hero) < this.interactRadius;\r\n    }\r\n\r\n    /**\r\n     * Take damage from hero attack\r\n     * @param {number} damage\r\n     * @returns {boolean} True if resource yielded loot\r\n     */\r\n    takeDamage(damage: number) {\r\n        if (this.state !== 'ready') return false;\r\n\r\n        // SFX: Mining Impact (unique per resource type)\r\n        if (AudioManager) {\r\n            const sfxId = `sfx_mine_${this.resourceType}`;\r\n            AudioManager.playSFX(sfxId);\r\n        }\r\n\r\n        // Visual Impact VFX (Hit)\r\n        if (VFXController) {\r\n            // 1. Sparks (Immediate stick)\r\n            VFXController.playForeground(this.x, this.y, {\r\n                type: 'spark',\r\n                color: '#FFFFFF',\r\n                count: 12,\r\n                speed: 12,\r\n                lifetime: GameConstants.Resource.VFX_SPARK_LIFETIME,\r\n                size: 10\r\n            });\r\n\r\n            // 2. Small Debris Chips\r\n            VFXController.playForeground(this.x, this.y, {\r\n                type: 'debris',\r\n                color: this.color,\r\n                count: 15,\r\n                speed: 10,\r\n                lifetime: 600,\r\n                gravity: 0.3,\r\n                size: 8\r\n            });\r\n        }\r\n\r\n        this.health -= damage;\r\n        if (this.health <= 0) {\r\n            // SFX: Break - use config-driven sfxSuffix\r\n            if (AudioManager) {\r\n                const typeConfig = EntityRegistry.resources?.[this.resourceType] || {};\r\n                const suffix = typeConfig.sfxSuffix || 'metal';\r\n                AudioManager.playSFX(`sfx_resource_break_${suffix}`);\r\n            }\r\n\r\n            this.health = 0;\r\n            this.state = 'depleted';\r\n\r\n            if (this.resourceType.includes('_t1_')) {\r\n                this.maxRespawnTime = GameConstants.Resource.T1_FAST_RESPAWN;\r\n            } else {\r\n                const defaultBase = GameConstants.Resource.DEFAULT_BASE_RESPAWN;\r\n                this.maxRespawnTime = (Resource.TYPES[this.resourceType] as { baseRespawnTime?: number } | undefined)?.baseRespawnTime ?? defaultBase;\r\n            }\r\n            this.respawnTimer = this.maxRespawnTime;\r\n\r\n            spawnResourceDrops(this.x, this.y, this.amount, this.resourceType);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Recalculate respawn timer based on current upgrades\r\n     * Handles proportional time reduction if already respawning\r\n     */\r\n    recalculateRespawnTimer() {\r\n        if (!WorldManager) return;\r\n\r\n        // Calculate new total duration\r\n        let newDuration = this.maxRespawnTime; // Default base\r\n\r\n        // Base value lookup\r\n        const typeConfig = EntityRegistry.resources?.[this.resourceType] || {};\r\n        const defaultBase = GameConstants.Resource.DEFAULT_BASE_RESPAWN;\r\n        newDuration = typeConfig.respawnTime ?? defaultBase;\r\n\r\n        // If depleted/respawning, scale remaining time\r\n        const currentTotal = this.currentRespawnDuration || this.maxRespawnTime;\r\n\r\n        if (this.state === 'depleted' && currentTotal > 0) {\r\n            const completionPct = 1 - this.respawnTimer / currentTotal;\r\n            this.respawnTimer = newDuration * (1 - completionPct);\r\n        }\r\n\r\n        this.maxRespawnTime = newDuration; // Update property\r\n        this.currentRespawnDuration = newDuration; // Sync tracking\r\n    }\r\n\r\n    /**\r\n     * Get health percentage\r\n     * @returns {number} 0-1\r\n     */\r\n    getHealthPercent() {\r\n        return this.health / this.maxHealth;\r\n    }\r\n\r\n    /**\r\n     * Render resource with health bar\r\n     * @param {CanvasRenderingContext2D} ctx\r\n     */\r\n    render(_ctx: CanvasRenderingContext2D) {\r\n        // Handled by ResourceRenderer\r\n    }\r\n\r\n    /**\r\n     * Render health bar (UI Layer)\r\n     * @param {CanvasRenderingContext2D} ctx\r\n     */\r\n    renderUI(ctx: CanvasRenderingContext2D) {\r\n        // Health bar (above resource)\r\n        this.renderHealthBar(ctx);\r\n    }\r\n\r\n    /**\r\n     * Render health bar above resource using ProgressBarRenderer\r\n     * @param {CanvasRenderingContext2D} ctx\r\n     */\r\n    renderHealthBar(ctx: CanvasRenderingContext2D) {\r\n        // Only show if damaged\r\n        if (this.health >= this.maxHealth) return;\r\n        if (this.state === 'depleted') return;\r\n\r\n        const barWidth = GameConstants.Resource.HEALTH_BAR_WIDTH;\r\n        const barHeight = 14;\r\n        const barX = this.x - barWidth / 2;\r\n        const barYOffset = GameConstants.Resource.HEALTH_BAR_Y_OFFSET;\r\n        const barY = this.y - this.height / 2 - barYOffset;\r\n\r\n        if (ProgressBarRenderer) {\r\n            ProgressBarRenderer.draw(ctx, {\r\n                x: barX,\r\n                y: barY,\r\n                width: barWidth,\r\n                height: barHeight,\r\n                percent: this.getHealthPercent(),\r\n                mode: 'health',\r\n                entityId: this.id,\r\n                animated: true\r\n            });\r\n        } else {\r\n            ctx.fillStyle = '#4CAF50';\r\n            ctx.fillRect(barX, barY, barWidth * this.getHealthPercent(), barHeight);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Refresh configuration from EntityRegistry\r\n     * Called by EntityLoader on live update\r\n     */\r\n    refreshConfig() {\r\n        // Look up latest config\r\n        const typeConfig =\r\n            EntityRegistry.nodes?.[this.resourceType] ||\r\n            EntityRegistry.resources?.[this.resourceType] ||\r\n            {};\r\n\r\n        Logger.info(`[Resource] Refreshing config for ${this.resourceType}`);\r\n\r\n        // Update dimensions using standard utility\r\n        // Note: passing empty instance config {} because we want to reset to registry values\r\n        // unless we want to persist instance overrides?\r\n        // Usually hot-reload implies we want to see the new registry values.\r\n        EntityScaling.applyToEntity(this, {}, typeConfig, { width: 120, height: 120 });\r\n    }\r\n\r\n    static COLORS = RESOURCE_COLORS;\r\n    static RARITY = RESOURCE_RARITY;\r\n    static RARITY_COLORS = RESOURCE_RARITY_COLORS;\r\n    static TYPES: Record<string, { baseRespawnTime?: number;[key: string]: unknown }> = {};\r\n}\r\n\r\n// ES6 Module Export\r\nexport { Resource };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\gameplay\\ResourceConstants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\gameplay\\ResourceDrops.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\gameplay\\SpawnHelper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\input\\InputSystem.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getConfig' is defined but never used.","line":14,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":34,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"getConfig"},"fix":{"range":[360,371],"text":""},"desc":"Remove unused variable \"getConfig\"."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * InputSystem - Central Input Aggregator\n *\n * Aggregates input from Keyboard, Touch, and Gamepad adapters.\n * Emits standardized events via EventBus.\n *\n * Update: Supports Intent-based mapping (Keys -> Actions)\n *\n * Owner: Core Infrastructure\n */\n\nimport { Logger } from '@core/Logger';\nimport { EventBus } from '@core/EventBus';\nimport { GameConstants, getConfig } from '@data/GameConstants';\nimport { Registry } from '@core/Registry';\nimport type { IGame } from '../types/core';\n\ninterface InputAdapter {\n    poll(): {\n        move?: { x: number; y: number };\n        action?: boolean;\n        heldKeys?: Set<string>;\n    } | null;\n}\n\nclass InputSystem {\n    // game reference stored via init()\n    private game: IGame | null = null;\n    private adapters: InputAdapter[] = [];\n    private inputState = {\n        move: { x: 0, y: 0 },\n        action: false,\n        intents: new Set<string>()\n    };\n\n    // Default Bindings (Action Name -> Key/Input IDs)\n    private bindings: Record<string, string[]> = {\n        INTERACT: ['e', 'E', 'Enter'],\n        MENU: ['Escape', 'p', 'P']\n    };\n\n    constructor() {\n        Logger.info('[InputSystem] Initialized');\n    }\n\n    init(game: IGame): void {\n        this.game = game;\n    }\n\n    registerAdapter(adapter: InputAdapter): void {\n        this.adapters.push(adapter);\n    }\n\n    update(): void {\n        let moveX = 0;\n        let moveY = 0;\n        let action = false;\n\n        const currentFrameIntents = new Set<string>();\n\n        for (const adapter of this.adapters) {\n            const state = adapter.poll();\n            if (state) {\n                // 1. Move Vector\n                if (state.move) {\n                    moveX += state.move.x;\n                    moveY += state.move.y;\n                }\n\n                // 2. Legacy Action\n                if (state.action) {\n                    action = true;\n                }\n\n                // 3. Intent Mapping (Keyboard)\n                if (state.heldKeys) {\n                    for (const [intent, keys] of Object.entries(this.bindings)) {\n                        for (const key of keys) {\n                            if (state.heldKeys.has(key)) {\n                                currentFrameIntents.add(intent);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // Normalize Move\n        const len = Math.sqrt(moveX * moveX + moveY * moveY);\n        if (len > 1) {\n            moveX /= len;\n            moveY /= len;\n        }\n\n        // Emit Move Event ONLY if changed\n        if (moveX !== this.inputState.move.x || moveY !== this.inputState.move.y) {\n            this.inputState.move.x = moveX;\n            this.inputState.move.y = moveY;\n            EventBus.emit(GameConstants.Events.INPUT_MOVE, { x: moveX, y: moveY });\n        }\n\n        // Emit Intent Events (Start/End)\n        // Check for New Intents (Pressed this frame)\n        for (const intent of currentFrameIntents) {\n            if (!this.inputState.intents.has(intent)) {\n                EventBus.emit(GameConstants.Events.INPUT_INTENT, {\n                    intent: intent,\n                    phase: 'START'\n                });\n            }\n        }\n\n        // Check for Released Intents\n        for (const intent of this.inputState.intents) {\n            if (!currentFrameIntents.has(intent)) {\n                EventBus.emit(GameConstants.Events.INPUT_INTENT, {\n                    intent: intent,\n                    phase: 'END'\n                });\n            }\n        }\n\n        this.inputState.intents = currentFrameIntents;\n\n        // Legacy Action Pulse (kept for compatibility)\n        if (action && !this.inputState.action) {\n            EventBus.emit(GameConstants.Events.INPUT_ACTION);\n        }\n        this.inputState.action = action;\n    }\n\n    /**\n     * Check if an intent is currently active (button held down)\n     */\n    hasIntent(intent: string): boolean {\n        return this.inputState.intents.has(intent);\n    }\n}\n\n// Create and export singleton instance\nconst inputSystem = new InputSystem();\nif (Registry) Registry.register('InputSystem', inputSystem);\nexport { InputSystem, inputSystem };\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\input\\adapters\\GamepadAdapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\input\\adapters\\KeyboardAdapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\input\\adapters\\TouchAdapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\main.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\rendering\\DebugOverlays.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getConfig' is defined but never used.","line":10,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":34,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"getConfig"},"fix":{"range":[259,270],"text":""},"desc":"Remove unused variable \"getConfig\"."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * DebugOverlays - Debug visualization overlays for development\r\n *\r\n * Extracted from GameRenderer.js for modularity.\r\n * Handles debug grid, collision blocks, and world boundary rendering.\r\n *\r\n * Owner: Development Tools\r\n */\r\n\r\nimport { GameConstants, getConfig } from '@data/GameConstants';\r\nimport { IGame, IViewport } from '@app-types/core';\r\n\r\nconst DebugOverlays = {\r\n    /**\r\n     * Draw world boundary indicator\r\n     */\r\n    drawWorldBoundary(ctx: CanvasRenderingContext2D, viewport: IViewport, worldWidth: number, worldHeight: number, game: IGame) {\r\n        ctx.save();\r\n        ctx.translate(-viewport.x, -viewport.y);\r\n\r\n        // Draw world border\r\n        ctx.strokeStyle = 'rgba(212, 175, 55, 0.5)';\r\n        ctx.lineWidth = 4;\r\n        ctx.strokeRect(0, 0, worldWidth, worldHeight);\r\n\r\n        // DEBUG: Show Collision Blocks (Red)\r\n        const islandManager = game ? game.getSystem('WorldManager') as typeof import('../world/WorldManager').WorldManager : null;\r\n        if (islandManager && islandManager.collisionBlocks) {\r\n            ctx.strokeStyle = '#FF0000';\r\n            ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';\r\n            ctx.lineWidth = 1;\r\n\r\n            for (const block of islandManager.collisionBlocks) {\r\n                ctx.beginPath();\r\n                ctx.rect(block.x, block.y, block.width, block.height);\r\n                ctx.fill();\r\n                ctx.stroke();\r\n            }\r\n\r\n            // Draw debug grid\r\n            const bounds = {\r\n                left: viewport.x,\r\n                top: viewport.y,\r\n                right: viewport.x + viewport.width,\r\n                bottom: viewport.y + viewport.height\r\n            };\r\n            this.drawDebugGrid(ctx, bounds);\r\n        }\r\n\r\n        ctx.restore();\r\n    },\r\n\r\n    /**\r\n     * Draw 128px gameplay grid overlay (debug only)\r\n     */\r\n    drawDebugGrid(ctx: CanvasRenderingContext2D, bounds: { left: number; top: number; right: number; bottom: number }) {\r\n        const cellSize = GameConstants ? GameConstants.Grid.CELL_SIZE : 128;\r\n\r\n        const startGx = Math.floor(bounds.left / cellSize);\r\n        const startGy = Math.floor(bounds.top / cellSize);\r\n        const endGx = Math.ceil(bounds.right / cellSize);\r\n        const endGy = Math.ceil(bounds.bottom / cellSize);\r\n\r\n        ctx.strokeStyle = 'rgba(255, 255, 0, 0.3)';\r\n        ctx.lineWidth = 1;\r\n        ctx.font = '10px monospace';\r\n        ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';\r\n\r\n        // Vertical lines\r\n        for (let gx = startGx; gx <= endGx; gx++) {\r\n            const x = gx * cellSize;\r\n            ctx.beginPath();\r\n            ctx.moveTo(x, bounds.top);\r\n            ctx.lineTo(x, bounds.bottom);\r\n            ctx.stroke();\r\n        }\r\n\r\n        // Horizontal lines\r\n        for (let gy = startGy; gy <= endGy; gy++) {\r\n            const y = gy * cellSize;\r\n            ctx.beginPath();\r\n            ctx.moveTo(bounds.left, y);\r\n            ctx.lineTo(bounds.right, y);\r\n            ctx.stroke();\r\n        }\r\n\r\n        // Cell labels\r\n        ctx.fillStyle = 'rgba(255, 255, 0, 0.7)';\r\n        ctx.font = 'bold 32px monospace';\r\n        ctx.textAlign = 'center';\r\n        ctx.textBaseline = 'middle';\r\n\r\n        for (let gx = startGx; gx <= endGx; gx++) {\r\n            for (let gy = startGy; gy <= endGy; gy++) {\r\n                const centerX = gx * cellSize + cellSize / 2;\r\n                const centerY = gy * cellSize + cellSize / 2;\r\n                ctx.fillText(`X${gx}`, centerX, centerY - 20);\r\n                ctx.fillText(`Y${gy}`, centerX, centerY + 20);\r\n            }\r\n        }\r\n\r\n        ctx.textAlign = 'left';\r\n        ctx.textBaseline = 'alphabetic';\r\n    }\r\n};\r\n\r\nexport { DebugOverlays };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\rendering\\DinosaurRenderer.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'game' is defined but never used. Allowed unused args must match /^_/u.","line":19,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * DinosaurRenderer\r\n * Handles rendering for all dinosaurs.\r\n */\r\n\r\nimport { Logger } from '@core/Logger';\r\nimport { MaterialLibrary } from '@vfx/MaterialLibrary';\r\nimport { ProgressBarRenderer } from '@vfx/ProgressBarRenderer';\r\nimport { Registry } from '@core/Registry';\r\nimport { environmentRenderer } from './EnvironmentRenderer';\r\nimport { Dinosaur } from '../gameplay/Dinosaur';\r\nimport type { IGame, ISystem } from '../types/core';\r\n\r\nclass DinosaurRendererService implements ISystem {\r\n    constructor() {\r\n        Logger.info('[DinosaurRenderer] Initialized');\r\n    }\r\n\r\n    init(game: IGame): void { }\r\n\r\n    render(ctx: CanvasRenderingContext2D, dino: Dinosaur, includeShadow = true, alpha = 1) {\r\n        if (!dino.active) return;\r\n\r\n        // Interpolation\r\n        const prevX = (dino.prevX !== undefined) ? dino.prevX : dino.x;\r\n        const prevY = (dino.prevY !== undefined) ? dino.prevY : dino.y;\r\n\r\n        const renderX = prevX + (dino.x - prevX) * alpha;\r\n        const renderY = prevY + (dino.y - prevY) * alpha;\r\n\r\n        const originalX = dino.x;\r\n        const originalY = dino.y;\r\n\r\n        // Apply interpolated coordinates for rendering\r\n        dino.x = renderX;\r\n        dino.y = renderY;\r\n\r\n        try {\r\n            // Shadow\r\n            if (includeShadow) {\r\n                this.renderShadow(ctx, dino);\r\n            }\r\n\r\n            // Dead State\r\n            if (dino.state === 'dead') {\r\n                this.renderDead(ctx, dino);\r\n                return;\r\n            }\r\n\r\n            // Alive State\r\n            ctx.save();\r\n\r\n            // 1. Sprite Render (modern: single sprite via _sprite)\r\n            if (dino._spriteLoaded && dino._sprite) {\r\n                const flipX = dino.wanderDirection.x < 0;\r\n                ctx.translate(dino.x, dino.y);\r\n                if (flipX) ctx.scale(-1, 1);\r\n                ctx.drawImage(dino._sprite, -dino.width / 2, -dino.height / 2, dino.width, dino.height);\r\n            }\r\n            // No fallback - just skip rendering until sprite loads\r\n\r\n            ctx.restore();\r\n        } finally {\r\n            dino.x = originalX;\r\n            dino.y = originalY;\r\n        }\r\n    }\r\n\r\n    // ... rest of methods ...\r\n    renderShadow(ctx: CanvasRenderingContext2D, dino: Dinosaur, forceOpaque = false) {\r\n        // Check environmentRenderer singleton for dynamic shadows\r\n        const env = environmentRenderer;\r\n\r\n        let scaleY = 0.3;\r\n        let alpha = 0.3;\r\n\r\n        if (env) {\r\n            scaleY = env.shadowScaleY;\r\n            alpha = env.shadowAlpha;\r\n        }\r\n\r\n        // 1. Static Contact Shadow\r\n        ctx.save();\r\n        ctx.translate(dino.x, dino.y + dino.height / 2 - 6);\r\n\r\n        if (forceOpaque) {\r\n            ctx.fillStyle = 'black';\r\n            ctx.globalAlpha = 1.0;\r\n        } else {\r\n            ctx.fillStyle = 'black';\r\n            ctx.globalAlpha = alpha;\r\n        }\r\n\r\n        const contactWidth = dino.width * 0.7; // Wider for dino\r\n        const contactHeight = dino.height * 0.2;\r\n\r\n        ctx.beginPath();\r\n        ctx.ellipse(0, 0, contactWidth / 2, contactHeight / 2, 0, 0, Math.PI * 2);\r\n        ctx.fill();\r\n        ctx.restore();\r\n\r\n        // 2. Dynamic Shadow\r\n        ctx.save();\r\n        ctx.translate(dino.x, dino.y + dino.height / 2 - 6); // Pivot at feet\r\n\r\n        const skew = env ? env.shadowSkew || 0 : 0;\r\n        ctx.transform(1, 0, skew, 1, 0, 0);\r\n\r\n        // Flip & Scale\r\n        ctx.scale(1, -scaleY);\r\n\r\n        if (forceOpaque) {\r\n            ctx.globalAlpha = 1.0;\r\n            ctx.fillStyle = 'black';\r\n        } else {\r\n            ctx.globalAlpha = alpha;\r\n            ctx.fillStyle = 'black';\r\n        }\r\n\r\n        // 1. Sprite Render (Silhouette)\r\n        // We need to find the correct sprite frame just like render() does\r\n        // 1. Sprite Render (Silhouette)\r\n        // Use _sprite directly\r\n        let sprite = dino._sprite;\r\n\r\n        if (dino.walkFrames && dino.walkFrames.length > 0) {\r\n            const frame = dino.walkFrames[dino.frameIndex];\r\n            if (frame instanceof HTMLImageElement) {\r\n                sprite = frame;\r\n            }\r\n        }\r\n\r\n        if (dino._spriteLoaded && sprite) {\r\n            const flipX = dino.wanderDirection.x < 0;\r\n\r\n            // Handle Horizontal Flip\r\n            if (flipX) {\r\n                ctx.scale(-1, 1);\r\n            }\r\n\r\n            // PERF: Cache shadow on entity (retry until successful)\r\n            if (!dino._shadowImg) {\r\n                if (MaterialLibrary) {\r\n                    const baseShadowId = 'dino_' + (dino.dinoType || 'base') + '_base';\r\n                    dino._shadowImg = MaterialLibrary.get(baseShadowId, 'shadow', {});\r\n                }\r\n            }\r\n\r\n            if (dino._shadowImg) {\r\n                // Draw anchored at bottom\r\n                // Use actual dimensions\r\n                ctx.drawImage(\r\n                    dino._shadowImg,\r\n                    -dino.width / 2,\r\n                    -dino.height,\r\n                    dino.width,\r\n                    dino.height\r\n                );\r\n            }\r\n        }\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    renderDead(ctx: CanvasRenderingContext2D, dino: Dinosaur) {\r\n        ctx.save();\r\n        ctx.fillStyle = '#444';\r\n        ctx.beginPath();\r\n        ctx.ellipse(dino.x, dino.y + 20, 40, 20, 0, 0, Math.PI * 2);\r\n        ctx.fill();\r\n\r\n        // Tombstone\r\n        ctx.fillStyle = '#666';\r\n        ctx.beginPath();\r\n        ctx.roundRect(dino.x - 30, dino.y - 30, 60, 60, 10);\r\n        ctx.fill();\r\n\r\n        // Skull\r\n        ctx.strokeStyle = '#222';\r\n        ctx.lineWidth = 6;\r\n        ctx.beginPath();\r\n        ctx.moveTo(dino.x - 16, dino.y - 16);\r\n        ctx.lineTo(dino.x + 16, dino.y + 16);\r\n        ctx.moveTo(dino.x + 16, dino.y - 16);\r\n        ctx.lineTo(dino.x - 16, dino.y + 16);\r\n        ctx.stroke();\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    renderUI(ctx: CanvasRenderingContext2D, dino: Dinosaur) {\r\n        if (!dino.active) return;\r\n\r\n        // Dead State: Respawn Bar\r\n        if (dino.state === 'dead') {\r\n            // Draw Respawn Progress Bar (High-Dopamine)\r\n            const barWidth = 120;\r\n            const barHeight = 14;\r\n            const barX = dino.x - barWidth / 2;\r\n            const barY = dino.y - 60;\r\n\r\n            const totalDuration = dino.maxRespawnTime;\r\n            const pct = Math.max(0, 1 - dino.respawnTimer / totalDuration);\r\n\r\n            if (ProgressBarRenderer) {\r\n                ProgressBarRenderer.draw(ctx, {\r\n                    x: barX,\r\n                    y: barY,\r\n                    width: barWidth,\r\n                    height: barHeight,\r\n                    percent: pct,\r\n                    mode: 'respawn',\r\n                    animated: true\r\n                });\r\n            } else {\r\n                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';\r\n                ctx.fillRect(barX, barY, barWidth, barHeight);\r\n                ctx.fillStyle = '#3498DB';\r\n                ctx.fillRect(barX, barY, barWidth * pct, barHeight);\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Alive State: Health Bar\r\n        if (dino.health < dino.maxHealth) {\r\n            const barWidth = 120;\r\n            const barHeight = 14;\r\n            const barX = dino.x - barWidth / 2;\r\n            const barY = dino.y - dino.height / 2 - 30;\r\n\r\n            const healthPercent = dino.health / dino.maxHealth;\r\n\r\n            if (ProgressBarRenderer) {\r\n                ProgressBarRenderer.draw(ctx, {\r\n                    x: barX,\r\n                    y: barY,\r\n                    width: barWidth,\r\n                    height: barHeight,\r\n                    percent: healthPercent,\r\n                    mode: 'health',\r\n                    animated: true\r\n                });\r\n            } else {\r\n                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';\r\n                ctx.fillRect(barX, barY, barWidth, barHeight);\r\n                ctx.fillStyle =\r\n                    healthPercent > 0.5 ? '#2ECC71' : healthPercent > 0.25 ? '#F39C12' : '#E74C3C';\r\n                ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// Create singleton and export\r\nconst DinosaurRenderer = new DinosaurRendererService();\r\nif (Registry) Registry.register('DinosaurRenderer', DinosaurRenderer);\r\n\r\nexport { DinosaurRendererService, DinosaurRenderer };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\rendering\\EntityRenderService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'IViewport' is defined but never used.","line":11,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":28,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"IViewport"},"fix":{"range":[368,379],"text":""},"desc":"Remove unused variable \"IViewport\"."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * EntityRenderService - Handles entity collection, Y-sorting, and render dispatch\n *\n * Extracted from GameRenderer to reduce file size and improve maintainability.\n * Owner: EntityRenderService\n */\n\nimport { entityManager } from '@core/EntityManager';\nimport { Registry } from '@core/Registry';\nimport { EntityTypes } from '@config/EntityTypes';\nimport { IEntity, IViewport } from '@app-types/core';\nimport { RenderTiming } from './RenderProfiler';\nimport { RendererCollection } from '../types/rendering';\nimport { isRenderable } from '../utils/typeGuards';\n\ninterface IVisibleBounds {\n    left: number;\n    top: number;\n    right: number;\n    bottom: number;\n    width: number;\n    height: number;\n}\n\n// Unmapped modules - need manual import\n\nconst EntityRenderService = {\n    // GC Optimization: Pre-allocated array for Y-sorting\n    _sortableEntities: [] as IEntity[],\n\n    /**\n     * Collect visible entities from entityManager and Y-sort them\n     * @param {object} visibleBounds - {left, top, right, bottom, width, height}\n     * @returns {array} Sorted array of active entities\n     */\n    collectAndSort(visibleBounds: IVisibleBounds) {\n        const sortableEntities = this._sortableEntities;\n        sortableEntities.length = 0; // Clear without deallocation\n\n        if (!entityManager) return sortableEntities;\n\n        // Add padding to prevent culling objects partially on screen\n        const bounds = {\n            x: visibleBounds.left - 200,\n            y: visibleBounds.top - 200,\n            width: visibleBounds.width + 400,\n            height: visibleBounds.height + 400\n        };\n\n        const allEntities = entityManager.queryRect(bounds);\n\n        // Filter active entities\n        for (const e of allEntities) {\n            if (e.active) sortableEntities.push(e);\n        }\n\n        // Helper to determine render layer priority\n        const getRenderLayer = (e: IEntity) => {\n            if (e.entityType === EntityTypes.DROPPED_ITEM) return 2; // Top priority\n            if (e.entityType === EntityTypes.HERO) return 1; // Middle priority (above nodes)\n            return 0; // Standard (nodes, enemies, etc.)\n        };\n\n        sortableEntities.sort((a, b) => {\n            const layerA = getRenderLayer(a);\n            const layerB = getRenderLayer(b);\n\n            // Primary Sort: Layer Priority\n            if (layerA !== layerB) {\n                return layerA - layerB;\n            }\n\n            // Secondary Sort: Y Position (within same layer)\n            const ay = a.y + (a.height ? a.height / 2 : 0);\n            const by = b.y + (b.height ? b.height / 2 : 0);\n\n            // Stable sort for equal Y\n            if (Math.abs(ay - by) < 0.1) {\n                return a.id > b.id ? 1 : -1;\n            }\n            return ay - by;\n        });\n\n        return sortableEntities;\n    },\n\n    /**\n     * Render a single entity using appropriate renderer\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {object} entity\n     * @param {object} renderers - {hero, heroRenderer, dinosaurRenderer, resourceRenderer}\n     * @param {object} timing - Optional timing object for profiling\n     * @param {number} alpha - Interpolation factor\n     */\n    renderEntity(ctx: CanvasRenderingContext2D, entity: IEntity, renderers: RendererCollection, timing: RenderTiming | null = null, alpha = 1) {\n        const tSub = timing ? performance.now() : 0;\n        const type = entity.entityType;\n\n        // Pass 'false' for includeShadow to prevent double rendering\n        if (entity === renderers.hero) {\n            if (renderers.heroRenderer) {\n                renderers.heroRenderer.render(ctx, renderers.hero, false, alpha);\n            } else if (isRenderable(entity)) {\n                entity.render(ctx);\n            }\n            if (timing) timing.entHeroTime = (timing.entHeroTime || 0) + performance.now() - tSub;\n        } else if (type === EntityTypes.DINOSAUR && renderers.dinosaurRenderer) {\n            renderers.dinosaurRenderer.render(ctx, entity, false, alpha);\n            if (timing) timing.entDinoTime = (timing.entDinoTime || 0) + performance.now() - tSub;\n        } else if (type === EntityTypes.RESOURCE && renderers.resourceRenderer) {\n            renderers.resourceRenderer.render(ctx, entity, false);\n            if (timing) timing.entResTime = (timing.entResTime || 0) + performance.now() - tSub;\n        } else if (type === EntityTypes.MERCHANT) {\n            if (isRenderable(entity)) entity.render(ctx);\n            if (timing) {\n                timing.entMerchantTime = (timing.entMerchantTime || 0) + performance.now() - tSub;\n                timing.entMerchantCount = (timing.entMerchantCount || 0) + 1;\n            }\n        } else if (type === EntityTypes.DROPPED_ITEM) {\n            if (isRenderable(entity)) entity.render(ctx);\n            if (timing) {\n                timing.entDroppedTime = (timing.entDroppedTime || 0) + performance.now() - tSub;\n                timing.entDroppedCount = (timing.entDroppedCount || 0) + 1;\n            }\n        } else {\n            if (isRenderable(entity)) entity.render(ctx);\n            if (timing) {\n                timing.entOtherTime = (timing.entOtherTime || 0) + performance.now() - tSub;\n                const typeName = type || (entity.constructor?.name) || 'unknown';\n                timing.entOtherTypes = timing.entOtherTypes || {};\n                timing.entOtherTypes[typeName] = (timing.entOtherTypes[typeName] || 0) + 1;\n            }\n        }\n\n        if (timing) timing.entCount = (timing.entCount || 0) + 1;\n    },\n\n    /**\n     * Render all entities in the sorted collection\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {array} entities - Y-sorted entity array\n     * @param {object} renderers - Renderer references\n     * @param {object} timing - Optional profiling object\n     * @param {number} alpha - Interpolation factor (0-1)\n     */\n    renderAll(ctx: CanvasRenderingContext2D, entities: IEntity[], renderers: RendererCollection, timing: RenderTiming | null = null, alpha = 1) {\n        // Initialize timing counters\n        if (timing) {\n            timing.entHeroTime = timing.entHeroTime || 0;\n            timing.entDinoTime = timing.entDinoTime || 0;\n            timing.entResTime = timing.entResTime || 0;\n            timing.entOtherTime = timing.entOtherTime || 0;\n            timing.entCount = timing.entCount || 0;\n        }\n\n        for (const entity of entities) {\n            this.renderEntity(ctx, entity, renderers, timing, alpha);\n        }\n    },\n\n    /**\n     * Render UI overlays (health bars) for all entities\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {array} entities\n     * @param {object} timing\n     */\n    renderUIOverlays(ctx: CanvasRenderingContext2D, entities: IEntity[], timing: RenderTiming | null = null) {\n        const tSub = timing ? performance.now() : 0;\n\n        for (const entity of entities) {\n            if (entity.renderUI) {\n                entity.renderUI(ctx);\n            }\n        }\n\n        if (timing) timing.entUITime = (timing.entUITime || 0) + performance.now() - tSub;\n    }\n};\n\nif (Registry) Registry.register('EntityRenderService', EntityRenderService);\n\nexport { EntityRenderService };\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\rendering\\EnvironmentRenderer.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'viewport' is defined but never used. Allowed unused args must match /^_/u.","line":191,"column":43,"nodeType":"Identifier","messageId":"unusedVar","endLine":191,"endColumn":51}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * EnvironmentRenderer\r\n * Manages environmental visuals including Day/Night lighting and Weather Effects.\r\n *\r\n * Responsibilities:\r\n * - Ambient Light Overlay (Day/Night cycle)\r\n * - Weather Particles (Rain, Snow, Fog)\r\n */\r\n\r\nimport { Logger } from '@core/Logger';\r\nimport { EventBus } from '@core/EventBus';\r\nimport { GameConstants } from '@data/GameConstants';\r\nimport { SFX } from '../audio/SFX_Core';\r\nimport { RainVFX } from '@vfx/weather/RainVFX';\r\nimport { SnowVFX } from '@vfx/weather/SnowVFX';\r\nimport { IGame, IViewport } from '@app-types/core';\r\nimport { computeLighting, computeShadows } from './EnvironmentRendererLighting';\r\nimport {\r\n    createLightningState,\r\n    createWindState,\r\n    updateLightning,\r\n    triggerLightning,\r\n    updateWind,\r\n    renderLightning,\r\n    type LightningState,\r\n    type WindState\r\n} from './EnvironmentRendererStorm';\r\n\r\ninterface VFXModules {\r\n    RAIN: RainVFX | null;\r\n    SNOW: SnowVFX | null;\r\n}\r\n\r\nclass EnvironmentRenderer {\r\n    // Canvas references\r\n    canvas: HTMLCanvasElement | null = null;\r\n    ctx: CanvasRenderingContext2D | null = null;\r\n    game: IGame | null = null;\r\n\r\n    // Ambient Lighting State\r\n    ambientColor: string = 'rgba(0,0,0,0)';\r\n    overlayAlpha: number = 0;\r\n\r\n    // Shadow State\r\n    shadowScaleY: number = 0.3;\r\n    shadowAlpha: number = 0.3;\r\n    shadowOffsetX: number = 0;\r\n    shadowSkew: number = 0;\r\n\r\n    // Camera Tracking\r\n    lastViewport: { x: number; y: number } = { x: 0, y: 0 };\r\n\r\n    // Current Weather State\r\n    weatherType: string = 'CLEAR';\r\n\r\n    lightning: LightningState = createLightningState();\r\n    wind: WindState = createWindState();\r\n\r\n    // Weather Modules\r\n    vfx: VFXModules = {\r\n        RAIN: null,\r\n        SNOW: null\r\n    };\r\n\r\n    constructor() {\r\n        // All properties initialized as class fields above\r\n    }\r\n\r\n    init(game: IGame) {\r\n        this.game = game;\r\n\r\n        // Listen for Time Ticks to update lighting state\r\n        if (EventBus && GameConstants) {\r\n            EventBus.on(GameConstants.Events.TIME_TICK, (data: { dayTime: number }) => this.updateLighting(data));\r\n            EventBus.on(GameConstants.Events.WEATHER_CHANGE, (data: { type: string }) =>\r\n                this.setWeather(data.type)\r\n            );\r\n        }\r\n\r\n        // Initialize VFX Modules\r\n        if (RainVFX) {\r\n            this.vfx.RAIN = new RainVFX();\r\n            this.vfx.RAIN.init();\r\n        }\r\n        if (SnowVFX) {\r\n            this.vfx.SNOW = new SnowVFX();\r\n            this.vfx.SNOW.init();\r\n        }\r\n\r\n        Logger.info('[EnvironmentRenderer] Initialized');\r\n    }\r\n\r\n    /**\r\n     * Set active weather effect\r\n     * @param {string} type - Weather Type (RAIN, SNOW, FOG, CLEAR)\r\n     */\r\n    setWeather(type: string) {\r\n        Logger.info(`[EnvironmentRenderer] Weather set to: ${type}`);\r\n        this.weatherType = type;\r\n\r\n        // Reset all\r\n        if (this.vfx.RAIN) this.vfx.RAIN.active = false;\r\n        if (this.vfx.SNOW) this.vfx.SNOW.active = false;\r\n\r\n        // Activate specific\r\n        if (type === 'RAIN' && this.vfx.RAIN) this.vfx.RAIN.active = true;\r\n        else if (type === 'STORM' && this.vfx.RAIN)\r\n            this.vfx.RAIN.active = true; // Storm reuses Rain for now\r\n        else if (type === 'SNOW' && this.vfx.SNOW) this.vfx.SNOW.active = true;\r\n\r\n        if (type === 'STORM') this.lightning.timer = 1 + Math.random() * 3;\r\n\r\n        // DIRECT AUDIO SYNC: Trigger weather ambience\r\n        if (SFX && SFX.ctx) {\r\n            SFX.setWeather(type);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update loop (called by Game.js if registered system has update method)\r\n     */\r\n    update(dt: number) {\r\n        // Get Camera Delta from GameRenderer\r\n        const delta = { x: 0, y: 0 };\r\n        let viewport = null;\r\n\r\n        if (this.game) {\r\n            const renderer = this.game.getSystem<{ viewport?: IViewport; updateCamera?: () => void }>('GameRenderer');\r\n            if (renderer) {\r\n                // Force update camera to get latest world position (minimizes lag)\r\n                if (typeof renderer.updateCamera === 'function') {\r\n                    renderer.updateCamera();\r\n                }\r\n\r\n                if (renderer.viewport) {\r\n                    viewport = renderer.viewport;\r\n                    // Initialize lastViewport if first run\r\n                    if (\r\n                        this.lastViewport.x === 0 &&\r\n                        this.lastViewport.y === 0 &&\r\n                        (viewport.x !== 0 || viewport.y !== 0)\r\n                    ) {\r\n                        this.lastViewport.x = viewport.x;\r\n                        this.lastViewport.y = viewport.y;\r\n                    }\r\n\r\n                    delta.x = viewport.x - this.lastViewport.x;\r\n                    delta.y = viewport.y - this.lastViewport.y;\r\n\r\n                    this.lastViewport.x = viewport.x;\r\n                    this.lastViewport.y = viewport.y;\r\n                }\r\n            }\r\n        }\r\n\r\n        updateWind(dt, this.wind, this.weatherType);\r\n        updateLightning(dt, this.lightning, this.weatherType, () => this.triggerLightning());\r\n\r\n        const isStorm = this.weatherType === 'STORM';\r\n        if (this.vfx.RAIN) this.vfx.RAIN.update(dt, delta, viewport, this.wind, isStorm);\r\n        if (this.vfx.SNOW) this.vfx.SNOW.update(dt, delta, viewport, this.wind);\r\n    }\r\n\r\n    triggerLightning() {\r\n        const getCtx = () => {\r\n            if (this.ctx) return this.ctx;\r\n            if (this.game) {\r\n                const r = this.game.getSystem<{ ctx?: CanvasRenderingContext2D }>('GameRenderer');\r\n                if (r?.ctx) { this.ctx = r.ctx; return this.ctx; }\r\n            }\r\n            return null;\r\n        };\r\n        triggerLightning(this.lightning, this.ctx, getCtx);\r\n    }\r\n\r\n    updateLighting(data: { dayTime: number }) {\r\n        const { ambientColor, overlayAlpha } = computeLighting(data.dayTime);\r\n        this.ambientColor = ambientColor;\r\n        this.overlayAlpha = overlayAlpha;\r\n        const shadows = computeShadows(data.dayTime);\r\n        this.shadowScaleY = shadows.shadowScaleY;\r\n        this.shadowAlpha = shadows.shadowAlpha;\r\n        this.shadowSkew = shadows.shadowSkew;\r\n    }\r\n\r\n    /**\r\n     * Render the environment overlay\r\n     * @param {CanvasRenderingContext2D} ctx - The game canvas context\r\n     * @param {Object} viewport - Current camera viewport\r\n     */\r\n    render(ctx: CanvasRenderingContext2D, viewport: IViewport) {\r\n        // Cache context for update loop usage\r\n        if (!this.ctx) this.ctx = ctx;\r\n\r\n        // Render Weather (Overlay)\r\n        if (this.vfx.RAIN) this.vfx.RAIN.render(ctx);\r\n        if (this.vfx.SNOW) this.vfx.SNOW.render(ctx);\r\n\r\n        if (this.weatherType === 'STORM') renderLightning(ctx, this.lightning);\r\n\r\n        // --- AMBIENT OVERLAY (Day/Night Cycle) ---\r\n        if (this.overlayAlpha > 0.01) {\r\n            ctx.save();\r\n            // Reset transform to draw in screen space (UI layer style)\r\n            // But GameRenderer might call this inside or outside a transform.\r\n            // Standard practice: assume GameRenderer passes us a customized state,\r\n            // OR we reset. Since this is a fullscreen overlay, we want screen space.\r\n            // GameRenderer typically restores context after calls, so we can be bold.\r\n            ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n\r\n            ctx.fillStyle = this.ambientColor;\r\n            ctx.globalCompositeOperation = 'multiply'; // Blend it nicely\r\n            ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);\r\n\r\n            ctx.restore();\r\n        }\r\n    }\r\n}\r\n\r\n// Create singleton and export\r\nconst environmentRenderer = new EnvironmentRenderer();\r\n\r\nimport { Registry } from '@core/Registry';\r\nRegistry.register('EnvironmentRenderer', environmentRenderer);\r\n\r\nexport { EnvironmentRenderer, environmentRenderer };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\rendering\\EnvironmentRendererLighting.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\rendering\\EnvironmentRendererStorm.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\rendering\\GridRenderer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\rendering\\HeroRenderer.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'RenderConfig' is defined but never used.","line":9,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":22,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"RenderConfig"},"fix":{"range":[228,280],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'environmentRenderer' is defined but never used.","line":15,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":29,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"environmentRenderer"},"fix":{"range":[535,595],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'IEntity' is defined but never used.","line":21,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":21,"endColumn":22,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"IEntity"},"fix":{"range":[881,889],"text":""},"desc":"Remove unused variable \"IEntity\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'game' is defined but never used. Allowed unused args must match /^_/u.","line":37,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":37,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * HeroRenderer - Dedicated rendering system for the player character\r\n *\r\n * Extracted from Hero.js to separate logic from presentation.\r\n * Uses RenderConfig for constants.\r\n */\r\n\r\nimport { Logger } from '@core/Logger';\r\nimport { RenderConfig } from '@config/RenderConfig';\r\nimport { MaterialLibrary } from '@vfx/MaterialLibrary';\r\nimport { AssetLoader } from '@core/AssetLoader';\r\nimport { Registry } from '@core/Registry';\r\nimport { EntityRegistry } from '@entities/EntityLoader';\r\nimport { DOMUtils } from '@core/DOMUtils';\r\nimport { environmentRenderer } from './EnvironmentRenderer';\r\nimport { drawStatusBars } from './HeroRendererStatusBars';\r\nimport { drawRangeCircles } from './HeroRendererRangeCircles';\r\nimport { drawShadow } from './HeroRendererShadow';\r\nimport { drawWeapon } from './HeroRendererWeapon';\r\nimport { Hero } from '../gameplay/Hero';\r\nimport type { IEntity, IGame, ISystem } from '../types/core';\r\n\r\nclass HeroRendererSystem implements ISystem {\r\n    // Cached image properties\r\n    private _heroPath: string | null = null;\r\n    private _heroImg: HTMLImageElement | null = null;\r\n    private _heroCanvas: HTMLCanvasElement | null = null;\r\n    private _heroW: number | null = null;\r\n    private _heroH: number | null = null;\r\n    private _shadowImg: HTMLImageElement | HTMLCanvasElement | null = null;\r\n\r\n    constructor() {\r\n        Logger.info('[HeroRenderer] Initialized');\r\n    }\r\n\r\n    /** System initialization */\r\n    init(game: IGame): void {\r\n        // No specific init logic needed yet\r\n    }\r\n\r\n    /**\r\n     * Set the hero skin - clears cached images and loads new skin\r\n     * @param {string} skinId - Hero skin ID (e.g., 'hero_t1_01')\r\n     */\r\n    setSkin(skinId: string) {\r\n        // Get skin data from EntityRegistry\r\n        const skinData = EntityRegistry?.hero?.[skinId];\r\n        if (!skinData) {\r\n            Logger.warn(`[HeroRenderer] Skin not found: ${skinId}`);\r\n            return;\r\n        }\r\n\r\n        // Build image path from skin files\r\n        let path = null;\r\n        if (skinData.files?.clean) {\r\n            path = 'assets/' + skinData.files.clean;\r\n        } else if (skinData.files?.original) {\r\n            path = 'assets/' + skinData.files.original;\r\n        }\r\n\r\n        if (!path) {\r\n            Logger.warn(`[HeroRenderer] No image path for skin: ${skinId}`);\r\n            return;\r\n        }\r\n\r\n        // Clear all cached images to force reload\r\n        this._heroPath = path;\r\n        this._heroImg = null;\r\n        this._heroCanvas = null;\r\n        this._heroW = null;\r\n        this._heroH = null;\r\n        this._shadowImg = null;\r\n\r\n        Logger.info(`[HeroRenderer] Skin changed to: ${skinId} -> ${path}`);\r\n    }\r\n\r\n    /**\r\n     * Render the hero and their equipped weapon\r\n     * @param {CanvasRenderingContext2D} ctx\r\n     * @param {Hero} hero\r\n     */\r\n    render(ctx: CanvasRenderingContext2D, hero: Hero, includeShadow = true, alpha = 1) {\r\n        if (!hero || !hero.active) return;\r\n\r\n        // Interpolation\r\n        const prevX = (hero.prevX !== undefined) ? hero.prevX : hero.x;\r\n        const prevY = (hero.prevY !== undefined) ? hero.prevY : hero.y;\r\n\r\n        const renderX = prevX + (hero.x - prevX) * alpha;\r\n        const renderY = prevY + (hero.y - prevY) * alpha;\r\n\r\n        const originalX = hero.x;\r\n        const originalY = hero.y;\r\n\r\n        // Apply interpolated coordinates for rendering\r\n        const heroPos = hero as { x: number; y: number };\r\n        heroPos.x = renderX;\r\n        heroPos.y = renderY;\r\n\r\n        try {\r\n            if (includeShadow) {\r\n                this._ensureShadowImg();\r\n                drawShadow(ctx, hero, {\r\n                    shadowImg: this._shadowImg,\r\n                    forceOpaque: false\r\n                });\r\n            }\r\n\r\n            drawRangeCircles(ctx, hero);\r\n\r\n            this.drawBody(ctx, hero);\r\n\r\n            drawWeapon(ctx, hero);\r\n\r\n            drawStatusBars(ctx, hero);\r\n        } finally {\r\n            // Restore actual physics coordinates\r\n            const heroPos = hero as { x: number; y: number };\r\n            heroPos.x = originalX;\r\n            heroPos.y = originalY;\r\n        }\r\n    }\r\n\r\n    private _ensureShadowImg(): void {\r\n        if (!this._shadowImg && MaterialLibrary) {\r\n            this._shadowImg = MaterialLibrary.get('world_hero', 'shadow', {});\r\n        }\r\n    }\r\n\r\n    /** For ShadowRenderer compatibility */\r\n    drawShadow(ctx: CanvasRenderingContext2D, hero: Hero, forceOpaque = false) {\r\n        this._ensureShadowImg();\r\n        drawShadow(ctx, hero, { shadowImg: this._shadowImg, forceOpaque });\r\n    }\r\n\r\n    /**\r\n     * Draw the main hero sprite\r\n     */\r\n    drawBody(ctx: CanvasRenderingContext2D, hero: Hero) {\r\n        // PERF: Cache heroPath on renderer - use saved skin or default\r\n        if (!this._heroPath) {\r\n            const savedSkin = localStorage.getItem('heroSelectedSkin') || 'hero_t1_01';\r\n            const skinData = EntityRegistry?.hero?.[savedSkin];\r\n\r\n            if (skinData?.files?.clean) {\r\n                this._heroPath = 'assets/' + skinData.files.clean;\r\n            } else if (skinData?.files?.original) {\r\n                this._heroPath = 'assets/' + skinData.files.original;\r\n            } else if (AssetLoader) {\r\n                // Fallback to world_hero asset\r\n                this._heroPath = AssetLoader.getImagePath('world_hero');\r\n            }\r\n        }\r\n\r\n        if (this._heroPath) {\r\n            // Lazy load image on the renderer instance\r\n            if (!this._heroImg) {\r\n                this._heroImg = AssetLoader.createImage(this._heroPath);\r\n            }\r\n\r\n            // Wait for image to be fully processed (white removal converts src to data URL)\r\n            const isProcessed =\r\n                this._heroImg.src.startsWith('data:') || this._heroImg.src.includes('PH.png');\r\n            const isLoaded = this._heroImg.complete && this._heroImg.naturalWidth;\r\n\r\n            if (isLoaded && isProcessed) {\r\n                // PERF: Cache scaled sprite to avoid expensive resizing every frame\r\n                // Invalidate cache if dimensions change\r\n                if (\r\n                    !this._heroCanvas ||\r\n                    this._heroW !== hero.width ||\r\n                    this._heroH !== hero.height\r\n                ) {\r\n                    this._heroW = hero.width;\r\n                    this._heroH = hero.height;\r\n                    this._heroCanvas = DOMUtils.createCanvas(hero.width, hero.height);\r\n                    const c = this._heroCanvas.getContext('2d');\r\n                    c.imageSmoothingEnabled = false;\r\n                    c.drawImage(this._heroImg, 0, 0, hero.width, hero.height);\r\n                }\r\n\r\n                ctx.drawImage(this._heroCanvas, hero.x - hero.width / 2, hero.y - hero.height / 2);\r\n            }\r\n        }\r\n        // No fallback - skip rendering until sprite loads\r\n    }\r\n}\r\n\r\n// Create singleton and export\r\nconst HeroRenderer = new HeroRendererSystem();\r\nif (Registry) Registry.register('HeroRenderer', HeroRenderer);\r\n\r\nexport { HeroRendererSystem, HeroRenderer };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\rendering\\HeroRendererRangeCircles.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\rendering\\HeroRendererShadow.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\rendering\\HeroRendererStatusBars.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\rendering\\HeroRendererWeapon.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\rendering\\HomeOutpostRenderer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\rendering\\RenderProfiler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\rendering\\ResourceRenderer.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ColorPalette' is defined but never used.","line":15,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":22,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"ColorPalette"},"fix":{"range":[562,614],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'game' is defined but never used. Allowed unused args must match /^_/u.","line":25,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":25,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * ResourceRenderer\r\n * Handles rendering for all resources.\r\n */\r\n\r\nimport { Logger } from '@core/Logger';\r\nimport { MaterialLibrary } from '@vfx/MaterialLibrary';\r\nimport { ProgressBarRenderer } from '@vfx/ProgressBarRenderer';\r\nimport { AssetLoader } from '@core/AssetLoader';\r\nimport { Registry } from '@core/Registry';\r\nimport { environmentRenderer } from './EnvironmentRenderer';\r\nimport { Resource } from '../gameplay/Resource';\r\nimport { DroppedItem } from '../gameplay/DroppedItem';\r\nimport { renderDroppedItem } from './ResourceRendererDropped';\r\nimport { ColorPalette } from '@config/ColorPalette';\r\nimport { EntityRegistry } from '@entities/EntityLoader';\r\nimport { GameConstants } from '@data/GameConstants';\r\nimport type { IGame, ISystem } from '../types/core';\r\n\r\nclass ResourceRendererService implements ISystem {\r\n    constructor() {\r\n        Logger.info('[ResourceRenderer] Initialized');\r\n    }\r\n\r\n    init(game: IGame): void { }\r\n\r\n    render(ctx: CanvasRenderingContext2D, res: Resource, includeShadow = true) {\r\n        if (!res.active) return;\r\n\r\n        // Shadow\r\n        if (includeShadow) {\r\n            this.renderShadow(ctx, res);\r\n        }\r\n\r\n        // Shake logic (if damaged) - skipped for simplification or handled by Tween?\r\n        // Check if this resource type uses custom rendering (e.g., trees handled elsewhere)\r\n        const typeConfig =\r\n            EntityRegistry?.nodes?.[res.resourceType] || EntityRegistry?.resources?.[res.resourceType] || {};\r\n        if (typeConfig.skipDefaultRender) return;\r\n\r\n        if (res.state === 'depleted') {\r\n            this.renderDepleted(ctx, res);\r\n            return;\r\n        }\r\n\r\n        // Active State\r\n        this.renderActive(ctx, res);\r\n    }\r\n\r\n    // ... rest of methods ...\r\n    renderShadow(ctx: CanvasRenderingContext2D, res: Resource, forceOpaque = false) {\r\n        // Check environmentRenderer singleton for dynamic shadows\r\n        const env = environmentRenderer;\r\n\r\n        let scaleY = 0.3;\r\n        let alpha = 0.3;\r\n\r\n        if (env) {\r\n            scaleY = env.shadowScaleY;\r\n            alpha = env.shadowAlpha;\r\n        }\r\n\r\n        // 1. Static Contact Shadow\r\n        ctx.save();\r\n        ctx.translate(res.x, res.y + res.height / 2 - 6);\r\n\r\n        if (forceOpaque) {\r\n            ctx.fillStyle = 'black';\r\n            ctx.globalAlpha = 1.0;\r\n        } else {\r\n            ctx.fillStyle = 'black';\r\n            ctx.globalAlpha = alpha;\r\n        }\r\n\r\n        const contactWidth = res.width * 0.6;\r\n        const contactHeight = res.height * 0.15;\r\n\r\n        ctx.beginPath();\r\n        ctx.ellipse(0, 0, contactWidth / 2, contactHeight / 2, 0, 0, Math.PI * 2);\r\n        ctx.fill();\r\n        ctx.restore();\r\n\r\n        // 2. Dynamic Shadow\r\n        ctx.save();\r\n        ctx.translate(res.x, res.y + res.height / 2 - 6);\r\n\r\n        const skew = env ? env.shadowSkew || 0 : 0;\r\n        ctx.transform(1, 0, skew, 1, 0, 0);\r\n\r\n        ctx.scale(1, -scaleY); // Flip resource shadows vertical\r\n\r\n        if (forceOpaque) {\r\n            ctx.globalAlpha = 1.0;\r\n            ctx.fillStyle = 'black';\r\n        } else {\r\n            ctx.globalAlpha = alpha;\r\n            ctx.fillStyle = 'black';\r\n        }\r\n\r\n        // PERF: Cache shadow image on entity (retry until successful)\r\n        if (!res._shadowImg) {\r\n            // Use same asset ID logic as renderActive\r\n            let assetId = null;\r\n            if (res.resourceType && res.resourceType.startsWith('node_')) {\r\n                assetId = res.resourceType;\r\n            } else {\r\n                const entityData =\r\n                    EntityRegistry?.nodes?.[res.resourceType] ||\r\n                    EntityRegistry?.resources?.[res.resourceType];\r\n                if (entityData?.sprite) {\r\n                    assetId = entityData.sprite;\r\n                } else if (entityData?.id) {\r\n                    assetId = entityData.id;\r\n                } else {\r\n                    assetId = res.resourceType;\r\n                }\r\n            }\r\n            if (MaterialLibrary && assetId) {\r\n                res._shadowImg = MaterialLibrary.get(assetId, 'shadow', {});\r\n            }\r\n        }\r\n\r\n        if (res._shadowImg) {\r\n            // Draw anchored at bottom center (-w/2, -h)\r\n            ctx.drawImage(res._shadowImg, -res.width / 2, -res.height, res.width, res.height);\r\n        } else {\r\n            // Fallback: Geometric Shadow\r\n            ctx.beginPath();\r\n            ctx.ellipse(0, -res.height / 4, res.width / 2, res.height / 2, 0, 0, Math.PI * 2);\r\n            ctx.fill();\r\n        }\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    renderDepleted(ctx: CanvasRenderingContext2D, res: Resource) {\r\n        // For node_* types, use resourceType directly as base asset ID\r\n        let baseAssetId = null;\r\n        if (res.resourceType && res.resourceType.startsWith('node_')) {\r\n            baseAssetId = res.resourceType;\r\n        } else {\r\n            // Fallback: try EntityRegistry lookup for legacy types\r\n            const entityData =\r\n                EntityRegistry?.nodes?.[res.resourceType] ||\r\n                EntityRegistry?.resources?.[res.resourceType];\r\n            if (entityData?.sprite) {\r\n                baseAssetId = entityData.sprite;\r\n            } else if (entityData?.id) {\r\n                baseAssetId = entityData.id;\r\n            } else {\r\n                baseAssetId = 'world_' + res.resourceType;\r\n            }\r\n        }\r\n\r\n        const consumedAssetId = baseAssetId + '_consumed';\r\n        const consumedPath = AssetLoader ? AssetLoader.getImagePath(consumedAssetId) : null;\r\n\r\n        // Simple image load logic, in real engine use AssetLoader.get()\r\n        if (consumedPath) {\r\n            // We can't easily cache image on the renderer without a map.\r\n            // Rely on browser caching or check res._consumedImage (legacy data prop)\r\n            if (!res._consumedImage) {\r\n                res._consumedImage = AssetLoader.createImage(consumedPath);\r\n            }\r\n            if (res._consumedImage.complete && res._consumedImage.naturalWidth) {\r\n                ctx.drawImage(\r\n                    res._consumedImage,\r\n                    res.x - res.width / 2,\r\n                    res.y - res.height / 2,\r\n                    res.width,\r\n                    res.height\r\n                );\r\n            }\r\n        } else {\r\n            // Fallback\r\n            ctx.save();\r\n            ctx.globalAlpha = 0.4;\r\n            ctx.fillStyle = '#222222';\r\n            ctx.beginPath();\r\n            ctx.arc(res.x, res.y, res.width / 2, 0, Math.PI * 2);\r\n            ctx.fill();\r\n            ctx.arc(res.x, res.y, res.width / 2, 0, Math.PI * 2);\r\n            ctx.fill();\r\n            ctx.restore();\r\n        }\r\n\r\n        // Use ProgressBarRenderer for Respawn Timer\r\n        if (ProgressBarRenderer && res.respawnTimer > 0 && res.maxRespawnTime > 0) {\r\n            // Calculate percentage (0 to 1 filling up)\r\n            const remaining = res.respawnTimer;\r\n            const total = res.maxRespawnTime;\r\n            const pct = 1 - remaining / total;\r\n\r\n            const R = GameConstants.Resource;\r\n            ProgressBarRenderer.draw(ctx, {\r\n                x: res.x - R.HEALTH_BAR_OFFSET_X,\r\n                y: res.y - res.height / 2 - R.HEALTH_BAR_Y_OFFSET,\r\n                width: R.HEALTH_BAR_WIDTH,\r\n                height: R.HEALTH_BAR_HEIGHT,\r\n                percent: pct,\r\n                mode: 'respawn',\r\n                animated: true\r\n            });\r\n        }\r\n    }\r\n\r\n    renderActive(ctx: CanvasRenderingContext2D, res: Resource) {\r\n        // For node_* types, use resourceType directly as asset key (matches AssetLoader)\r\n        let assetId = null;\r\n        if (res.resourceType && res.resourceType.startsWith('node_')) {\r\n            assetId = res.resourceType;\r\n        } else {\r\n            // Fallback: try EntityRegistry lookup for legacy types\r\n            const entityData =\r\n                EntityRegistry?.nodes?.[res.resourceType] ||\r\n                EntityRegistry?.resources?.[res.resourceType];\r\n            if (entityData?.sprite) {\r\n                assetId = entityData.sprite;\r\n            } else if (entityData?.id) {\r\n                assetId = entityData.id;\r\n            } else {\r\n                // Last resort: legacy world_ prefix\r\n                assetId = 'world_' + res.resourceType;\r\n            }\r\n        }\r\n\r\n        const imagePath = AssetLoader ? AssetLoader.getImagePath(assetId) : null;\r\n\r\n        if (imagePath) {\r\n            if (!res._spriteImage) {\r\n                res._spriteImage = AssetLoader.createImage(imagePath);\r\n            }\r\n            if (res._spriteImage.complete && res._spriteImage.naturalWidth) {\r\n                ctx.drawImage(\r\n                    res._spriteImage,\r\n                    res.x - res.width / 2,\r\n                    res.y - res.height / 2,\r\n                    res.width,\r\n                    res.height\r\n                );\r\n                return;\r\n            }\r\n        }\r\n\r\n        // Fallback Procedural\r\n        ctx.save();\r\n        ctx.shadowColor = res.color;\r\n        ctx.shadowBlur = 8;\r\n        ctx.fillStyle = res.color;\r\n        ctx.beginPath();\r\n        ctx.roundRect(res.x - res.width / 2, res.y - res.height / 2, res.width, res.height, 6);\r\n        ctx.fill();\r\n        ctx.shadowBlur = 0;\r\n        ctx.strokeStyle = '#1A1A2E';\r\n        ctx.lineWidth = 2;\r\n        ctx.stroke();\r\n\r\n        // Letter\r\n        ctx.fillStyle = '#FFFFFF';\r\n        ctx.font = 'bold 16px sans-serif';\r\n        ctx.textAlign = 'center';\r\n        ctx.textBaseline = 'middle';\r\n        const letter = res.resourceType.charAt(0).toUpperCase();\r\n        ctx.fillText(letter, res.x, res.y);\r\n        ctx.restore();\r\n\r\n        // --- Progress Bar (Health) ---\r\n        // Check for health (Component or Direct)\r\n        let currentHealth = 0;\r\n        let maxHealth = 0;\r\n\r\n        if (res.components && res.components.health) {\r\n            currentHealth = res.components.health.health;\r\n            maxHealth = res.components.health.maxHealth;\r\n        } else if (res.health !== undefined) {\r\n            currentHealth = res.health;\r\n            maxHealth = res.maxHealth || GameConstants.Combat.DEFAULT_MAX_HEALTH_NPC;\r\n        }\r\n\r\n        // Only draw if damaged and not dead\r\n        if (currentHealth < maxHealth && currentHealth > 0) {\r\n            if (ProgressBarRenderer) {\r\n                const pct = currentHealth / maxHealth;\r\n                const R = GameConstants.Resource;\r\n                ProgressBarRenderer.draw(ctx, {\r\n                    x: res.x - R.HEALTH_BAR_OFFSET_X,\r\n                    y: res.y - res.height / 2 - R.HEALTH_BAR_Y_OFFSET,\r\n                    width: R.HEALTH_BAR_WIDTH,\r\n                    height: R.HEALTH_BAR_HEIGHT,\r\n                    percent: pct,\r\n                    mode: 'health',\r\n                    entityId: res.id // For damage trail\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    renderDroppedItem(ctx: CanvasRenderingContext2D, item: DroppedItem) {\r\n        renderDroppedItem(ctx, item);\r\n    }\r\n}\r\n\r\n// Create singleton and export\r\nconst ResourceRenderer = new ResourceRendererService();\r\nif (Registry) Registry.register('ResourceRenderer', ResourceRenderer);\r\n\r\nexport { ResourceRendererService, ResourceRenderer };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\rendering\\ResourceRendererDropped.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\rendering\\RoadRenderer.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'tNext' is assigned a value but never used.","line":126,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":126,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'dt' is defined but never used. Allowed unused args must match /^_/u.","line":163,"column":12,"nodeType":"Identifier","messageId":"unusedVar","endLine":163,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * RoadRenderer - Renders spline roads with tiled textures\r\n *\r\n * Stretches a road tile image along Bezier spline curves.\r\n * Tile size = 128px (1 grid cell)\r\n *\r\n * Owner: Graphics Engineer\r\n */\r\n\r\nimport { Logger } from '@core/Logger';\r\nimport { AssetLoader } from '@core/AssetLoader';\r\nimport { BiomeManager } from '../world/BiomeManager';\r\nimport { Registry } from '@core/Registry';\r\nimport { DOMUtils } from '@core/DOMUtils';\r\nimport type { IViewport, IGame } from '../types/core';\r\n\r\nclass RoadRenderer {\r\n    game: IGame | null = null;\r\n    roadTile: HTMLImageElement | null = null;\r\n    tileSize: number = 128;\r\n    tileLoaded: boolean = false;\r\n\r\n    constructor() {\r\n        Logger.info('[RoadRenderer] Constructed');\r\n    }\r\n\r\n    init(game: IGame) {\r\n        this.game = game;\r\n        this.loadRoadTile();\r\n        Logger.info('[RoadRenderer] Initialized');\r\n    }\r\n\r\n    /**\r\n     * Load the road tile image\r\n     */\r\n    loadRoadTile() {\r\n        // Check if AssetLoader has a road tile\r\n        if (AssetLoader && typeof AssetLoader.getImage === 'function') {\r\n            const tile = AssetLoader.getImage('road_tile');\r\n            if (tile && tile.complete && tile.naturalWidth) {\r\n                this.roadTile = tile;\r\n                this.tileLoaded = true;\r\n                Logger.info('[RoadRenderer] Road tile loaded from AssetLoader');\r\n                return;\r\n            }\r\n        }\r\n\r\n        // Create a procedural road tile as fallback\r\n        this.createProceduralTile();\r\n    }\r\n\r\n    /**\r\n     * Create a procedural dirt road tile\r\n     */\r\n    createProceduralTile() {\r\n        const size = this.tileSize;\r\n        const canvas = DOMUtils.createCanvas(size, size);\r\n        const ctx = canvas.getContext('2d');\r\n\r\n        // Base dirt color\r\n        ctx.fillStyle = '#8B6914';\r\n        ctx.fillRect(0, 0, size, size);\r\n\r\n        // Add some texture variation\r\n        for (let i = 0; i < 50; i++) {\r\n            const x = Math.random() * size;\r\n            const y = Math.random() * size;\r\n            const r = 2 + Math.random() * 4;\r\n            const brightness = 0.8 + Math.random() * 0.4;\r\n            ctx.fillStyle = `rgba(${Math.floor(139 * brightness)}, ${Math.floor(105 * brightness)}, ${Math.floor(20 * brightness)}, 0.5)`;\r\n            ctx.beginPath();\r\n            ctx.arc(x, y, r, 0, Math.PI * 2);\r\n            ctx.fill();\r\n        }\r\n\r\n        // Add edge shadows\r\n        const edgeGrad = ctx.createLinearGradient(0, 0, size, 0);\r\n        edgeGrad.addColorStop(0, 'rgba(0, 0, 0, 0.3)');\r\n        edgeGrad.addColorStop(0.15, 'rgba(0, 0, 0, 0)');\r\n        edgeGrad.addColorStop(0.85, 'rgba(0, 0, 0, 0)');\r\n        edgeGrad.addColorStop(1, 'rgba(0, 0, 0, 0.3)');\r\n        ctx.fillStyle = edgeGrad;\r\n        ctx.fillRect(0, 0, size, size);\r\n\r\n        // Store as image\r\n        this.roadTile = new Image();\r\n        this.roadTile.src = canvas.toDataURL();\r\n        this.tileLoaded = true;\r\n\r\n        Logger.info('[RoadRenderer] Procedural road tile created');\r\n    }\r\n\r\n    /**\r\n     * Render all roads to the given context\r\n     * @param {CanvasRenderingContext2D} ctx\r\n     * @param {object} viewport - { x, y, width, height }\r\n     */\r\n    render(ctx: CanvasRenderingContext2D, viewport: IViewport) {\r\n        if (!this.tileLoaded || !BiomeManager) return;\r\n\r\n        ctx.save();\r\n\r\n        for (const road of BiomeManager.ROADS) {\r\n            this.renderSplineRoad(ctx, road, viewport);\r\n        }\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    /**\r\n     * Render a single spline road with tiled texture\r\n     */\r\n    renderSplineRoad(ctx: CanvasRenderingContext2D, road: { points: Array<{ x: number; y: number }>; width?: number }, viewport: IViewport) {\r\n        if (!road.points || road.points.length < 4) return;\r\n\r\n        // Get the approximate length of the spline\r\n        const length = BiomeManager.getSplineLength(road);\r\n        const tileCount = Math.ceil(length / this.tileSize);\r\n\r\n        // Sample points along the spline (one per tile)\r\n        const segmentsPerTile = 1;\r\n        const totalSegments = tileCount * segmentsPerTile;\r\n\r\n        for (let i = 0; i < totalSegments; i++) {\r\n            const t = i / totalSegments;\r\n            const tNext = (i + 1) / totalSegments;\r\n\r\n            // Get position and tangent at this point\r\n            const pos = BiomeManager.evaluateBezier(t, road.points);\r\n            const tangent = BiomeManager.evaluateBezierTangent(t, road.points);\r\n            const angle = Math.atan2(tangent.y, tangent.x);\r\n\r\n            // Skip if outside viewport (with margin)\r\n            const margin = this.tileSize * 2;\r\n            if (\r\n                pos.x < viewport.x - margin ||\r\n                pos.x > viewport.x + viewport.width + margin ||\r\n                pos.y < viewport.y - margin ||\r\n                pos.y > viewport.y + viewport.height + margin\r\n            ) {\r\n                continue;\r\n            }\r\n\r\n            // Calculate tile dimensions\r\n            const tileWidth = this.tileSize;\r\n            const tileHeight = road.width || this.tileSize;\r\n\r\n            // Draw the road tile rotated to follow the curve\r\n            ctx.save();\r\n            ctx.translate(pos.x, pos.y);\r\n            ctx.rotate(angle);\r\n\r\n            // Draw tile centered on the spline\r\n            ctx.drawImage(this.roadTile, -tileWidth / 2, -tileHeight / 2, tileWidth, tileHeight);\r\n\r\n            ctx.restore();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update (placeholder for animations)\r\n     */\r\n    update(dt: number) {\r\n        // Could add animated road effects here\r\n    }\r\n}\r\n\r\nconst roadRenderer = new RoadRenderer();\r\nif (Registry) Registry.register('RoadRenderer', roadRenderer);\r\n\r\nexport { RoadRenderer, roadRenderer };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\rendering\\ShadowRenderer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\rendering\\WeaponRenderer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\rendering\\WorldRenderer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\rendering\\WorldRendererMapgen4.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'MapEditorConfig' is defined but never used.","line":16,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":16,"endColumn":25,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"MapEditorConfig"},"fix":{"range":[650,720],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'scale' is assigned a value but never used.","line":151,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":151,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * WorldRendererMapgen4 - Renders mapgen4 polygon mesh to canvas\r\n *\r\n * Uses WorldManager mesh+map. Viewport in world coords, converted to mesh coords (0..1000).\r\n * Railroad is rendered as its own pass AFTER the terrain/rivers/roads (not inside the\r\n * preview function) so the game pipeline has full control and visibility.\r\n *\r\n * Owner: Director\r\n */\r\n\r\nimport { Logger } from '@core/Logger';\r\nimport { Registry } from '@core/Registry';\r\nimport * as PIXI from 'pixi.js';\r\nimport { drawCachedMeshToCanvas } from '../tools/map-editor/Mapgen4PreviewRenderer';\r\nimport { createRailroadMeshes } from '../tools/map-editor/RailroadMeshRenderer';\r\nimport { MapEditorConfig } from '../tools/map-editor/MapEditorConfig';\r\nimport type { Mesh } from '../tools/map-editor/mapgen4/types';\r\nimport type Mapgen4Map from '../tools/map-editor/mapgen4/map';\r\nimport type { Mapgen4Param, RailroadCrossing, TownSite, RoadSegment } from '../tools/map-editor/Mapgen4Param';\r\nimport type { IGame, IViewport } from '../types/core';\r\n\r\nconst MESH_SIZE = 1000;\r\nconst WORLD_SIZE = 160000;\r\n\r\ntype WorldManagerLike = {\r\n    getMesh: () => { mesh: Mesh; map: Mapgen4Map } | null;\r\n    getMapgen4Param: () => Mapgen4Param;\r\n    getCachedTownsAndRoads?: () => {\r\n        towns: TownSite[];\r\n        roadSegments: RoadSegment[];\r\n        railroadPath: number[];\r\n        railroadCrossings: RailroadCrossing[];\r\n        railroadStationIds: number[];\r\n    };\r\n};\r\n\r\nclass WorldRendererMapgen4 {\r\n    game: IGame | null = null;\r\n    _worldManager: WorldManagerLike | null = null;\r\n    private _loggedOnce = false;\r\n    private _pixiApp: PIXI.Application | null = null;\r\n    private _pixiAppInitPromise: Promise<void> | null = null;\r\n    private _railroadContainer: PIXI.Container | null = null;\r\n    private _lastRailroadPath: string = '';\r\n    private _railroadMeshes: PIXI.Mesh[] = [];\r\n\r\n    constructor() {\r\n        Logger.info('[WorldRendererMapgen4] Constructed');\r\n    }\r\n\r\n    init(game: IGame) {\r\n        this.game = game;\r\n        this._worldManager = game.getSystem('WorldManager') as typeof this._worldManager;\r\n        if (!this._worldManager) {\r\n            this._worldManager = Registry?.get('WorldManager') as typeof this._worldManager;\r\n        }\r\n        Logger.info('[WorldRendererMapgen4] Initialized');\r\n    }\r\n\r\n    render(ctx: CanvasRenderingContext2D, viewport: IViewport) {\r\n        if (!this.game || !this._worldManager) return;\r\n\r\n        const meshAndMap = this._worldManager.getMesh();\r\n        if (!meshAndMap) return;\r\n\r\n        const param = this._worldManager.getMapgen4Param();\r\n        const { mesh, map } = meshAndMap;\r\n\r\n        // Viewport in world coords  mesh coords (0..1000)\r\n        const vpX = (viewport.x / WORLD_SIZE) * MESH_SIZE;\r\n        const vpY = (viewport.y / WORLD_SIZE) * MESH_SIZE;\r\n        const vpW = (viewport.width / WORLD_SIZE) * MESH_SIZE;\r\n        const vpH = (viewport.height / WORLD_SIZE) * MESH_SIZE;\r\n\r\n        if (!ctx?.canvas) return;\r\n\r\n        const { towns, roadSegments, railroadPath, railroadCrossings, railroadStationIds = [] } =\r\n            this._worldManager.getCachedTownsAndRoads?.() ?? {\r\n                towns: [],\r\n                roadSegments: [],\r\n                railroadPath: [],\r\n                railroadCrossings: [],\r\n                railroadStationIds: []\r\n            };\r\n\r\n        // One-time diagnostic log to confirm railroad data is present\r\n        if (!this._loggedOnce) {\r\n            Logger.info(\r\n                '[WorldRendererMapgen4] First render  railroadPath:',\r\n                railroadPath.length,\r\n                'towns:', towns.length,\r\n                'roads:', roadSegments.length,\r\n                'canvas:', ctx.canvas.width, 'x', ctx.canvas.height,\r\n                'meshVP:', vpX.toFixed(1), vpY.toFixed(1), vpW.toFixed(3), vpH.toFixed(3)\r\n            );\r\n            this._loggedOnce = true;\r\n        }\r\n\r\n        // 1. Terrain, rivers, roads  skip railroad (drawn as separate pass below)\r\n        drawCachedMeshToCanvas(\r\n            ctx,\r\n            mesh,\r\n            map,\r\n            param,\r\n            vpX,\r\n            vpY,\r\n            vpW,\r\n            vpH,\r\n            towns,\r\n            roadSegments,\r\n            railroadPath,\r\n            railroadCrossings,\r\n            railroadStationIds,\r\n            new Set<string>(), // no hidden zones in game\r\n            true // skipRailroad  drawn explicitly below\r\n        );\r\n\r\n        // 2. Railroad  separate pass, directly on game canvas\r\n        if (railroadPath.length >= 2) {\r\n            this.renderRailroad(\r\n                ctx, mesh, map, param, railroadPath, railroadCrossings, railroadStationIds,\r\n                vpX, vpY, vpW, vpH\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draw railroad directly to the game canvas using the same meshcanvas mapping\r\n     * as drawCachedMeshToCanvas. This gives the game full control over railroad rendering\r\n     * instead of relying on the map editor preview function's internal drawing.\r\n     */\r\n    private renderRailroad(\r\n        ctx: CanvasRenderingContext2D,\r\n        mesh: Mesh,\r\n        map: Mapgen4Map,\r\n        param: Mapgen4Param,\r\n        railroadPath: number[],\r\n        railroadCrossings: RailroadCrossing[],\r\n        railroadStationIds: number[],\r\n        vpX: number,\r\n        vpY: number,\r\n        vpW: number,\r\n        vpH: number\r\n    ): void {\r\n        const w = ctx.canvas.width;\r\n        const h = ctx.canvas.height;\r\n        if (w === 0 || h === 0) return;\r\n\r\n        const scaleX = w / vpW;\r\n        const scaleY = h / vpH;\r\n        const scale = Math.min(scaleX, scaleY);\r\n\r\n        const toCanvas = (x: number, y: number) => ({\r\n            x: (x - vpX) * scaleX,\r\n            y: (y - vpY) * scaleY\r\n        });\r\n\r\n        // Initialize PIXI App asynchronously if needed for WebGL context to render true continuous UV meshes\r\n        if (!this._pixiApp && !this._pixiAppInitPromise) {\r\n            this._pixiApp = new PIXI.Application();\r\n\r\n            // PIXI v8 requires async initialization. Catch errors to prevent silent fails.\r\n            this._pixiAppInitPromise = this._pixiApp.init({\r\n                width: w,\r\n                height: h,\r\n                backgroundAlpha: 0,\r\n                autoStart: false,\r\n                preserveDrawingBuffer: true\r\n            }).then(() => {\r\n                this._railroadContainer = new PIXI.Container();\r\n                this._pixiApp!.stage.addChild(this._railroadContainer);\r\n            }).catch(err => {\r\n                Logger.error('[WorldRendererMapgen4] PIXI Railroad Renderer init failed:', err);\r\n            });\r\n        }\r\n\r\n        // The game render loop is synchronous. Fall back to simple lines while PIXI mounts in the background\r\n        if (!this._pixiApp || !this._railroadContainer || !this._pixiApp.canvas) {\r\n            this.renderRailroadFallbackLines(ctx, mesh, railroadPath, toCanvas);\r\n            return;\r\n        }\r\n\r\n        // Ensure canvas stays synchronized with game viewport resizes\r\n        if (this._pixiApp.canvas.width !== w || this._pixiApp.canvas.height !== h) {\r\n            this._pixiApp.renderer.resize(w, h);\r\n        }\r\n\r\n        // Rebuild mesh geometry if the path changes\r\n        const currentPathStr = railroadPath.join(',');\r\n        if (this._lastRailroadPath !== currentPathStr) {\r\n            this._lastRailroadPath = currentPathStr;\r\n\r\n            // Clean up old meshes to prevent WebGL buffer leaks\r\n            for (const m of this._railroadMeshes) {\r\n                m.destroy({ children: true, texture: false });\r\n            }\r\n            this._railroadContainer!.removeChildren();\r\n\r\n            this._railroadMeshes = createRailroadMeshes(\r\n                mesh,\r\n                map,\r\n                railroadPath,\r\n                this._railroadContainer!,\r\n                railroadStationIds\r\n            );\r\n        }\r\n\r\n        if (this._railroadMeshes.length > 0) {\r\n            // Transform the container to match the viewport camera.\r\n            // Mapgen4 coordinates (rx, ry) in mesh space (0-1000).\r\n            this._railroadContainer!.scale.set(scaleX, scaleY);\r\n            this._railroadContainer!.position.set(-vpX * scaleX, -vpY * scaleY);\r\n\r\n            // Render the PIXI stage to its internal WebGL canvas\r\n            this._pixiApp.renderer.render(this._pixiApp.stage);\r\n\r\n            // Composite the PIXI WebGL canvas onto the Game's native 2D canvas\r\n            // PIXI v8 uses .canvas instead of .view\r\n            ctx.drawImage(this._pixiApp.canvas, 0, 0);\r\n        } else {\r\n            // Fallback: if the spline fails to produce visible output\r\n            this.renderRailroadFallbackLines(ctx, mesh, railroadPath, toCanvas);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Simple thick lines between railroad station points.\r\n     * Always drawn ON TOP of the spline as a guarantee of visibility.\r\n     * Uses a semi-transparent dark line so it doesn't overpower textures\r\n     * but is clearly visible if the spline rendering fails.\r\n     */\r\n    private renderRailroadFallbackLines(\r\n        ctx: CanvasRenderingContext2D,\r\n        mesh: Mesh,\r\n        railroadPath: number[],\r\n        toCanvas: (x: number, y: number) => { x: number; y: number }\r\n    ): void {\r\n        if (railroadPath.length < 2) return;\r\n\r\n        ctx.save();\r\n        ctx.strokeStyle = 'rgba(90, 60, 30, 0.7)';\r\n        ctx.lineWidth = 4;\r\n        ctx.lineCap = 'round';\r\n        ctx.lineJoin = 'round';\r\n\r\n        ctx.beginPath();\r\n        const first = toCanvas(mesh.x_of_r(railroadPath[0]), mesh.y_of_r(railroadPath[0]));\r\n        ctx.moveTo(first.x, first.y);\r\n\r\n        for (let i = 1; i < railroadPath.length; i++) {\r\n            const p = toCanvas(\r\n                mesh.x_of_r(railroadPath[i]),\r\n                mesh.y_of_r(railroadPath[i])\r\n            );\r\n            ctx.lineTo(p.x, p.y);\r\n        }\r\n        ctx.stroke();\r\n        ctx.restore();\r\n    }\r\n}\r\n\r\nconst worldRendererMapgen4 = new WorldRendererMapgen4();\r\nif (Registry) Registry.register('WorldRendererMapgen4', worldRendererMapgen4);\r\n\r\nexport { WorldRendererMapgen4, worldRendererMapgen4 };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\rendering\\WorldRendererWater.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\systems\\BossSystem.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getConfig' is defined but never used.","line":15,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":34,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"getConfig"},"fix":{"range":[345,356],"text":""},"desc":"Remove unused variable \"getConfig\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'EntityTypes' is defined but never used.","line":20,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":20,"endColumn":21,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"EntityTypes"},"fix":{"range":[589,639],"text":""},"desc":"Remove unused import declaration."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * BossSystem\n * Manages boss spawning, respawn timers, and encounter tracking.\n *\n * Features:\n * - One boss per biome\n * - Respawn on timer after death\n * - Spawn on biome entry or game start\n *\n * Work Package: 09-boss-system.md\n */\n\nimport { Logger } from '@core/Logger';\nimport { EventBus } from '@core/EventBus';\nimport { GameConstants, getConfig } from '@data/GameConstants';\nimport { entityManager } from '@core/EntityManager';\nimport { Registry } from '@core/Registry';\nimport { EntityRegistry } from '@entities/EntityLoader';\nimport { BiomeConfig } from '@data/BiomeConfig';\nimport { EntityTypes } from '@config/EntityTypes';\nimport { Boss } from '../gameplay/Boss';\nimport type { IGame, IEntity } from '../types/core';\n\nclass BossSystem {\n    game: IGame | null = null;\n    bosses: Map<string, Boss> = new Map();\n    respawnTimers: Map<string, number> = new Map();\n\n    constructor() {\n        Logger.info('[BossSystem] Constructed');\n    }\n\n    init(game: IGame) {\n        this.game = game;\n        this.initListeners();\n\n        const delay = GameConstants.Timing.BOSS_SPAWN_DELAY_MS;\n        setTimeout(() => {\n            this.spawnAllBosses();\n        }, delay);\n\n        Logger.info('[BossSystem] Initialized');\n    }\n\n    initListeners() {\n        if (EventBus && GameConstants?.Events) {\n            // Listen for enemy death to track boss deaths\n            EventBus.on('ENEMY_DIED', (data: { entity: IEntity }) => this.onEnemyDied(data));\n\n            // Listen for biome entry to spawn bosses\n            EventBus.on(GameConstants.Events.BIOME_ENTERED, (data: { biomeId: string }) =>\n                this.onBiomeEntered(data)\n            );\n        }\n    }\n\n    /**\n     * Spawn boss for a biome\n     * @param {string} biomeId\n     */\n    spawnBoss(biomeId: string) {\n        // Check if already spawned or respawning\n        if (this.bosses.has(biomeId) || this.respawnTimers.has(biomeId)) {\n            return null;\n        }\n\n        // Get biome config\n        const biome = (BiomeConfig?.types as Record<string, { bossId?: string; bossSpawn?: { x: number; y: number }; bounds?: { x: number; y: number; width: number; height: number }; [key: string]: unknown }>)?.[biomeId];\n        if (!biome?.bossId) {\n            Logger.info(`[BossSystem] No boss configured for biome: ${biomeId}`);\n            return null;\n        }\n\n        // Get boss type config\n        const bossConfig = EntityRegistry.bosses?.[biome.bossId];\n        if (!bossConfig) {\n            Logger.info(`[BossSystem] Boss type not found: ${biome.bossId}`);\n            return null;\n        }\n\n        // Get spawn position\n        const spawnPos = this.getBossSpawnPosition(biomeId);\n\n        // Create boss\n        const boss = new Boss({\n            x: spawnPos.x,\n            y: spawnPos.y,\n            bossType: biome.bossId,\n            biomeId: biomeId,\n            level: biome.levelRange?.max ?? GameConstants.Boss.DEFAULT_LEVEL\n        });\n\n        // Register with EntityManager\n        if (entityManager) {\n            entityManager.add(boss);\n        }\n\n        // Track\n        this.bosses.set(biomeId, boss);\n\n        // Emit spawn event\n        if (EventBus && GameConstants?.Events) {\n            EventBus.emit(GameConstants.Events.BOSS_SPAWNED, {\n                boss,\n                biomeId,\n                bossType: biome.bossId\n            });\n        }\n\n        Logger.info(`[BossSystem] Spawned ${boss.bossName} in ${biomeId}`);\n        return boss;\n    }\n\n    /**\n     * Get spawn position for boss\n     * @param {string} biomeId\n     * @returns {{x: number, y: number}}\n     */\n    getBossSpawnPosition(biomeId: string) {\n        // Try to get from biome config\n        const biome = (BiomeConfig?.types as Record<string, { bossSpawn?: { x: number; y: number }; bounds?: { x: number; y: number; width: number; height: number }; [key: string]: unknown }>)?.[biomeId];\n        if (biome?.bossSpawn) {\n            return biome.bossSpawn;\n        }\n\n        // Try to calculate from biome bounds\n        if (biome?.bounds) {\n            return {\n                x: biome.bounds.x + biome.bounds.width / 2,\n                y: biome.bounds.y + biome.bounds.height / 2\n            };\n        }\n\n        const offsetX = GameConstants.World.IRONHAVEN_OFFSET_X;\n        const offsetY = GameConstants.World.IRONHAVEN_OFFSET_Y;\n        const offsets = GameConstants?.Boss?.SPAWN_OFFSETS;\n        const g = offsets?.grasslands ?? { x: 5500, y: 3000 };\n        const t = offsets?.tundra ?? { x: 3000, y: 5500 };\n        const d = offsets?.desert ?? { x: 5500, y: 5500 };\n        const b = offsets?.badlands ?? { x: 3000, y: 3000 };\n        const def = offsets?.default ?? { x: 3500, y: 3500 };\n        const defaults: Record<string, { x: number; y: number }> = {\n            grasslands: { x: offsetX + g.x, y: offsetY + g.y },\n            tundra: { x: offsetX + t.x, y: offsetY + t.y },\n            desert: { x: offsetX + d.x, y: offsetY + d.y },\n            badlands: { x: offsetX + b.x, y: offsetY + b.y }\n        };\n        return defaults[biomeId] ?? { x: offsetX + def.x, y: offsetY + def.y };\n    }\n\n    /**\n     * Handle enemy death - track boss deaths\n     */\n    onEnemyDied(data: { entity: IEntity; enemy?: IEntity & { isBoss?: boolean; biomeId?: string; respawnTime?: number; bossName?: string } }) {\n        const enemy = data.enemy || data.entity;\n        if (!enemy?.isBoss) return;\n\n        const biomeId = enemy.biomeId;\n        if (!biomeId) return;\n\n        // Remove from active bosses\n        this.bosses.delete(biomeId);\n\n        const msPerSecond = GameConstants.Timing.MS_PER_SECOND;\n        const respawnTime = enemy.respawnTime * msPerSecond;\n        this.respawnTimers.set(biomeId, respawnTime);\n\n        Logger.info(`[BossSystem] ${enemy.bossName} killed. Respawning in ${enemy.respawnTime}s`);\n    }\n\n    /**\n     * Handle biome entry - spawn boss if not already spawned\n     */\n    onBiomeEntered(data: { biomeId: string }) {\n        const { biomeId } = data;\n        if (!biomeId) return;\n\n        // Spawn boss if not already active or respawning\n        if (!this.bosses.has(biomeId) && !this.respawnTimers.has(biomeId)) {\n            this.spawnBoss(biomeId);\n        }\n    }\n\n    /**\n     * Update respawn timers\n     * @param {number} dt - Delta time in milliseconds\n     */\n    update(dt: number) {\n        // Update respawn timers\n        for (const [biomeId, timer] of this.respawnTimers.entries()) {\n            const newTimer = timer - dt;\n\n            if (newTimer <= 0) {\n                this.respawnTimers.delete(biomeId);\n                this.spawnBoss(biomeId);\n            } else {\n                this.respawnTimers.set(biomeId, newTimer);\n            }\n        }\n    }\n\n    /**\n     * Check if boss is alive in biome\n     * @param {string} biomeId\n     * @returns {boolean}\n     */\n    isBossAlive(biomeId: string) {\n        const boss = this.bosses.get(biomeId);\n        return boss && !boss.isDead && boss.active;\n    }\n\n    /**\n     * Get active boss for biome\n     * @param {string} biomeId\n     * @returns {Boss|null}\n     */\n    getBoss(biomeId: string) {\n        return this.bosses.get(biomeId) || null;\n    }\n\n    /**\n     * Get time until boss respawn (in seconds)\n     * @param {string} biomeId\n     * @returns {number}\n     */\n    getRespawnTime(biomeId: string) {\n        const timer = this.respawnTimers.get(biomeId);\n        const ms = GameConstants.Timing.MS_PER_SECOND;\n        return timer ? Math.ceil(timer / ms) : 0;\n    }\n\n    /**\n     * Spawn all bosses for testing/initial load\n     */\n    spawnAllBosses() {\n        const biomes = BiomeConfig?.types;\n        if (!biomes) return;\n\n        for (const biomeId of Object.keys(biomes)) {\n            if ((biomes as Record<string, { bossId?: string; [key: string]: unknown }>)[biomeId]?.bossId) {\n                this.spawnBoss(biomeId);\n            }\n        }\n    }\n}\n\n// Create singleton and export\nconst bossSystem = new BossSystem();\nif (Registry) Registry.register('BossSystem', bossSystem);\n\nexport { BossSystem, bossSystem };\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\systems\\CollisionSystem.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'game' is defined but never used. Allowed unused args must match /^_/u.","line":32,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":32,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'dt' is defined but never used. Allowed unused args must match /^_/u.","line":103,"column":12,"nodeType":"Identifier","messageId":"unusedVar","endLine":103,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * CollisionSystem  Resolves spatial collisions, movement, and triggers between entities using a spatial hash.\r\n */\r\nimport { ISystem, IGame } from '../types/core';\r\nimport { Entity } from '../core/Entity';\r\nimport { Logger } from '../core/Logger';\r\nimport { CollisionLayers } from '../components/CollisionComponent';\r\nimport { GameConstants } from '../data/GameConstants';\r\nimport { EventBus } from '../core/EventBus';\r\nimport { Registry } from '../core/Registry';\r\nimport { EntityManagerService } from '../core/EntityManager';\r\nimport { renderCollisionDebug } from './CollisionSystemDebug';\r\nimport { getCollisionBounds } from './CollisionSystemUtils';\r\nimport { updateSpatialHash } from './CollisionSystemSpatialHash';\r\nimport { checkCollision, checkTriggers } from './CollisionSystemCollision';\r\n\r\nexport class CollisionSystem implements ISystem {\r\n    private entities: Entity[] = [];\r\n    private spatialHash: Map<string, Entity[]> = new Map();\r\n    private activeCollisions: Map<string, Set<string>> = new Map(); // EntityID -> Set<OtherID>\r\n    /** Scratch Set reused per entity in checkTriggers to avoid allocation in hot path */\r\n    private _currentOverlapsScratch: Set<string> = new Set();\r\n    private cellSize: number;\r\n    private debugMode: boolean = false;\r\n\r\n    constructor() {\r\n        this.entities = [];\r\n        this.spatialHash = new Map();\r\n        this.activeCollisions = new Map();\r\n    }\r\n\r\n    init(game: IGame): void {\r\n        this.cellSize = GameConstants.Grid.CELL_SIZE;\r\n        Logger.info('[CollisionSystem] Initialized');\r\n\r\n        // Listen for entity registration\r\n        EventBus.on(GameConstants.Events.ENTITY_ADDED, (data: { entity: Entity }) => {\r\n            if (data && data.entity) {\r\n                this.register(data.entity);\r\n                Logger.info(`[CollisionSystem] Event ADDED: ${data.entity.id}`);\r\n            }\r\n        });\r\n\r\n        EventBus.on(GameConstants.Events.ENTITY_REMOVED, (data: { entity: Entity }) => {\r\n            if (data && data.entity) this.unregister(data.entity);\r\n        });\r\n\r\n        EventBus.on(GameConstants.Events.ENTITY_MOVE_REQUEST, (data: { entity: Entity; dx: number; dy: number }) => {\r\n            if (data?.entity != null && this.entities.includes(data.entity)) {\r\n                const result = this.move(data.entity, data.dx, data.dy);\r\n                EventBus.emit(GameConstants.Events.MOVEMENT_UPDATE_RESULT, {\r\n                    entity: data.entity,\r\n                    actualDx: result.x,\r\n                    actualDy: result.y\r\n                });\r\n            }\r\n        });\r\n\r\n        // Initial Sync (Get existing entities from EntityManager)\r\n        const entityManager = Registry.get<EntityManagerService>('EntityManager');\r\n        if (entityManager) {\r\n            // EntityManager returns IEntity[], but we need Entity[] locally if we rely on Entity class features\r\n            // In practice, all entities are instances of Entity class\r\n            const existing = entityManager.getAll() as Entity[]; // Safe cast as we know runtime types\r\n            existing.forEach((e: Entity) => this.register(e));\r\n            Logger.info(`[CollisionSystem] Synced ${existing.length} initial entities`);\r\n        }\r\n    }\r\n\r\n    toggleDebug(): boolean {\r\n        this.debugMode = !this.debugMode;\r\n        Logger.info(`[CollisionSystem] Debug Mode: ${this.debugMode}`);\r\n        return this.debugMode;\r\n    }\r\n\r\n    public get isDebugMode(): boolean {\r\n        return this.debugMode;\r\n    }\r\n\r\n    start(): void {\r\n        // Optional start logic\r\n    }\r\n\r\n    register(entity: Entity): void {\r\n        if (!this.entities.includes(entity)) {\r\n            this.entities.push(entity);\r\n            updateSpatialHash(entity, this.spatialHash, this.cellSize);\r\n            Logger.info(`[CollisionSystem] Registered ${entity.id}. Total: ${this.entities.length}`);\r\n        }\r\n    }\r\n\r\n    unregister(entity: Entity): void {\r\n        const index = this.entities.indexOf(entity);\r\n        if (index !== -1) {\r\n            this.entities.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Main update loop - Rebuilds spatial hash for dynamic entities.\r\n     * Reuses bucket arrays to avoid per-frame allocation (object pooling).\r\n     */\r\n    update(dt: number): void {\r\n        // Clear bucket contents but reuse arrays (no new allocation)\r\n        for (const bucket of this.spatialHash.values()) {\r\n            bucket.length = 0;\r\n        }\r\n\r\n        for (const entity of this.entities) {\r\n            if (!entity.active) continue;\r\n            if (entity.collision) updateSpatialHash(entity, this.spatialHash, this.cellSize);\r\n        }\r\n\r\n        if (this.debugMode) {\r\n            // Render handled by GameRenderer\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update entity movement with collision resolution\r\n     */\r\n    public updateMovement(entity: Entity, direction: { x: number, y: number }, speed: number, dt: number) {\r\n        if (!entity.active || speed <= 0) return { x: 0, y: 0, collidedX: false, collidedY: false };\r\n\r\n        const msPerSecond = GameConstants.Timing.MS_PER_SECOND;\r\n        const dx = direction.x * (speed * dt / msPerSecond);\r\n        const dy = direction.y * (speed * dt / msPerSecond);\r\n\r\n        // Resolve X\r\n        const originalX = entity.x;\r\n        entity.x += dx;\r\n        let colX = false;\r\n        if (checkCollision(entity, this.spatialHash, this.cellSize, getCollisionBounds)) {\r\n            entity.x = originalX;\r\n            colX = true;\r\n        }\r\n        const movedX = entity.x - originalX;\r\n\r\n        // Resolve Y\r\n        const originalY = entity.y;\r\n        entity.y += dy;\r\n        let colY = false;\r\n        if (checkCollision(entity, this.spatialHash, this.cellSize, getCollisionBounds)) {\r\n            entity.y = originalY;\r\n            colY = true;\r\n        }\r\n        const movedY = entity.y - originalY;\r\n\r\n        // Update Prev Position for interpolation (at end of frame usually, but here is fine for now)\r\n        entity.prevX = originalX; // Note: This might be updated elsewhere too\r\n        entity.prevY = originalY;\r\n\r\n        return {\r\n            x: movedX,\r\n            y: movedY,\r\n            collidedX: colX,\r\n            collidedY: colY\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Attempt to move an entity by (dx, dy) handling collisions.\r\n     * Returns the ACTUAL amount moved.\r\n     */\r\n    move(entity: Entity, dx: number, dy: number): { x: number, y: number } {\r\n        const col = entity.collision;\r\n        if (!col || !col.enabled) {\r\n            entity.x += dx;\r\n            entity.y += dy;\r\n            return { x: dx, y: dy };\r\n        }\r\n\r\n        let actualDx = dx;\r\n        let actualDy = dy;\r\n\r\n        if (dx !== 0) {\r\n            entity.x += dx;\r\n            if (checkCollision(entity, this.spatialHash, this.cellSize, getCollisionBounds)) {\r\n                entity.x -= dx;\r\n                actualDx = 0;\r\n            }\r\n        }\r\n        if (dy !== 0) {\r\n            entity.y += dy;\r\n            if (checkCollision(entity, this.spatialHash, this.cellSize, getCollisionBounds)) {\r\n                entity.y -= dy;\r\n                actualDy = 0;\r\n            }\r\n        }\r\n\r\n        if (col.layer === CollisionLayers.ENEMY) this.applySeparation(entity);\r\n\r\n        checkTriggers(entity, this.spatialHash, this.cellSize, this.activeCollisions, this._currentOverlapsScratch, this.entities, getCollisionBounds);\r\n\r\n        return { x: actualDx, y: actualDy };\r\n    }\r\n\r\n    private applySeparation(_entity: Entity) {\r\n        // Separation/flocking logic not yet implemented\r\n    }\r\n\r\n    /** Render collision debug info (Called by GameRenderer). Context is already translated to World View. */\r\n    renderDebug(ctx: CanvasRenderingContext2D): void {\r\n        renderCollisionDebug(ctx, {\r\n            debugMode: this.debugMode,\r\n            entities: this.entities,\r\n            getCollisionBounds\r\n        });\r\n    }\r\n}\r\n\r\nconst collisionSystem = new CollisionSystem();\r\nif (Registry) Registry.register('CollisionSystem', collisionSystem);\r\nexport { collisionSystem };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\systems\\CollisionSystemCollision.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getCollisionBounds' is defined but never used.","line":8,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":28,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"getCollisionBounds"},"fix":{"range":[297,316],"text":""},"desc":"Remove unused variable \"getCollisionBounds\"."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * CollisionSystemCollision  Collision detection and trigger event handling.\r\n */\r\nimport { Entity } from '../core/Entity';\r\nimport { WorldManager } from '../world/WorldManager';\r\nimport { GameConstants } from '../data/GameConstants';\r\nimport { EventBus } from '../core/EventBus';\r\nimport { getCollisionBounds, isHardCollision, isTriggerCollision } from './CollisionSystemUtils';\r\n\r\nexport function checkCollision(\r\n    entity: Entity,\r\n    spatialHash: Map<string, Entity[]>,\r\n    cellSize: number,\r\n    getBounds: (e: Entity) => { x: number; y: number; width: number; height: number }\r\n): boolean {\r\n    const col = entity.collision;\r\n    const bounds = getBounds(entity);\r\n\r\n    if (WorldManager.isBlocked(bounds.x, bounds.y) ||\r\n        WorldManager.isBlocked(bounds.x + bounds.width, bounds.y) ||\r\n        WorldManager.isBlocked(bounds.x, bounds.y + bounds.height) ||\r\n        WorldManager.isBlocked(bounds.x + bounds.width, bounds.y + bounds.height)) {\r\n        return true;\r\n    }\r\n\r\n    const startX = Math.floor(bounds.x / cellSize);\r\n    const startY = Math.floor(bounds.y / cellSize);\r\n    const endX = Math.floor((bounds.x + bounds.width) / cellSize);\r\n    const endY = Math.floor((bounds.y + bounds.height) / cellSize);\r\n\r\n    for (let x = startX; x <= endX; x++) {\r\n        for (let y = startY; y <= endY; y++) {\r\n            const key = `${x},${y}`;\r\n            const neighbors = spatialHash.get(key);\r\n            if (!neighbors) continue;\r\n\r\n            for (const other of neighbors) {\r\n                if (other === entity || !other.active) continue;\r\n\r\n                const otherCol = other.collision;\r\n                if (!otherCol || !otherCol.enabled) continue;\r\n\r\n                if (col && isHardCollision(col, otherCol)) {\r\n                    if (entity.collidesWith(other)) return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nexport function checkTriggers(\r\n    entity: Entity,\r\n    spatialHash: Map<string, Entity[]>,\r\n    cellSize: number,\r\n    activeCollisions: Map<string, Set<string>>,\r\n    currentOverlapsScratch: Set<string>,\r\n    entities: Entity[],\r\n    getBounds: (e: Entity) => { x: number; y: number; width: number; height: number }\r\n): void {\r\n    const col = entity.collision;\r\n    if (!col) return;\r\n\r\n    const bounds = getBounds(entity);\r\n    const startX = Math.floor(bounds.x / cellSize);\r\n    const startY = Math.floor(bounds.y / cellSize);\r\n    const endX = Math.floor((bounds.x + bounds.width) / cellSize);\r\n    const endY = Math.floor((bounds.y + bounds.height) / cellSize);\r\n\r\n    currentOverlapsScratch.clear();\r\n\r\n    for (let x = startX; x <= endX; x++) {\r\n        for (let y = startY; y <= endY; y++) {\r\n            const key = `${x},${y}`;\r\n            const neighbors = spatialHash.get(key);\r\n            if (!neighbors) continue;\r\n\r\n            for (const other of neighbors) {\r\n                if (other === entity || !other.active) continue;\r\n\r\n                const otherCol = other.collision;\r\n                if (!otherCol || !otherCol.enabled) continue;\r\n\r\n                if (isTriggerCollision(col, otherCol) && entity.collidesWith(other)) {\r\n                    currentOverlapsScratch.add(other.id);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    let previousOverlaps = activeCollisions.get(entity.id);\r\n    if (!previousOverlaps) {\r\n        previousOverlaps = new Set();\r\n        activeCollisions.set(entity.id, previousOverlaps);\r\n    }\r\n\r\n    for (const otherId of currentOverlapsScratch) {\r\n        if (!previousOverlaps.has(otherId)) {\r\n            const other = entities.find((e) => e.id === otherId);\r\n            if (other) EventBus.emit(GameConstants.Events.COLLISION_START, { a: entity, b: other });\r\n        }\r\n    }\r\n\r\n    for (const otherId of previousOverlaps) {\r\n        if (!currentOverlapsScratch.has(otherId)) {\r\n            const other = entities.find((e) => e.id === otherId);\r\n            if (other) EventBus.emit(GameConstants.Events.COLLISION_END, { a: entity, b: other });\r\n        }\r\n    }\r\n\r\n    previousOverlaps.clear();\r\n    for (const id of currentOverlapsScratch) previousOverlaps.add(id);\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\systems\\CollisionSystemDebug.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\systems\\CollisionSystemSpatialHash.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\systems\\CollisionSystemUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\systems\\CombatController.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'dt' is defined but never used. Allowed unused args must match /^_/u.","line":42,"column":12,"nodeType":"Identifier","messageId":"unusedVar","endLine":42,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'i' is assigned a value but never used.","line":88,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":88,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'target' is defined but never used. Allowed unused args must match /^_/u.","line":156,"column":29,"nodeType":"Identifier","messageId":"unusedVar","endLine":156,"endColumn":35},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'type' is defined but never used. Allowed unused args must match /^_/u.","line":156,"column":46,"nodeType":"Identifier","messageId":"unusedVar","endLine":156,"endColumn":50}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * CombatController - Manages combat targeting, attacks, and loot drops\r\n *\r\n * Extracted from Game.js to separate combat logic from the core game loop.\r\n * Handles auto-targeting, attack execution, and item spawning.\r\n *\r\n * Owner: Gameplay Engineer\r\n */\r\n\r\nimport { Logger } from '@core/Logger';\r\nimport { GameConstants } from '@data/GameConstants';\r\nimport { entityManager } from '@core/EntityManager';\r\nimport { Registry } from '@core/Registry';\r\nimport { heroSystem } from './HeroSystem';\r\nimport { MathUtils } from '@core/MathUtils';\r\nimport type { IGame, IEntity } from '../types/core';\r\n\r\n// Reference entityManager as EntityManager for global usage pattern\r\nconst EntityManager = entityManager;\r\n\r\nclass CombatController {\r\n    game: IGame | null = null;\r\n    _logTimer: number = 0;\r\n\r\n    constructor() {\r\n        Logger.info('[CombatController] Constructed');\r\n    }\r\n\r\n    /**\r\n     * Initialize with game reference\r\n     * @param {Game} game\r\n     */\r\n    init(game: IGame) {\r\n        this.game = game;\r\n        Logger.info('[CombatController] Initialized');\r\n    }\r\n\r\n    /**\r\n     * Update combat logic\r\n     * @param {number} dt - Delta time\r\n     */\r\n    update(dt: number) {\r\n        if (!this.game || !this.game.hero) return;\r\n\r\n        // Debug Throttle (every ~60 frames)\r\n        this._logTimer++;\r\n        const doLog = this._logTimer % 60 === 0;\r\n\r\n        const hero = this.game.hero;\r\n        // Use EntityManager for efficient lookups\r\n        const resources = EntityManager ? EntityManager.getByType('Resource') : [];\r\n        const dinosaurs = EntityManager ? EntityManager.getByType('Dinosaur') : [];\r\n\r\n        // Debug once per second\r\n        if (doLog) {\r\n            // Logger.info(`[CombatController] Entities - Resources: ${resources.length}, Dinos: ${dinosaurs.length}`);\r\n        }\r\n\r\n        const combat = hero.components && hero.components.combat;\r\n\r\n        // Reset dinosaur attack flags\r\n        for (const dino of dinosaurs) {\r\n            if (dino.active) {\r\n                dino.isBeingAttacked = false;\r\n            }\r\n        }\r\n\r\n        // Find closest target (Resource or Dinosaur)\r\n        let closestTarget = null;\r\n        let closestDist = Infinity;\r\n        let targetType = null;\r\n\r\n        // Check resources (Mining Range)\r\n        const miningDist =\r\n            hero.miningRange || (combat ? combat.range : GameConstants.Combat.DEFAULT_MINING_RANGE);\r\n        let i = 0;\r\n        for (const resource of resources) {\r\n            // Must be active AND ready (not depleted)\r\n            if (resource.active && resource.state === 'ready') {\r\n                const dist = resource.distanceTo(hero);\r\n\r\n                if (dist <= miningDist && dist < closestDist) {\r\n                    closestDist = dist;\r\n                    closestTarget = resource;\r\n                    targetType = 'resource';\r\n                }\r\n            }\r\n            i++;\r\n        }\r\n\r\n        // Check dinosaurs (Gun Range) - use stats component for equipped weapon range\r\n        const gunDist =\r\n            hero.stats?.getAttackRange?.() ||\r\n            (combat ? combat.range : GameConstants.Combat.DEFAULT_GUN_RANGE);\r\n\r\n        for (const dino of dinosaurs) {\r\n            if (dino.active) {\r\n                const dist = dino.distanceTo(hero);\r\n                // Dinos are valid targets if within gun range (and not dead)\r\n                if (dino.state !== 'dead' && dist <= gunDist && dist < closestDist) {\r\n                    closestDist = dist;\r\n                    closestTarget = dino;\r\n                    targetType = 'dinosaur';\r\n                }\r\n            }\r\n        }\r\n\r\n        // Check enemies (highest priority - hostile entities)\r\n        // Note: Use constructor.name ('Enemy', 'Boss') since entityType varies\r\n        const enemies = EntityManager\r\n            ? [...EntityManager.getByType('Enemy'), ...EntityManager.getByType('Boss')]\r\n            : [];\r\n\r\n        for (const enemy of enemies) {\r\n            if (enemy.active && !enemy.isDead) {\r\n                const dist = enemy.distanceTo\r\n                    ? enemy.distanceTo(hero)\r\n                    : MathUtils.distance(enemy.x, enemy.y, hero.x, hero.y);\r\n                // Enemies are valid targets within gun range\r\n                if (dist <= gunDist && dist < closestDist) {\r\n                    closestDist = dist;\r\n                    closestTarget = enemy;\r\n                    targetType = 'enemy';\r\n                }\r\n            }\r\n        }\r\n\r\n        // Auto-attack closest target\r\n        if (closestTarget) {\r\n            // Logger.info(`[Combat] Target found: ${targetType}`);\r\n            // Freeze dinosaurs while being attacked\r\n            if (targetType === 'dinosaur') {\r\n                closestTarget.isBeingAttacked = true;\r\n            }\r\n\r\n            // Execute attack (Delegated to HeroSystem)\r\n            let destroyed = false;\r\n            if (heroSystem) {\r\n                destroyed = heroSystem.tryAttack(hero, closestTarget);\r\n            }\r\n\r\n            if (destroyed) {\r\n                this.handleTargetDestruction(closestTarget, targetType);\r\n            }\r\n        } else {\r\n            hero.targetResource = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle logic when a target is destroyed (state updates, VFX)\r\n     * NOTE: Drops are already created by Resource.takeDamage / DinosaurSystem\r\n     * @param {Entity} target\r\n     * @param {string} type - 'resource' or 'dinosaur'\r\n     */\r\n    handleTargetDestruction(target: IEntity, type: string) {\r\n        // Drops are handled by the entity's own takeDamage method\r\n        // This method is now only used for any additional destruction effects\r\n        // (Currently none - preserved for future extension like VFX, audio, etc.)\r\n    }\r\n}\r\n\r\n// Create singleton and export\r\nconst combatController = new CombatController();\r\n\r\n// Register at module load time\r\nRegistry.register('CombatController', combatController);\r\n\r\nexport { CombatController, combatController };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\systems\\DamageSystem.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'DamageableEntity' is defined but never used.","line":24,"column":34,"nodeType":"Identifier","messageId":"unusedVar","endLine":24,"endColumn":50,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"DamageableEntity"},"fix":{"range":[796,814],"text":""},"desc":"Remove unused variable \"DamageableEntity\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'killer' is assigned a value but never used.","line":186,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":186,"endColumn":31}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * DamageSystem\n * Centralized handler for all damage, death, and combat VFX logic.\n *\n * Responsibilities:\n * - Listens for ENTITY_DAMAGED\n * - Applies damage to Health/Stats components\n * - Triggers Blood/Hit VFX\n * - Triggers Floating Text\n * - Handles Death (ENTITY_DIED) and Loot generation\n *\n * Owner: Combat System\n */\n\nimport { Logger } from '@core/Logger';\nimport { EventBus } from '@core/EventBus';\nimport { GameConstants } from '@data/GameConstants';\nimport { VFXController } from '@vfx/VFXController';\nimport { VFXConfig } from '@data/VFXConfig';\nimport { AudioManager } from '@audio/AudioManager';\nimport { Registry } from '@core/Registry';\nimport { EntityTypes } from '@config/EntityTypes';\nimport type { IGame, IEntity } from '../types/core.d';\nimport { isDamageable, isMortal, DamageableEntity } from '../utils/typeGuards';\n\nconst Events = GameConstants.Events;\n\nclass DamageSystem {\n    game: IGame | null = null;\n\n    private _onDamageBound: (data: { entity: IEntity; amount: number; source?: IEntity; type?: string }) => void;\n    private _onDeathBound: (data: { entity: IEntity }) => void;\n\n    constructor() {\n        Logger.info('[DamageSystem] Initialized');\n        // Bind handlers once\n        this._onDamageBound = this.handleDamage.bind(this);\n        this._onDeathBound = this.handleDeath.bind(this);\n\n        this.initListeners();\n    }\n\n    init(game: IGame) {\n        this.game = game;\n    }\n\n    initListeners() {\n        if (EventBus) {\n            EventBus.on(Events.ENTITY_DAMAGED, this._onDamageBound);\n            EventBus.on(Events.ENTITY_DIED, this._onDeathBound);\n        }\n    }\n\n    destroy() {\n        if (EventBus) {\n            EventBus.off(Events.ENTITY_DAMAGED, this._onDamageBound);\n            EventBus.off(Events.ENTITY_DIED, this._onDeathBound);\n            Logger.info('[DamageSystem] Cleared listeners');\n        }\n    }\n\n    /**\n     * Process incoming damage\n     */\n    handleDamage(data: { entity: IEntity; amount: number; source?: IEntity; type?: string }) {\n        const { entity, amount, source, type } = data;\n        if (!entity || !entity.active || entity.isDead) return;\n\n        // 1. Apply Damage (using component if available)\n        // Check for StatsComponent (Hero/Complex Entities)\n        let finalDamage = amount;\n        const healthComponent = entity.components?.health || entity.components?.stats;\n\n        // Apply Armor reduction (simple flat reduction for now)\n        if (entity.defense) {\n            finalDamage = Math.max(1, finalDamage - entity.defense);\n        }\n\n        let tookDamage = false;\n\n        if (healthComponent && typeof healthComponent.health === 'number') {\n            // Data-only: apply damage and clamp; systems emit events\n            Logger.info(\n                `[DamageSystem] Applying ${finalDamage} damage to component on ${entity.id}`\n            );\n            healthComponent.health = Math.max(0, healthComponent.health - finalDamage);\n            if (healthComponent.health <= 0) {\n                healthComponent.isDead = true;\n                healthComponent.health = 0;\n            }\n            tookDamage = true;\n            const maxH = healthComponent.maxHealth ?? entity.maxHealth;\n            if (entity.entityType === EntityTypes.HERO) {\n                EventBus.emit(Events.HERO_HEALTH_CHANGE, { current: healthComponent.health, max: maxH });\n            } else {\n                EventBus.emit(Events.ENTITY_HEALTH_CHANGE, { entity, current: healthComponent.health, max: maxH });\n            }\n        } else if (isDamageable(entity)) {\n            // Entity handles its own damage (e.g. Resource)\n            Logger.info(`[DamageSystem] Delegating damage to entity ${entity.id}`);\n            entity.takeDamage(finalDamage);\n            return; // Entity handles VFX/Death/State\n        } else if (typeof entity.health === 'number') {\n            Logger.info(\n                `[DamageSystem] Applying ${finalDamage} damage directly to entity ${entity.id}`\n            );\n            // Fallback to direct entity property (Enemies mostly)\n            entity.health -= finalDamage;\n            if (entity.health < 0) entity.health = 0;\n            tookDamage = true;\n        }\n\n        if (!tookDamage) return;\n\n        // 2. Trigger VFX & SFX\n        this.playHitEffects(entity, finalDamage, type);\n\n        // 3. Check Death\n        const currentHealth = healthComponent ? healthComponent.health : entity.health;\n        if (currentHealth <= 0) {\n            // Call entity-specific death handler (sets respawn timers, cleanup, etc.)\n            if (isMortal(entity)) {\n                entity.die(source);\n            } else {\n                // Fallback\n                entity.isDead = true;\n                entity.state = 'dead';\n            }\n\n            EventBus.emit(GameConstants.Events.ENTITY_DIED, {\n                entity: entity,\n                killer: source\n            });\n        }\n    }\n\n    /**\n     * visual and audio effects for damage\n     */\n    playHitEffects(entity: IEntity, amount: number, type: string = 'physical') {\n        const x = entity.x;\n        const y = entity.y;\n\n        // Floating Text: emit event; FloatingTextManager subscribes\n        const yOffset = GameConstants.Damage.FLOATING_TEXT_Y_OFFSET;\n        const isCrit = type === 'crit';\n        if (EventBus) {\n            EventBus.emit(GameConstants.Events.DAMAGE_NUMBER_REQUESTED, {\n                x,\n                y: y - yOffset,\n                amount: Math.round(amount),\n                isCrit\n            });\n        }\n\n        // SFX\n        if (AudioManager) {\n            const isHero = entity.entityType === EntityTypes.HERO;\n            AudioManager.playSFX(isHero ? 'sfx_hero_hurt' : 'sfx_enemy_hurt');\n        }\n\n        // VFX (Blood)\n        if (VFXController && VFXConfig) {\n            const isMechanical = entity.entityType === EntityTypes.BUILDING; // Assuming buildings bleed sparks not blood\n\n            if (isMechanical) {\n                // Sparks for mechanical/buildings\n                // TODO: Add Spark VFX config\n            } else {\n                // Organic Blood VFX\n                VFXController.playForeground(x, y, VFXConfig.DINO.BLOOD_SPLATTER);\n                VFXController.playForeground(x, y, VFXConfig.DINO.BLOOD_MIST);\n\n                const threshold = GameConstants.Combat.DAMAGE_VFX_THRESHOLD;\n                if (amount > threshold) {\n                    VFXController.playForeground(x, y, VFXConfig.DINO.BLOOD_DROPS);\n                }\n            }\n        }\n    }\n\n    /**\n     * Handle entity death\n     */\n    handleDeath(data: { entity: IEntity; killer?: IEntity }) {\n        const { entity, killer } = data;\n\n        Logger.info(`[DamageSystem] Entity died: ${entity.entityType} (ID: ${entity.id})`);\n\n        // 1. Hero Death\n        if (entity.entityType === EntityTypes.HERO) {\n            EventBus.emit(GameConstants.Events.HERO_DIED, { hero: entity });\n            if (AudioManager) AudioManager.playSFX('sfx_hero_death');\n            return;\n        }\n\n        // 2. Enemy Death\n        if (this.isEnemy(entity)) {\n            if (AudioManager) AudioManager.playSFX('sfx_enemy_death');\n\n            // Emit kill event for Quests/XP\n            EventBus.emit(GameConstants.Events.ENEMY_KILLED, {\n                enemy: entity,\n                xpReward: entity.xpReward ?? GameConstants.Combat.XP_REWARD_FALLBACK,\n                lootTableId: entity.lootTableId\n            });\n        }\n    }\n\n    isEnemy(entity: IEntity): boolean {\n        return (\n            entity.entityType === EntityTypes.ENEMY_DINOSAUR ||\n            entity.entityType === EntityTypes.ENEMY_SOLDIER ||\n            entity.entityType === EntityTypes.ENEMY_SAURIAN ||\n            (entity.constructor && entity.constructor.name === 'Enemy')\n        );\n    }\n}\n\n// Singleton Management for HMR\nif (Registry) {\n    const previousInstance = Registry.get('DamageSystem');\n    if (previousInstance && typeof previousInstance.destroy === 'function') {\n        previousInstance.destroy();\n    }\n}\n\nconst damageSystem = new DamageSystem();\nif (Registry) Registry.register('DamageSystem', damageSystem);\n\nexport { DamageSystem, damageSystem };\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\systems\\Dialogue.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\systems\\DinosaurSystem.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'BOUNDS_PADDING' is assigned a value but never used.","line":19,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * DinosaurSystem\r\n * Handles AI, Movement, and Animation updates for all Dinosaurs.\r\n */\r\n\r\nimport { Logger } from '@core/Logger';\r\nimport { EventBus } from '@core/EventBus';\r\nimport { entityManager } from '@core/EntityManager';\r\nimport { AudioManager } from '../audio/AudioManager';\r\nimport { VFXController } from '@vfx/VFXController';\r\nimport { VFXConfig } from '@data/VFXConfig';\r\nimport { spawnDrop } from '../gameplay/SpawnHelper';\r\nimport { GameConstants } from '@data/GameConstants';\r\nimport { Registry } from '@core/Registry';\r\nimport { EntityTypes } from '@config/EntityTypes';\r\nimport type { IGame, IEntity } from '../types/core.d';\r\n\r\n// Bounds padding constant (was from BaseCreature)\r\nconst BOUNDS_PADDING = 30;\r\n\r\n// Event data interfaces\r\ninterface EntityDamageEvent {\r\n    entity: IEntity;\r\n    amount: number;\r\n    source?: IEntity;\r\n}\r\ninterface EntityDeathEvent {\r\n    entity: IEntity;\r\n    killer?: IEntity;\r\n}\r\n\r\nclass DinosaurSystem {\r\n    game: IGame | null = null;\r\n\r\n    constructor() {\r\n        Logger.info('[DinosaurSystem] Initialized');\r\n    }\r\n\r\n    init(game: IGame) {\r\n        this.game = game;\r\n        this.initListeners();\r\n    }\r\n\r\n    initListeners() {\r\n        if (EventBus) {\r\n            EventBus.on(GameConstants.Events.ENTITY_DAMAGED, (data: EntityDamageEvent) => this.onEntityDamaged(data));\r\n            EventBus.on(GameConstants.Events.ENTITY_DIED, (data: EntityDeathEvent) => this.onEntityDied(data));\r\n            EventBus.on(\r\n                GameConstants.Events.MOVEMENT_UPDATE_RESULT,\r\n                (data: { entity: IEntity; actualDx: number; actualDy: number }) => {\r\n                    const d = data.entity as IEntity & { _moveRequested?: { dx: number; dy: number }; _moveResult?: { actualDx: number; actualDy: number } };\r\n                    if (d) d._moveResult = { actualDx: data.actualDx, actualDy: data.actualDy };\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    onEntityDamaged(data: EntityDamageEvent) {\r\n        const { entity, amount } = data;\r\n        if (!entity || entity.entityType !== EntityTypes.DINOSAUR) return;\r\n\r\n        // SFX: Hurt\r\n        if (AudioManager) AudioManager.playSFX('sfx_dino_hurt');\r\n\r\n        // Blood VFX - Multi-layered realistic gore\r\n        if (VFXController && VFXConfig) {\r\n            // Primary blood spray (directional splatter)\r\n            VFXController.playForeground(entity.x, entity.y, VFXConfig.DINO.BLOOD_SPLATTER);\r\n            // Blood mist (fine particles lingering)\r\n            VFXController.playForeground(entity.x, entity.y, VFXConfig.DINO.BLOOD_MIST);\r\n            // Blood droplets (falling drops)\r\n            VFXController.playForeground(entity.x, entity.y, VFXConfig.DINO.BLOOD_DROPS);\r\n            // Meat chunks on heavy hits\r\n            if (amount > 10) {\r\n                VFXController.playForeground(entity.x, entity.y, VFXConfig.DINO.MEAT_CHUNKS);\r\n            }\r\n        }\r\n    }\r\n\r\n    onEntityDied(data: EntityDeathEvent) {\r\n        const { entity } = data;\r\n        if (!entity || entity.entityType !== EntityTypes.DINOSAUR) return;\r\n\r\n        // SFX: Death\r\n        if (AudioManager) AudioManager.playSFX('sfx_dino_death');\r\n\r\n        // Death logic handled in updateDino via HealthComponent sync\r\n    }\r\n\r\n    update(dt: number) {\r\n        if (!entityManager) return;\r\n        const dinos = entityManager.getByType('Dinosaur');\r\n        for (const dino of dinos) {\r\n            if (dino.active) {\r\n                this.updateDino(dino, dt);\r\n            }\r\n        }\r\n    }\r\n\r\n    updateDino(dino: IEntity, dt: number) {\r\n        // Sync with HealthComponent\r\n        if (dino.components.health) {\r\n            dino.health = dino.components.health.health;\r\n            if (dino.components.health.isDead && dino.state !== 'dead') {\r\n                dino.state = 'dead';\r\n                dino.health = 0;\r\n                dino.respawnTimer = dino.maxRespawnTime;\r\n                if (AudioManager) AudioManager.playSFX('sfx_dino_death');\r\n\r\n                // Trigger Death VFX (Huge Rebirth Effect)\r\n                // Trigger Death VFX (Pixelated Blood Explosion)\r\n                if (VFXController && VFXConfig && VFXConfig.TEMPLATES.DINO_DEATH_FX) {\r\n                    VFXController.playForeground(dino.x, dino.y, VFXConfig.TEMPLATES.DINO_DEATH_FX);\r\n                }\r\n\r\n                // Drop loot directly using SpawnManager (same pattern as Resource.js)\r\n                // This bypasses the complex LootSystem chain and works on file:// protocol\r\n                if (dino.lootTable && Array.isArray(dino.lootTable)) {\r\n                    for (const entry of dino.lootTable) {\r\n                        // Roll chance (0-1 format)\r\n                        if (Math.random() > (entry.chance || 1)) continue;\r\n\r\n                        // Calculate amount\r\n                        let amount = 1;\r\n                        if (Array.isArray(entry.amount)) {\r\n                            amount = Math.floor(\r\n                                entry.amount[0] +\r\n                                Math.random() * (entry.amount[1] - entry.amount[0] + 1)\r\n                            );\r\n                        } else if (entry.amount) {\r\n                            amount = entry.amount;\r\n                        }\r\n\r\n                        // Spawn the drop directly\r\n                        spawnDrop(dino.x, dino.y, entry.item, amount);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // 1. Handle Death / Respawn\r\n        if (dino.state === 'dead') {\r\n            dino.respawnTimer -= dt / 1000;\r\n            if (dino.respawnTimer <= 0) {\r\n                // Respawn\r\n                dino.state = 'alive';\r\n                dino.health = dino.maxHealth;\r\n                if (dino.components.health) {\r\n                    dino.components.health.isDead = false;\r\n                    dino.components.health.health = dino.components.health.maxHealth;\r\n                }\r\n\r\n                if (AudioManager) AudioManager.playSFX('sfx_dino_respawn');\r\n                if (VFXController && VFXConfig) {\r\n                    VFXController.playForeground(dino.x, dino.y, VFXConfig.DINO.RESPAWN);\r\n                }\r\n            }\r\n            return;\r\n        }\r\n\r\n        // 2. Handle Combat Freeze\r\n        if (dino.isBeingAttacked) {\r\n            return;\r\n        }\r\n\r\n        // 3. Wandering AI\r\n        dino.wanderTimer -= dt;\r\n        if (dino.wanderTimer <= 0) {\r\n            this.changeDirection(dino);\r\n        }\r\n\r\n        // Move via EventBus: emit ENTITY_MOVE_REQUEST; CollisionSystem applies and emits MOVEMENT_UPDATE_RESULT\r\n        const cfg = GameConstants.Dinosaur;\r\n        const speedPxPerSec = (dino.moveSpeed ?? cfg.DEFAULT_MOVE_SPEED) * cfg.SPEED_SCALE;\r\n        const msPerSecond = GameConstants.Timing.MS_PER_SECOND;\r\n        const dx = dino.wanderDirection.x * (speedPxPerSec * dt / msPerSecond);\r\n        const dy = dino.wanderDirection.y * (speedPxPerSec * dt / msPerSecond);\r\n\r\n        const d = dino as IEntity & { _moveRequested?: { dx: number; dy: number }; _moveResult?: { actualDx: number; actualDy: number } };\r\n        d._moveRequested = { dx, dy };\r\n        d._moveResult = undefined;\r\n        EventBus.emit(GameConstants.Events.ENTITY_MOVE_REQUEST, { entity: dino, dx, dy });\r\n\r\n        const res = d._moveResult;\r\n        const collidedX = res && dx !== 0 && res.actualDx === 0;\r\n        const collidedY = res && dy !== 0 && res.actualDy === 0;\r\n        if (collidedX) dino.wanderDirection.x *= -1;\r\n        if (collidedY) dino.wanderDirection.y *= -1;\r\n        if (res && res.actualDx === 0 && res.actualDy === 0 && dt > 0) {\r\n            this.changeDirection(dino);\r\n        }\r\n\r\n\r\n        // 4. Animation Frame Cycling\r\n        dino.frameTimer += dt;\r\n        if (dino.frameTimer >= dino.frameInterval) {\r\n            dino.frameTimer = 0;\r\n            if (dino.walkFrames) {\r\n                dino.frameIndex = (dino.frameIndex + 1) % dino.walkFrames.length;\r\n            }\r\n        }\r\n    }\r\n\r\n    changeDirection(dino: IEntity) {\r\n        if (dino.components.ai) {\r\n            dino.components.ai.randomizeWander();\r\n        } else {\r\n            // Fallback for legacy (or if component missing)\r\n            const angle = Math.random() * Math.PI * 2;\r\n            // GC Optimization: Reuse existing object instead of allocating new one\r\n            if (!dino.wanderDirection) {\r\n                dino.wanderDirection = { x: 0, y: 0 };\r\n            }\r\n            dino.wanderDirection.x = Math.cos(angle);\r\n            dino.wanderDirection.y = Math.sin(angle);\r\n            dino.wanderTimer =\r\n                GameConstants.AI.WANDER_TIMER_MIN +\r\n                Math.random() *\r\n                (GameConstants.AI.WANDER_TIMER_MAX - GameConstants.AI.WANDER_TIMER_MIN);\r\n        }\r\n    }\r\n}\r\n\r\n// Create singleton and export\r\nconst dinosaurSystem = new DinosaurSystem();\r\nif (Registry) Registry.register('DinosaurSystem', dinosaurSystem);\r\n\r\nexport { DinosaurSystem, dinosaurSystem };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\systems\\EconomySystem.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getConfig' is defined but never used.","line":10,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":34,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"getConfig"},"fix":{"range":[257,268],"text":""},"desc":"Remove unused variable \"getConfig\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'WorldManager' is defined but never used.","line":12,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":22,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"WorldManager"},"fix":{"range":[342,395],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'AudioManager' is defined but never used.","line":13,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":22,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"AudioManager"},"fix":{"range":[397,450],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'VFXTriggerService' is defined but never used.","line":14,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":27,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"VFXTriggerService"},"fix":{"range":[452,508],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'dt' is defined but never used. Allowed unused args must match /^_/u.","line":40,"column":12,"nodeType":"Identifier","messageId":"unusedVar","endLine":40,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * EconomySystem\r\n * Manages game currency, transactions, and resource validation.\r\n *\r\n * Replaces the legacy Economy.js object literal.\r\n */\r\n\r\nimport { Logger } from '@core/Logger';\r\nimport { EventBus } from '@core/EventBus';\r\nimport { GameConstants, getConfig } from '@data/GameConstants';\r\nimport { GameState } from '@core/State';\r\nimport { WorldManager } from '../world/WorldManager';\r\nimport { AudioManager } from '../audio/AudioManager';\r\nimport { VFXTriggerService } from './VFXTriggerService';\r\nimport { Registry } from '@core/Registry';\r\nimport type { IGame } from '../types/core';\r\n\r\nclass EconomySystem {\r\n    game: IGame | null = null;\r\n\r\n    constructor() {\r\n        Logger.info('[EconomySystem] Constructed');\r\n    }\r\n\r\n    init(game: IGame) {\r\n        this.game = game;\r\n        this.initListeners();\r\n        Logger.info('[EconomySystem] Initialized');\r\n    }\r\n\r\n    initListeners() {\r\n        if (!EventBus) return;\r\n\r\n\r\n        // Listen for direct gold modification requests (e.g. from debug or cheats)\r\n        EventBus.on(GameConstants.Events.ADD_GOLD, (amount: number) => this.addGold(amount));\r\n\r\n    }\r\n\r\n    update(dt: number) {\r\n        // No per-frame logic needed currently\r\n    }\r\n\r\n    /**\r\n     * Get current gold amount\r\n     */\r\n    getGold() {\r\n        const hero = this.game?.hero as { inventory?: { gold: number } } | undefined;\r\n        if (hero && hero.inventory) {\r\n            return hero.inventory.gold || 0;\r\n        }\r\n        return GameState ? (GameState.get('gold') as number) || 0 : 0;\r\n    }\r\n\r\n    /**\r\n     * Internal method to deduct gold\r\n     * @param {number} amount\r\n     */\r\n    spendGold(amount: number) {\r\n        const currentGold = this.getGold();\r\n        if (currentGold < amount) return false;\r\n\r\n        const newGold = currentGold - amount;\r\n\r\n        // Update Hero\r\n        const hero = this.game?.hero as { inventory?: { gold: number } } | undefined;\r\n        if (hero && hero.inventory) {\r\n            hero.inventory.gold = newGold;\r\n        }\r\n\r\n        // Update Persistence\r\n        if (GameState) {\r\n            GameState.set('gold', newGold);\r\n        }\r\n\r\n        // Emit Update\r\n        if (EventBus) {\r\n            EventBus.emit(GameConstants.Events.INVENTORY_UPDATED, hero.inventory);\r\n        }\r\n\r\n        Logger.info(`[EconomySystem] Spent ${amount}. New Balance: ${newGold}`);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Internal method to add gold\r\n     * @param {number} amount\r\n     */\r\n    addGold(amount: number) {\r\n        const currentGold = this.getGold();\r\n        const newGold = currentGold + amount;\r\n\r\n        // Update Hero\r\n        const hero = this.game?.hero as { inventory?: { gold: number } } | undefined;\r\n        if (hero && hero.inventory) {\r\n            hero.inventory.gold = newGold;\r\n        }\r\n\r\n        // Update Persistence\r\n        if (GameState) {\r\n            GameState.set('gold', newGold);\r\n        }\r\n\r\n        // Emit Update\r\n        if (EventBus) {\r\n            EventBus.emit(GameConstants.Events.INVENTORY_UPDATED, hero.inventory);\r\n        }\r\n\r\n        Logger.info(`[EconomySystem] Added ${amount}. New Balance: ${newGold}`);\r\n    }\r\n\r\n\r\n}\r\n\r\n// Create singleton and export\r\nconst economySystem = new EconomySystem();\r\nif (Registry) Registry.register('EconomySystem', economySystem);\r\n\r\nexport { EconomySystem, economySystem };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\systems\\EnemySystem.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getConfig' is defined but never used.","line":11,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":34,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"getConfig"},"fix":{"range":[306,317],"text":""},"desc":"Remove unused variable \"getConfig\"."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * EnemySystem\r\n * Handles AI, Movement, and Combat updates for hostile enemies.\r\n *\r\n * States: WANDER, CHASE, ATTACK, LEASH_RETURN\r\n */\r\n\r\nimport { Logger } from '@core/Logger';\r\nimport { EventBus } from '@core/EventBus';\r\nimport { entityManager } from '@core/EntityManager';\r\nimport { GameConstants, getConfig } from '@data/GameConstants';\r\nimport { AudioManager } from '../audio/AudioManager';\r\nimport { VFXController } from '@vfx/VFXController';\r\nimport { VFXConfig } from '@data/VFXConfig';\r\nimport { Registry } from '@core/Registry';\r\nimport { EntityTypes } from '@config/EntityTypes';\r\nimport { MathUtils } from '@core/MathUtils';\r\nimport type { IGame, IEntity } from '@app-types/core';\r\nimport { Enemy } from '../gameplay/EnemyCore';\r\nimport { Entity } from '../core/Entity';\r\nimport { AIComponent } from '../components/AIComponent';\r\nimport { CombatComponent } from '../components/CombatComponent';\r\nimport { HealthComponent } from '../components/HealthComponent';\r\n\r\n// Events from GameConstants\r\nconst Events = GameConstants.Events;\r\n\r\n// Event data interface\r\ninterface EntityEvent {\r\n    entity: IEntity;\r\n    amount?: number;\r\n    killer?: IEntity;\r\n}\r\n\r\nclass EnemySystem {\r\n    game: IGame | null = null;\r\n\r\n    constructor() {\r\n        Logger.info('[EnemySystem] Initialized');\r\n    }\r\n\r\n    init(game: IGame) {\r\n        this.game = game;\r\n        this.initListeners();\r\n    }\r\n\r\n    initListeners() {\r\n        if (EventBus) {\r\n            // EventBus.on('ENTITY_DAMAGED', (data: EntityEvent) => this.onEntityDamaged(data));\r\n            // EventBus.on('ENTITY_DIED', (data: EntityEvent) => this.onEntityDied(data));\r\n        }\r\n    }\r\n\r\n    update(dt: number) {\r\n        if (!entityManager) return;\r\n        const enemies = entityManager.getByType('Enemy');\r\n        const hero = this.game?.hero;\r\n\r\n        for (const enemy_ of enemies) {\r\n            const enemy = enemy_ as Enemy;\r\n            if (enemy.active && enemy.state !== 'dead') {\r\n                this.updateEnemy(enemy, hero, dt);\r\n            }\r\n        }\r\n    }\r\n\r\n    updateEnemy(enemy: Enemy, hero: IEntity | null, dt: number) {\r\n        // Update interpolation state (per fixed tick)\r\n        enemy.prevX = enemy.x;\r\n        enemy.prevY = enemy.y;\r\n\r\n        // Sync HealthComponent to Entity property for Renderer/UI\r\n        const healthComp = enemy.components?.health as HealthComponent;\r\n        if (healthComp) {\r\n            enemy.health = healthComp.health;\r\n        }\r\n\r\n        const ai = enemy.components?.ai as AIComponent;\r\n        if (!ai) return;\r\n\r\n        // Debug state\r\n        // Logger.info(`[EnemySystem] ${enemy.id} State: ${ai.state} Pos: ${enemy.x.toFixed(0)},${enemy.y.toFixed(0)}`);\r\n\r\n        // State Machine\r\n        switch (ai.state) {\r\n            case 'WANDER':\r\n                this.handleWander(enemy, hero, dt);\r\n                break;\r\n            case 'CHASE':\r\n                this.handleChase(enemy, hero, dt);\r\n                break;\r\n            case 'ATTACK':\r\n                this.handleAttack(enemy, hero, dt);\r\n                break;\r\n            case 'LEASH_RETURN':\r\n                this.handleLeashReturn(enemy, dt);\r\n                break;\r\n        }\r\n    }\r\n\r\n    handleWander(enemy: Enemy, hero: IEntity | null, dt: number) {\r\n        const ai = enemy.components?.ai as AIComponent;\r\n\r\n        // Check for aggro\r\n        if (hero && ai.canAggro(hero)) {\r\n            ai.setState('CHASE');\r\n            ai.target = hero;\r\n\r\n            // Pack Aggro - alert nearby grouped enemies\r\n            if (enemy.packAggro && enemy.groupId) {\r\n                this.alertPackMembers(enemy, hero);\r\n            }\r\n\r\n            if (EventBus) {\r\n                EventBus.emit(GameConstants.Events.ENEMY_AGGRO, { enemy, target: hero });\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Wander within patrol area\r\n        ai.wanderTimer -= dt;\r\n        if (ai.wanderTimer <= 0) {\r\n            ai.randomizeWander();\r\n        }\r\n\r\n        const msPerSecond = GameConstants.Timing.MS_PER_SECOND;\r\n        const speed = enemy.speed * (dt / msPerSecond);\r\n        const dx = ai.wanderDirection.x * speed;\r\n        const dy = ai.wanderDirection.y * speed;\r\n\r\n        // Predict next pos for patrol radius check\r\n        const nextX = enemy.x + dx;\r\n        const nextY = enemy.y + dy;\r\n\r\n        // Clamp to patrol radius\r\n        const patrolRadius = enemy.patrolRadius ?? GameConstants.Combat.DEFAULT_PATROL_RADIUS;\r\n        const dist = MathUtils.distance(nextX, nextY, enemy.spawnX, enemy.spawnY);\r\n\r\n        if (dist > patrolRadius) {\r\n            // Reverse direction\r\n            ai.wanderDirection.x *= -1;\r\n            ai.wanderDirection.y *= -1;\r\n            // Immediate turnaround\r\n            return;\r\n        }\r\n\r\n        this.applyMovement(enemy, dx, dy);\r\n    }\r\n\r\n    /**\r\n     * Alert pack members when one enemy aggros\r\n     */\r\n    alertPackMembers(aggroEnemy: IEntity, target: IEntity) {\r\n        if (!entityManager) return;\r\n\r\n        const enemies = entityManager.getByType('Enemy');\r\n        const alertRadius = GameConstants.Biome.PACK_AGGRO_RADIUS;\r\n\r\n        for (const enemy of enemies) {\r\n            if (enemy === aggroEnemy) continue;\r\n            if (enemy.groupId !== aggroEnemy.groupId) continue;\r\n            if (!enemy.packAggro) continue; // Respect individual packAggro flag\r\n            const ai = enemy.components?.ai as AIComponent;\r\n            if (ai?.state !== 'WANDER') continue;\r\n\r\n            // Check distance\r\n            const dist = MathUtils.distance(enemy.x, enemy.y, aggroEnemy.x, aggroEnemy.y);\r\n\r\n            if (dist <= alertRadius) {\r\n                ai.setState?.('CHASE');\r\n                ai.target = target;\r\n            }\r\n        }\r\n    }\r\n\r\n    handleChase(enemy: Enemy, hero: IEntity, dt: number) {\r\n        const ai = enemy.components?.ai as AIComponent;\r\n\r\n        // Check leash\r\n        if (ai.shouldLeash()) {\r\n            ai.setState('LEASH_RETURN');\r\n            ai.target = null;\r\n            if (EventBus) {\r\n                EventBus.emit(GameConstants.Events.ENEMY_LEASH, { enemy });\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Check attack range\r\n        if (ai.inAttackRange(hero)) {\r\n            ai.setState('ATTACK');\r\n            return;\r\n        }\r\n\r\n        // Move toward target\r\n        const dxRaw = hero.x - enemy.x;\r\n        const dyRaw = hero.y - enemy.y;\r\n        const dist = MathUtils.distance(enemy.x, enemy.y, hero.x, hero.y);\r\n\r\n        if (dist > 0) {\r\n            const ms = GameConstants?.Timing?.MS_PER_SECOND ?? 1000;\r\n            const speed = enemy.speed * (dt / ms);\r\n            const dx = (dxRaw / dist) * speed;\r\n            const dy = (dyRaw / dist) * speed;\r\n            this.applyMovement(enemy, dx, dy);\r\n        }\r\n    }\r\n\r\n    applyMovement(enemy: IEntity, dx: number, dy: number) {\r\n        if (enemy instanceof Entity && EventBus) {\r\n            EventBus.emit(GameConstants.Events.ENTITY_MOVE_REQUEST, { entity: enemy, dx, dy });\r\n        } else {\r\n            enemy.x += dx;\r\n            enemy.y += dy;\r\n        }\r\n    }\r\n\r\n    handleAttack(enemy: Enemy, hero: IEntity, dt: number) {\r\n        const ai = enemy.components?.ai as AIComponent;\r\n        const combat = enemy.components?.combat as CombatComponent;\r\n\r\n        // Check if still in range\r\n        if (!ai.inAttackRange(hero)) {\r\n            ai.setState('CHASE');\r\n            return;\r\n        }\r\n\r\n        // Check leash\r\n        if (ai.shouldLeash()) {\r\n            ai.setState('LEASH_RETURN');\r\n            return;\r\n        }\r\n\r\n        if (combat) {\r\n            if (combat.cooldownTimer > 0) {\r\n                combat.cooldownTimer -= dt / 1000;\r\n                if (combat.cooldownTimer <= 0) {\r\n                    combat.cooldownTimer = 0;\r\n                    combat.canAttack = true;\r\n                }\r\n            }\r\n            if (combat.canAttack) {\r\n                combat.cooldownTimer = 1 / combat.rate;\r\n                combat.canAttack = false;\r\n                if (EventBus) {\r\n                    EventBus.emit(GameConstants.Events.ENTITY_DAMAGED, {\r\n                        entity: hero,\r\n                        amount: combat.damage,\r\n                        source: enemy,\r\n                        type: 'physical'\r\n                    });\r\n                    EventBus.emit(GameConstants.Events.ENEMY_ATTACK, {\r\n                        attacker: enemy,\r\n                        target: hero,\r\n                        damage: combat.damage\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    handleLeashReturn(enemy: Enemy, dt: number) {\r\n        const ai = enemy.components?.ai as AIComponent;\r\n\r\n        // Move back to spawn\r\n        const dxRaw = enemy.spawnX - enemy.x;\r\n        const dyRaw = enemy.spawnY - enemy.y;\r\n        const dist = MathUtils.distance(enemy.x, enemy.y, enemy.spawnX, enemy.spawnY);\r\n\r\n        const arrivalThreshold = GameConstants.Biome.LEASH_ARRIVAL_THRESHOLD;\r\n        if (dist < arrivalThreshold) {\r\n            ai.setState('WANDER');\r\n            return;\r\n        }\r\n\r\n        const ms = GameConstants?.Timing?.MS_PER_SECOND ?? 1000;\r\n        const mult = GameConstants.Biome.LEASH_RETURN_SPEED_MULTIPLIER;\r\n        const speed = enemy.speed * mult * (dt / ms);\r\n        const dx = (dxRaw / dist) * speed;\r\n        const dy = (dyRaw / dist) * speed;\r\n        this.applyMovement(enemy, dx, dy);\r\n    }\r\n\r\n    onEntityDamaged(data: EntityEvent) {\r\n        const { entity, amount } = data;\r\n        if (!entity) return;\r\n\r\n        const entityType = entity.entityType;\r\n        if (\r\n            entityType !== EntityTypes?.ENEMY_DINOSAUR &&\r\n            entityType !== EntityTypes?.ENEMY_SOLDIER &&\r\n            entityType !== EntityTypes?.ENEMY_SAURIAN\r\n        )\r\n            return;\r\n\r\n        // SFX\r\n        if (AudioManager) AudioManager.playSFX('sfx_enemy_hurt');\r\n\r\n        if (VFXController && VFXConfig) {\r\n            VFXController.playForeground(entity.x, entity.y, VFXConfig.DINO.BLOOD_SPLATTER);\r\n            // Blood mist\r\n            VFXController.playForeground(entity.x, entity.y, VFXConfig.DINO.BLOOD_MIST);\r\n            // Blood droplets\r\n            VFXController.playForeground(entity.x, entity.y, VFXConfig.DINO.BLOOD_DROPS);\r\n            // Meat chunks on heavy hits\r\n            const threshold = GameConstants.Combat.DAMAGE_VFX_THRESHOLD;\r\n            if (amount > threshold) {\r\n                VFXController.playForeground(entity.x, entity.y, VFXConfig.DINO.MEAT_CHUNKS);\r\n            }\r\n        }\r\n    }\r\n\r\n    onEntityDied(data: EntityEvent) {\r\n        const { entity } = data;\r\n        if (!entity) return;\r\n\r\n        // Check if entity is an enemy type\r\n        const entityType = entity.entityType;\r\n        if (\r\n            entityType !== EntityTypes?.ENEMY_DINOSAUR &&\r\n            entityType !== EntityTypes?.ENEMY_SOLDIER &&\r\n            entityType !== EntityTypes?.ENEMY_SAURIAN\r\n        )\r\n            return;\r\n\r\n        // Death handling\r\n        entity.state = 'dead';\r\n        if (AudioManager) AudioManager.playSFX('sfx_enemy_death');\r\n\r\n        // Emit for XP/Loot\r\n        if (EventBus) {\r\n            EventBus.emit(Events.ENEMY_KILLED, {\r\n                enemy: entity,\r\n                xpReward: entity.xpReward,\r\n                lootTableId: entity.lootTableId\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\n// Create singleton and export\r\nconst enemySystem = new EnemySystem();\r\nif (Registry) Registry.register('EnemySystem', enemySystem);\r\n\r\nexport { EnemySystem, enemySystem };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\systems\\EquipmentManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'activeSlots' is assigned a value but never used.","line":81,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":81,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'slotId' is defined but never used. Allowed unused args must match /^_/u.","line":87,"column":20,"nodeType":"Identifier","messageId":"unusedVar","endLine":87,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * EquipmentManager\n * Manages equipped items on an entity (typically Hero).\n * Handles equip/unequip, stat aggregation, and set bonus detection.\n *\n * Owner: Gameplay Engineer\n */\n\nimport { Logger } from '@core/Logger';\nimport { EventBus } from '@core/EventBus';\nimport { SetBonusesConfig } from '@config/SetBonusesConfig';\nimport { EquipmentSlotsConfig } from '@config/EquipmentSlotsConfig';\nimport type { ItemStats, EquipmentItem } from '../types/ui';\nimport type { IEntity } from '../types/core';\n\nclass EquipmentManager {\n    owner: IEntity;\n    slots: Record<string, EquipmentItem | null> = {};\n    activeWeaponSet: number = 1;\n\n    /**\n     * @param {IEntity} owner - The entity that owns this equipment\n     */\n    constructor(owner: IEntity) {\n        this.owner = owner;\n\n        // Initialize empty slots from config\n        if (EquipmentSlotsConfig) {\n            for (const slotId of EquipmentSlotsConfig.getSlotIds()) {\n                this.slots[slotId] = null;\n            }\n        }\n\n        // Weapon set initialized above\n\n        Logger.info(`[EquipmentManager] Initialized for ${owner.id || owner.constructor.name}`);\n    }\n\n    /**\n     * Swap between weapon set 1 and weapon set 2\n     */\n    swapWeaponSet() {\n        this.activeWeaponSet = this.activeWeaponSet === 1 ? 2 : 1;\n        Logger.info(`[EquipmentManager] Swapped to weapon set ${this.activeWeaponSet}`);\n\n        if (EventBus) {\n            EventBus.emit('WEAPON_SET_CHANGED', { activeSet: this.activeWeaponSet });\n        }\n\n        return this.activeWeaponSet;\n    }\n\n    /**\n     * Get the slot IDs for the currently active weapon set\n     * @returns {Object} { mainHand: string, offHand: string }\n     */\n    getActiveWeaponSlots() {\n        if (this.activeWeaponSet === 2) {\n            return { mainHand: 'hand1_alt', offHand: 'hand2_alt' };\n        }\n        return { mainHand: 'hand1', offHand: 'hand2' };\n    }\n\n    /**\n     * Get the weapons from the currently active set\n     * @returns {Object} { mainHand: Object|null, offHand: Object|null }\n     */\n    getActiveWeapons() {\n        const slots = this.getActiveWeaponSlots();\n        return {\n            mainHand: this.slots[slots.mainHand],\n            offHand: this.slots[slots.offHand]\n        };\n    }\n\n    /**\n     * Get equipped items that should apply stats (excludes inactive weapon set)\n     * @returns {Object[]}\n     */\n    getEquippedItemsForStats() {\n        const activeSlots = this.getActiveWeaponSlots();\n        const excludedSlots =\n            this.activeWeaponSet === 1 ? ['hand1_alt', 'hand2_alt'] : ['hand1', 'hand2'];\n\n        return Object.entries(this.slots)\n            .filter(([slotId, item]) => item !== null && !excludedSlots.includes(slotId))\n            .map(([slotId, item]) => item);\n    }\n\n    /**\n     * Equip an item to a slot\n     * @param {string} slotId - The slot to equip to (e.g., 'hand1', 'chest')\n     * @param {Object} equipmentData - Full equipment object with id, stats, etc.\n     * @returns {boolean} Success\n     */\n    equip(slotId: string, equipmentData: EquipmentItem) {\n        if (!Object.prototype.hasOwnProperty.call(this.slots, slotId)) {\n            Logger.warn(`[EquipmentManager] Invalid slot: ${slotId}`);\n            return false;\n        }\n\n        // Validate item type can go in this slot\n        const itemSlot = equipmentData.slot;\n        const itemTypeRaw = equipmentData.type;\n        const itemSource = equipmentData.sourceFile;\n        let itemType = itemSlot || itemTypeRaw || itemSource || 'unknown';\n\n        // Strip sub-category qualifiers like 'weapon_melee' -> 'weapon' for validation\n        if (typeof itemType === 'string' && itemType.includes('_')) {\n            itemType = itemType.split('_')[0];\n        }\n\n        if (EquipmentSlotsConfig && !EquipmentSlotsConfig.canEquip(slotId, itemType)) {\n            // Log warning but still allow equip (data issue)\n            Logger.warn(\n                `[EquipmentManager] Type mismatch (normalized: ${itemType}) in ${slotId} - allowing anyway`\n            );\n        }\n\n        // Unequip existing item first\n        const previousItem = this.slots[slotId];\n        this.slots[slotId] = equipmentData;\n\n        // Emit event for UI and other systems\n        if (EventBus) {\n            EventBus.emit('EQUIPMENT_CHANGED', {\n                owner: this.owner.id,\n                slot: slotId,\n                equipped: equipmentData,\n                unequipped: previousItem\n            });\n        }\n\n        Logger.info(`[EquipmentManager] Equipped ${equipmentData.id} to ${slotId}`);\n        return true;\n    }\n\n    /**\n     * Unequip an item from a slot\n     * @param {string} slotId\n     * @returns {Object|null} The unequipped item or null\n     */\n    unequip(slotId: string) {\n        if (!Object.prototype.hasOwnProperty.call(this.slots, slotId)) {\n            return null;\n        }\n\n        const item = this.slots[slotId];\n        this.slots[slotId] = null;\n\n        if (item && EventBus) {\n            EventBus.emit('EQUIPMENT_CHANGED', {\n                owner: this.owner.id,\n                slot: slotId,\n                equipped: null,\n                unequipped: item\n            });\n        }\n\n        return item;\n    }\n\n    /**\n     * Get all currently equipped items\n     * @returns {Object[]} Array of equipped items (non-null)\n     */\n    getEquippedItems() {\n        return Object.values(this.slots).filter((item) => item !== null);\n    }\n\n    /**\n     * Get IDs of all equipped items\n     * @returns {string[]}\n     */\n    getEquippedIds() {\n        return this.getEquippedItems().map((item) => item.id);\n    }\n\n    /**\n     * Get item equipped in a specific slot\n     * @param {string} slotId\n     * @returns {Object|null}\n     */\n    getSlot(slotId: string) {\n        return this.slots[slotId] || null;\n    }\n\n    // === Stat Aggregation ===\n\n    /**\n     * Get total bonus for a stat from all equipped items + set bonuses\n     * @param {string} statKey - e.g., 'damage', 'armor', 'critChance'\n     * @returns {number}\n     */\n    getStatBonus(statKey: string): number {\n        let total = 0;\n\n        // Sum from equipped items (excluding inactive weapon set)\n        for (const item of this.getEquippedItemsForStats()) {\n            if (\n                item.stats &&\n                typeof (item.stats as Record<string, unknown>)[statKey] === 'number'\n            ) {\n                total += (item.stats as Record<string, number>)[statKey];\n            }\n        }\n\n        // Add set bonuses\n        if (SetBonusesConfig) {\n            const setBonuses = SetBonusesConfig.calculateSetBonuses(this.getEquippedIds());\n            if (setBonuses[statKey]) {\n                total += setBonuses[statKey];\n            }\n        }\n\n        return total;\n    }\n\n    /**\n     * Check if any equipped item has a boolean effect\n     * @param {string} effectKey - e.g., 'bleed', 'stagger'\n     * @returns {boolean}\n     */\n    hasEffect(effectKey: string): boolean {\n        for (const item of this.getEquippedItems()) {\n            if (item.stats && (item.stats as Record<string, unknown>)[effectKey] === true) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Get the highest value of a stat from equipped items\n     * Useful for range (use best weapon's range)\n     * @param {string} statKey\n     * @returns {number}\n     */\n    getMaxStat(statKey: string) {\n        let max = 0;\n        for (const item of this.getEquippedItems()) {\n            if (\n                item.stats &&\n                typeof (item.stats as Record<string, unknown>)[statKey] === 'number'\n            ) {\n                max = Math.max(max, (item.stats as Record<string, number>)[statKey]);\n            }\n        }\n        return max;\n    }\n\n    /**\n     * Get active set bonuses for display\n     * @returns {Object[]} Array of { setName, pieceCount, bonuses }\n     */\n    getActiveSetBonuses() {\n        if (!SetBonusesConfig) return [];\n\n        const equippedIds = this.getEquippedIds();\n        const setCounts: Record<string, number> = {};\n        const result = [];\n\n        // Count pieces per set\n        for (const id of equippedIds) {\n            const setId = SetBonusesConfig.findSetForPiece(id);\n            if (setId) {\n                setCounts[setId] = (setCounts[setId] || 0) + 1;\n            }\n        }\n\n        // Build result\n        for (const [setId, count] of Object.entries(setCounts) as [string, number][]) {\n            const set = (\n                SetBonusesConfig.sets as Record<\n                    string,\n                    { name: string; pieces: string[]; bonuses: Record<string, ItemStats> }\n                >\n            )[setId];\n            const activeBonuses: Partial<ItemStats> = {};\n\n            for (const [threshold, stats] of Object.entries(set.bonuses) as [string, ItemStats][]) {\n                if (count >= parseInt(threshold)) {\n                    Object.assign(activeBonuses, stats);\n                }\n            }\n\n            if (Object.keys(activeBonuses).length > 0) {\n                result.push({\n                    setId,\n                    setName: set.name,\n                    pieceCount: count,\n                    totalPieces: set.pieces.length,\n                    bonuses: activeBonuses\n                });\n            }\n        }\n\n        return result;\n    }\n}\n\n// ES6 Module Export\nexport { EquipmentManager };\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\systems\\HeroCombatService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'VFXController' is defined but never used.","line":12,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":23,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"VFXController"},"fix":{"range":[396,447],"text":""},"desc":"Remove unused import declaration."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * HeroCombatService - Handles auto-targeting and attack execution\r\n *\r\n * Extracted from HeroSystem to reduce file size and improve maintainability.\r\n * Owner: HeroCombatService\r\n */\r\n\r\nimport { Logger } from '@core/Logger';\r\nimport { EventBus } from '@core/EventBus';\r\nimport { GameConstants, getConfig } from '@data/GameConstants';\r\nimport { AudioManager } from '../audio/AudioManager';\r\nimport { VFXController } from '@vfx/VFXController';\r\nimport { ProjectileVFX } from '@vfx/ProjectileVFX';\r\nimport { VFXConfig } from '@data/VFXConfig';\r\nimport { Registry } from '@core/Registry';\r\nimport { inputSystem } from '../input/InputSystem';\r\nimport { EntityTypes } from '@config/EntityTypes';\r\nimport { getWeaponStats } from '@data/GameConfig';\r\nimport { MathUtils } from '@core/MathUtils';\r\nimport { findTarget as findTargetFn } from './HeroCombatTargeting';\r\n\r\n// Unmapped modules - need manual import\r\nimport type { Hero } from '../gameplay/Hero';\r\nimport type { IEntity } from '../types/core';\r\nimport type { Game } from '@core/Game';\r\n\r\nconst HeroCombatService = {\r\n    game: null as Game | null,\r\n\r\n    /**\r\n     * Initialize service with game reference\r\n     * @param {Game} game\r\n     */\r\n    init(game: Game) {\r\n        this.game = game;\r\n    },\r\n\r\n    /**\r\n     * Update combat logic: auto-targeting and attack execution\r\n     * @param {number} dt - Delta time in ms\r\n     */\r\n    update(dt: number) {\r\n        const hero = this.game?.hero as Hero | null;\r\n        if (!hero) return;\r\n        // Update attack timer\r\n        if (hero.attackTimer > 0) {\r\n            hero.attackTimer -= dt / 1000;\r\n        }\r\n\r\n        if (hero.components.combat) {\r\n            const c = hero.components.combat;\r\n            if (c.cooldownTimer > 0) {\r\n                c.cooldownTimer -= dt / 1000;\r\n                if (c.cooldownTimer <= 0) {\r\n                    c.cooldownTimer = 0;\r\n                    c.canAttack = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        const target = findTargetFn(hero);\r\n\r\n        // Auto-Attack\r\n        if (target) {\r\n            this.tryAttack(hero, target);\r\n        } else {\r\n            // Only reset attack state after animation completes\r\n            if (hero.attackTimer <= 0) {\r\n                hero.isAttacking = false;\r\n                hero.targetResource = null;\r\n            }\r\n        }\r\n\r\n        // Manual Interaction check (future expansion)\r\n        if (\r\n            inputSystem &&\r\n            typeof inputSystem.hasIntent === 'function' &&\r\n            inputSystem.hasIntent('INTERACT')\r\n        ) {\r\n            // Placeholder for interaction intent handling\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Play muzzle flash for a specific weapon slot\r\n     * Each weapon only attacks if target is within its range\r\n     * @param {Hero} hero\r\n     * @param {IEntity} target\r\n     * @returns {boolean} Whether the target was killed\r\n     */\r\n    tryAttack(hero: Hero, target: IEntity) {\r\n        if (!target || !target.active) return false;\r\n\r\n        // Determine target type\r\n        const isEnemy =\r\n            target.constructor.name === 'Enemy' ||\r\n            target.constructor.name === 'Boss' ||\r\n            (target as unknown as { isBoss: boolean }).isBoss === true;\r\n        const isDino =\r\n            target.constructor.name === 'Dinosaur' || target.entityType === EntityTypes?.DINOSAUR;\r\n        const isRangedTarget = isDino || isEnemy;\r\n\r\n        // Skip if resource is depleted (but not for enemies/dinos)\r\n        if (!isRangedTarget && (target as unknown as { state: string }).state === 'depleted') return false;\r\n        // Skip if enemy is dead\r\n        if (isEnemy && (target as unknown as { isDead: boolean }).isDead) return false;\r\n\r\n        // Calculate distance to target\r\n        const dist = MathUtils.distance(hero.x, hero.y, target.x, target.y);\r\n\r\n        // Get equipped weapons from the active weapon set\r\n        const activeWeapons = hero.equipment?.getActiveWeapons?.() || {};\r\n        const hand1Item = activeWeapons.mainHand;\r\n        const hand2Item = activeWeapons.offHand;\r\n        const activeSlots = hero.equipment?.getActiveWeaponSlots?.() || {\r\n            mainHand: 'hand1',\r\n            offHand: 'hand2'\r\n        };\r\n\r\n        // Use getWeaponStats for consistent range (base + bonus)\r\n        const hand1Range = hand1Item ? getWeaponStats(hand1Item).range : 80;\r\n        const hand2Range = hand2Item ? getWeaponStats(hand2Item).range : 80;\r\n\r\n        // For non-combat (mining), use mining range\r\n        if (!isRangedTarget) {\r\n            const miningRange = hero.miningRange || getConfig().Combat.DEFAULT_MINING_RANGE;\r\n            if (dist > miningRange) return false;\r\n        }\r\n\r\n        // Determine which weapons can attack based on range\r\n        const hand1InRange = isRangedTarget && !!hand1Item && dist <= hand1Range;\r\n        const hand2InRange = isRangedTarget && !!hand2Item && dist <= hand2Range;\r\n\r\n        // For ranged targets, at least one weapon must be in range\r\n        if (isRangedTarget && !hand1InRange && !hand2InRange) return false;\r\n\r\n        // Update Hero State for Renderer - per-weapon attack state\r\n        hero.targetResource = target;\r\n        hero.isAttacking = true;\r\n        hero.hand1Attacking = hand1InRange;\r\n        hero.hand2Attacking = hand2InRange;\r\n\r\n        const combat = hero.components.combat;\r\n        if (combat) {\r\n            if (!combat.canAttack) return false;\r\n            if (combat.staminaCost > 0 && hero.stamina !== undefined) {\r\n                if (hero.stamina < combat.staminaCost) return false;\r\n                hero.stamina -= combat.staminaCost;\r\n                if (EventBus) {\r\n                    EventBus.emit(GameConstants.Events.HERO_STAMINA_CHANGE, {\r\n                        current: hero.stamina,\r\n                        max: hero.maxStamina\r\n                    });\r\n                }\r\n            }\r\n            combat.cooldownTimer = 1 / combat.rate;\r\n            combat.canAttack = false;\r\n            hero.attackTimer = 1 / combat.rate;\r\n        } else {\r\n            if (hero.attackTimer > 0) return false;\r\n            hero.attackTimer = GameConstants.Combat.ATTACK_COOLDOWN;\r\n        }\r\n\r\n        // Calculate total damage from weapons in range\r\n        let totalDmg = 0;\r\n\r\n        // Hand1 Attack\r\n        if (hand1InRange && hand1Item) {\r\n            const weaponStats = getWeaponStats(hand1Item);\r\n            const weaponDmg = weaponStats.damage;\r\n            totalDmg += weaponDmg;\r\n\r\n            // VFX: Per-weapon muzzle flash\r\n            if (hand1Item.weaponType === 'ranged') {\r\n                this.playMuzzleFlashForSlot(hero, target, activeSlots.mainHand);\r\n            }\r\n\r\n            // SFX based on weapon type\r\n            if (AudioManager) {\r\n                AudioManager.playSFX(\r\n                    hand1Item.weaponType === 'ranged' ? 'sfx_hero_shoot' : 'sfx_hero_swing'\r\n                );\r\n            }\r\n        }\r\n\r\n        // Hand2 Attack\r\n        if (hand2InRange && hand2Item) {\r\n            const weaponStats = getWeaponStats(hand2Item);\r\n            const weaponDmg = weaponStats.damage;\r\n            totalDmg += weaponDmg;\r\n\r\n            // VFX: Per-weapon muzzle flash\r\n            if (hand2Item.weaponType === 'ranged') {\r\n                this.playMuzzleFlashForSlot(hero, target, activeSlots.offHand);\r\n            }\r\n\r\n            // SFX based on weapon type (only if different from hand1)\r\n            if (AudioManager && !hand1InRange) {\r\n                AudioManager.playSFX(\r\n                    hand2Item.weaponType === 'ranged' ? 'sfx_hero_shoot' : 'sfx_hero_swing'\r\n                );\r\n            }\r\n        }\r\n\r\n        // Fallback for non-ranged targets (mining)\r\n        if (!isRangedTarget) {\r\n            totalDmg = combat ? combat.damage : getConfig().Combat.DEFAULT_DAMAGE;\r\n            if (AudioManager) {\r\n                AudioManager.playSFX('sfx_hero_swing');\r\n            }\r\n        }\r\n\r\n        // Legacy muzzle flash for ranged targets if neither weapon has ranged type\r\n        if (isRangedTarget && !hand1InRange && !hand2InRange) {\r\n            this.playMuzzleFlash(hero, target, isRangedTarget);\r\n        }\r\n\r\n        Logger.info(\r\n            `[HeroCombatService] Attacking ${target.constructor.name}, damage: ${totalDmg} (H1:${hand1InRange}, H2:${hand2InRange})`\r\n        );\r\n\r\n        // Damage Logic\r\n        // Damage Logic - Delegated to DamageSystem\r\n        if (EventBus) {\r\n            EventBus.emit(GameConstants.Events.ENTITY_DAMAGED, {\r\n                entity: target,\r\n                amount: totalDmg, // Use totalDmg\r\n                source: hero,\r\n                type: 'physical'\r\n            });\r\n        }\r\n\r\n        const justKilled = false; // DamageSystem handles death, this is just for local return if needed\r\n        // We assume false for now as death is async event\r\n\r\n        // Spawn damage popup via EventBus; FloatingTextManager subscribes\r\n        if (EventBus && totalDmg > 0) {\r\n            EventBus.emit(GameConstants.Events.DAMAGE_NUMBER_REQUESTED, {\r\n                x: target.x,\r\n                y: target.y,\r\n                amount: totalDmg,\r\n                isCrit: false\r\n            });\r\n        }\r\n\r\n        return justKilled;\r\n    },\r\n\r\n    /**\r\n     * Play muzzle flash for a specific weapon slot\r\n     * @param {Hero} hero\r\n     * @param {IEntity} target\r\n     * @param {string} slotId - 'hand1' or 'hand2'\r\n     */\r\n    playMuzzleFlashForSlot(hero: Hero, target: IEntity, slotId: string) {\r\n        if (!ProjectileVFX) return;\r\n\r\n        const item = hero.equipment?.getSlot?.(slotId);\r\n        const weaponType = item?.weaponSubtype || 'pistol';\r\n\r\n        ProjectileVFX.spawn({ x: hero.x, y: hero.y }, { x: target.x, y: target.y }, weaponType);\r\n    },\r\n\r\n    /**\r\n     * Play muzzle flash and projectile VFX when attacking ranged targets\r\n     * @param {Hero} hero\r\n     * @param {IEntity} target\r\n     * @param {boolean} isRangedTarget\r\n     */\r\n    playMuzzleFlash(hero: Hero, target: IEntity, isRangedTarget: boolean) {\r\n        if (!isRangedTarget) return;\r\n\r\n        // Use new ProjectileVFX system\r\n        if (ProjectileVFX) {\r\n            const weaponType = ProjectileVFX.getWeaponType(hero);\r\n            ProjectileVFX.spawn({ x: hero.x, y: hero.y }, { x: target.x, y: target.y }, weaponType);\r\n            return;\r\n        }\r\n\r\n        if (!VFXConfig) return;\r\n        const cfg = VFXConfig.HERO.MUZZLE_FLASH;\r\n        const dx = target.x - hero.x;\r\n        const dy = target.y - hero.y;\r\n        const angle = Math.atan2(dy, dx);\r\n        const tipX = hero.x + Math.cos(angle) * cfg.DISTANCE;\r\n        const tipY = hero.y + Math.sin(angle) * cfg.DISTANCE;\r\n        if (VFXConfig.TEMPLATES.MUZZLE_FLASH_FX && EventBus) {\r\n            const fx = { ...VFXConfig.TEMPLATES.MUZZLE_FLASH_FX, angle, spread: 1.0 };\r\n            EventBus.emit(GameConstants.Events.VFX_PLAY_FOREGROUND, { x: tipX, y: tipY, options: fx });\r\n        }\r\n    }\r\n};\r\n\r\n// Export\r\nif (Registry) Registry.register('HeroCombatService', HeroCombatService);\r\n\r\nexport { HeroCombatService };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\systems\\HeroCombatTargeting.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\systems\\HeroSystem.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getConfig' is defined but never used.","line":9,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":34,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"getConfig"},"fix":{"range":[242,253],"text":""},"desc":"Remove unused variable \"getConfig\"."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * HeroSystem\r\n * Handles Input, Physics, and logic for the Hero entity.\r\n * Decoupled from the Hero class data container.\r\n */\r\n\r\nimport { Logger } from '@core/Logger';\r\nimport { EventBus } from '@core/EventBus';\r\nimport { GameConstants, getConfig } from '@data/GameConstants';\r\n// import { VFXController } from '@vfx/VFXController';\r\n// import { VFXConfig } from '@data/VFXConfig';\r\nimport { WorldManager } from '../world/WorldManager';\r\nimport { GameRenderer } from '@core/GameRenderer';\r\nimport { HomeBase } from '../world/HomeBase';\r\nimport { BiomeManager } from '../world/BiomeManager';\r\nimport { Registry } from '@core/Registry';\r\nimport { HeroCombatService } from './HeroCombatService';\r\nimport { MathUtils } from '@core/MathUtils';\r\nimport type { IGame, IEntity } from '../types/core.d';\r\nimport type { ParticleOptions } from '../types/vfx';\r\nimport type { Hero } from '../gameplay/Hero';\r\n\r\nclass HeroSystem {\r\n    // Property declarations\r\n    game: IGame | null = null;\r\n    hero: Hero | null = null;\r\n    inputMove: { x: number; y: number } = { x: 0, y: 0 };\r\n    isAttacking: boolean = false;\r\n    lastHomeState: boolean = false;\r\n    _dustConfig: ParticleOptions;\r\n    _islandManager: typeof WorldManager | null = null;\r\n    _homeBase: typeof HomeBase | null = null;\r\n    _gameRenderer: typeof GameRenderer | null = null;\r\n    // _vfxController: any; // Moved to HeroVisualsSystem\r\n    _lastStaminaEmit: number = 0;\r\n\r\n    constructor() {\r\n        // GC Optimization: Reusable config object for heavy VFX loops\r\n        // _dustConfig moved to HeroVisualsSystem\r\n\r\n        this.initListeners();\r\n        Logger.info('[HeroSystem] Initialized');\r\n    }\r\n\r\n    init(game: IGame) {\r\n        this.game = game;\r\n        // Assume single hero for now, but design allows for multiple\r\n        this.hero = game.hero as Hero;\r\n\r\n        // GC Optimization: Cache system references via Registry (Service Locator)\r\n        this._islandManager = Registry.get<typeof WorldManager>('WorldManager');\r\n        this._homeBase = Registry.get<typeof HomeBase>('HomeBase');\r\n        this._gameRenderer = Registry.get<typeof GameRenderer>('GameRenderer');\r\n        // this._vfxController = Registry.get('VFXController');\r\n    }\r\n\r\n    initListeners() {\r\n        if (EventBus) {\r\n            EventBus.on(GameConstants.Events.INPUT_MOVE, (vec: { x: number; y: number }) => {\r\n                this.inputMove = vec;\r\n            });\r\n            // Attack events could be handled here too\r\n\r\n            // Death handler (06-damage-system)\r\n            EventBus.on(GameConstants.Events.HERO_DIED, (data: { hero: IEntity }) =>\r\n                this.onHeroDied({ hero: data.hero as Hero })\r\n            );\r\n            EventBus.on(GameConstants.Events.REQUEST_STAMINA_RESTORE, (data: { hero: Hero; amount: number }) => {\r\n                if (data?.hero && typeof data.amount === 'number') this.restoreStamina(data.hero, data.amount);\r\n            });\r\n        }\r\n    }\r\n\r\n    update(dt: number) {\r\n        if (!this.hero) {\r\n            // Try to find hero if not yet linked\r\n            if (this.game && this.game.hero) {\r\n                this.hero = this.game.hero as Hero;\r\n            } else {\r\n                return;\r\n            }\r\n        }\r\n\r\n        const hero = this.hero;\r\n        if (hero.locked) return;\r\n\r\n        // 1. Movement Logic\r\n        this.updateMovement(dt, hero);\r\n\r\n        // 2. Combat/Interaction Logic\r\n        this.updateCombat(dt, hero);\r\n\r\n        // 3. VFX (Dust) - Moved to HeroVisualsSystem\r\n        // this.updateVFX(dt, hero);\r\n\r\n        // 4. Events (State & Stats)\r\n        this.handleEvents(hero);\r\n    }\r\n\r\n    handleEvents(hero: Hero) {\r\n        // Home State Change\r\n        if (hero.isAtHomeOutpost !== this.lastHomeState) {\r\n            this.lastHomeState = hero.isAtHomeOutpost;\r\n            if (EventBus)\r\n                EventBus.emit(GameConstants.Events.HERO_HOME_STATE_CHANGE, {\r\n                    isHome: hero.isAtHomeOutpost\r\n                });\r\n        }\r\n\r\n        // Stats Emission - Throttle to every 100ms (6 events/sec instead of 60)\r\n        if (EventBus) {\r\n            const now = performance.now();\r\n            if (!this._lastStaminaEmit || now - this._lastStaminaEmit > GameConstants.Hero.STAMINA_EMIT_THROTTLE) {\r\n                this._lastStaminaEmit = now;\r\n                EventBus.emit(GameConstants.Events.HERO_STAMINA_CHANGE, {\r\n                    current: hero.stamina,\r\n                    max: hero.maxStamina\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    // --- Stamina Management (Moved from StatsComponent) ---\r\n    consumeStamina(hero: Hero, amount: number) {\r\n        if (!hero.components.stats) return false;\r\n\r\n        const stats = hero.components.stats;\r\n        if (stats.stamina >= amount) {\r\n            stats.stamina -= amount;\r\n            if (EventBus) {\r\n                EventBus.emit(GameConstants.Events.HERO_STAMINA_CHANGE, {\r\n                    current: stats.stamina,\r\n                    max: stats.maxStamina\r\n                });\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    restoreStamina(hero: Hero, amount: number) {\r\n        if (!hero.components.stats) return;\r\n\r\n        const stats = hero.components.stats;\r\n        stats.stamina = Math.min(stats.stamina + amount, stats.maxStamina);\r\n\r\n        if (EventBus) {\r\n            EventBus.emit(GameConstants.Events.HERO_STAMINA_CHANGE, {\r\n                current: stats.stamina,\r\n                max: stats.maxStamina\r\n            });\r\n        }\r\n    }\r\n\r\n    // Death/Respawn Handler (06-damage-system)\r\n    onHeroDied(data: { hero: Hero }) {\r\n        const hero = data.hero;\r\n        if (!hero) return;\r\n\r\n        // Lock movement\r\n        hero.locked = true;\r\n\r\n        // Death VFX - Moved to HeroVisualsSystem\r\n\r\n        // Respawn after delay\r\n        setTimeout(() => {\r\n            // Get spawn position\r\n            const spawnPos = this._islandManager?.getHeroSpawnPosition?.() || {\r\n                x: hero.x,\r\n                y: hero.y\r\n            };\r\n            hero.x = spawnPos.x;\r\n            hero.y = spawnPos.y;\r\n\r\n            if (hero.components.health) {\r\n                const h = hero.components.health;\r\n                h.isDead = false;\r\n                h.health = h.getMaxHealth();\r\n                if (EventBus) {\r\n                    EventBus.emit(GameConstants.Events.HERO_HEALTH_CHANGE, { current: h.health, max: h.getMaxHealth() });\r\n                }\r\n            }\r\n            hero.locked = false;\r\n\r\n            if (EventBus && GameConstants) {\r\n                EventBus.emit(GameConstants.Events.HERO_RESPAWNED, { hero });\r\n            }\r\n\r\n            Logger.info('[HeroSystem] Hero respawned at', spawnPos);\r\n        }, GameConstants.Hero.RESPAWN_DELAY_MS);\r\n    }\r\n\r\n    updateMovement(dt: number, hero: Hero) {\r\n        // if (!InputManager) return;\r\n        const move = this.inputMove;\r\n        hero.inputMove = move; // Sync for Renderer\r\n        const dtSec = dt / 1000;\r\n\r\n        // Save previous position for collision/VFX interpolated rendering\r\n        // PrevX/Y must be updated once per logic tick\r\n        hero.prevX = hero.x;\r\n        hero.prevY = hero.y;\r\n\r\n        // Calculate velocity\r\n        const speedMultiplier = BiomeManager?.getSpeedMultiplier?.(hero.x, hero.y) || 1.0;\r\n        const effectiveSpeed = hero.speed * speedMultiplier;\r\n        let dx = move.x * effectiveSpeed * dtSec;\r\n        let dy = move.y * effectiveSpeed * dtSec;\r\n\r\n        // HomeBase Special Check (Legacy tree collision until fully migrated)\r\n        const homeBase = this._homeBase;\r\n        if (homeBase) {\r\n            if (dx !== 0 && homeBase.isBlockedByTrees(hero.x + dx, hero.y)) dx = 0;\r\n            if (dy !== 0 && homeBase.isBlockedByTrees(hero.x, hero.y + dy)) dy = 0;\r\n        }\r\n\r\n        if (EventBus) {\r\n            EventBus.emit(GameConstants.Events.ENTITY_MOVE_REQUEST, { entity: hero, dx, dy });\r\n        } else {\r\n            hero.x += dx;\r\n            hero.y += dy;\r\n            if (this._islandManager?.isBlocked(hero.x, hero.y)) {\r\n                hero.x = hero.prevX;\r\n                hero.y = hero.prevY;\r\n            }\r\n        }\r\n\r\n        // World Bounds Check\r\n        const gameRenderer = this._gameRenderer;\r\n        if (gameRenderer) {\r\n            const halfW = hero.width / 2;\r\n            const halfH = hero.height / 2;\r\n            hero.x = MathUtils.clamp(hero.x, halfW, gameRenderer.worldWidth - halfW);\r\n            hero.y = MathUtils.clamp(hero.y, halfH, gameRenderer.worldHeight - halfH);\r\n        }\r\n    }\r\n\r\n    updateCombat(_dt: number, _hero: Hero) {\r\n        // Combat logic delegated to HeroCombatService (registered in SystemConfig)\r\n        // HeroCombatService now fetches hero from this.game.hero and has its own update cycle.\r\n    }\r\n\r\n    // updateVFX moved to HeroVisualsSystem\r\n\r\n    // --- Public Actions (Callable by Game/Input) ---\r\n\r\n    /**\r\n     * Attack a target - delegated to HeroCombatService\r\n     * Kept for backward compatibility with external callers\r\n     */\r\n    tryAttack(hero: Hero, target: IEntity) {\r\n        if (HeroCombatService) {\r\n            return HeroCombatService.tryAttack(hero, target);\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\n// Create singleton and export\r\nconst heroSystem = new HeroSystem();\r\nif (Registry) Registry.register('HeroSystem', heroSystem);\r\n\r\nexport { HeroSystem, heroSystem };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\systems\\HeroVisualsSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\systems\\InteractionSystem.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getConfig' is defined but never used.","line":9,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":34,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"getConfig"},"fix":{"range":[248,259],"text":""},"desc":"Remove unused variable \"getConfig\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'WorldManager' is defined but never used.","line":11,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":22,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"WorldManager"},"fix":{"range":[345,398],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'dt' is defined but never used. Allowed unused args must match /^_/u.","line":40,"column":12,"nodeType":"Identifier","messageId":"unusedVar","endLine":40,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'hero' is defined but never used. Allowed unused args must match /^_/u.","line":68,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":68,"endColumn":31}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * InteractionSystem\r\n * Handles entity interactions, specifically item pickups and magnetism.\r\n * Decouples logic from Game.js.\r\n */\r\n\r\nimport { Logger } from '@core/Logger';\r\nimport { EventBus } from '@core/EventBus';\r\nimport { GameConstants, getConfig } from '@data/GameConstants';\r\nimport { entityManager } from '@core/EntityManager';\r\nimport { WorldManager } from '../world/WorldManager';\r\nimport { DroppedItem } from '../gameplay/DroppedItem';\r\nimport { AudioManager } from '../audio/AudioManager';\r\nimport { QuestManager } from '../gameplay/QuestManager';\r\nimport { VFXTriggerService } from './VFXTriggerService';\r\nimport { Registry } from '@core/Registry';\r\n\r\nimport type { IGame, IEntity } from '../types/core.d';\r\n\r\nclass InteractionSystem {\r\n    game: IGame | null = null;\r\n    magnetActiveCount: number = 0;\r\n\r\n    constructor() {\r\n        Logger.info('[InteractionSystem] Constructed');\r\n    }\r\n\r\n    init(game: IGame) {\r\n        this.game = game;\r\n        this.initListeners();\r\n        Logger.info('[InteractionSystem] Initialized');\r\n    }\r\n\r\n    initListeners() {\r\n        if (EventBus) {\r\n            EventBus.on(GameConstants.Events.REQUEST_MAGNET, () => this.triggerMagnet());\r\n        }\r\n    }\r\n\r\n    update(dt: number) {\r\n        if (!entityManager || !this.game.hero) return;\r\n\r\n        const hero = this.game.hero;\r\n        const items = entityManager.getByType('DroppedItem');\r\n\r\n        for (const item of items) {\r\n            if (!item.active) continue;\r\n\r\n            // 1. Magnet Logic Check (Auto-magnetize if close enough even without global trigger)\r\n            if (item.shouldAutoMagnetize(hero)) {\r\n                item.magnetize(hero);\r\n            }\r\n\r\n            // 2. Pickup Logic\r\n            if (item.canBePickedUpBy(hero)) {\r\n                this.collectItem(hero, item);\r\n            }\r\n        }\r\n\r\n        // 3. Spatial Triggers (UI Prompts)\r\n        this.updateSpatialTriggers(hero);\r\n    }\r\n\r\n    /**\r\n     * Check for spatial triggers (Merchant, Bridge)\r\n     * Replaces Game.updateUITriggers\r\n     */\r\n    updateSpatialTriggers(hero: IEntity) {\r\n        // Merchant Button (merchants removed; placeholder for future map-placed merchants)\r\n        if (EventBus) {\r\n            EventBus.emit(GameConstants.Events.INTERACTION_OPPORTUNITY, {\r\n                type: 'merchant',\r\n                target: null,\r\n                visible: false\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle item collection\r\n     */\r\n    collectItem(hero: IEntity, item: IEntity) {\r\n        // Hero logic (add to inventory)\r\n        // Hero logic (add to inventory)\r\n        const type = item.resourceType;\r\n        const amount = (item as DroppedItem).amount || 1;\r\n\r\n        // SFX - play for EVERY item pickup (no debounce)\r\n        if (AudioManager) {\r\n            AudioManager.playSFX('sfx_resource_collect');\r\n        }\r\n\r\n        // Add to Inventory\r\n        if (hero.components.inventory) {\r\n            hero.components.inventory.add(type, amount);\r\n        }\r\n\r\n        // Quest Update\r\n        if (QuestManager) QuestManager.onCollect(type, amount);\r\n\r\n        // Check magnet completion logic\r\n        if (item.isMagnetized && this.magnetActiveCount > 0) {\r\n            this.magnetActiveCount--;\r\n            if (this.magnetActiveCount <= 0) {\r\n                this.magnetActiveCount = 0;\r\n                this.triggerMagnetCompletionVFX(hero);\r\n            }\r\n        }\r\n\r\n        // Deactivate\r\n        item.active = false;\r\n        if (entityManager) entityManager.remove(item);\r\n\r\n        // Events & Feedback\r\n        if (EventBus) {\r\n            EventBus.emit(GameConstants.Events.INVENTORY_UPDATED, hero.components.inventory);\r\n        }\r\n\r\n        // SFX is handled by Hero.collect or specific item logic usually,\r\n        // but if not, we can do it here. Hero.collect() usually plays 'sfx_pickup'.\r\n    }\r\n\r\n    /**\r\n     * Trigger global magnet effect\r\n     */\r\n    triggerMagnet() {\r\n        if (!this.game.hero || !entityManager) return;\r\n\r\n        // Check cooldown or resource cost if applicable (currently free/event based)\r\n\r\n        let count = 0;\r\n        const items = entityManager.getByType('DroppedItem');\r\n        for (const item of items) {\r\n            if (item.active && !item.isMagnetized) {\r\n                item.magnetize(this.game.hero);\r\n                count++;\r\n            }\r\n        }\r\n\r\n        if (count > 0) {\r\n            this.magnetActiveCount = count;\r\n            Logger.info(`[InteractionSystem] Magnet triggered for ${count} items`);\r\n            if (AudioManager) AudioManager.playSFX('sfx_ui_magnet');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Trigger \"Singularity\" VFX when all magnetized items arrive\r\n     */\r\n    triggerMagnetCompletionVFX(hero: IEntity) {\r\n        if (VFXTriggerService) {\r\n            VFXTriggerService.triggerMagnetCompletionVFX(hero);\r\n        }\r\n    }\r\n}\r\n\r\n// Create singleton and export\r\nconst interactionSystem = new InteractionSystem();\r\nif (Registry) Registry.register('InteractionSystem', interactionSystem);\r\n\r\nexport { InteractionSystem, interactionSystem };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\systems\\PathfindingSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\systems\\ResourceSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\systems\\RestSystem.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getConfig' is defined but never used.","line":14,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":34,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"getConfig"},"fix":{"range":[389,400],"text":""},"desc":"Remove unused variable \"getConfig\"."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * RestSystem\r\n * Handles the \"Rest\" mechanic at the Home Outpost.\r\n * Logic:\r\n * 1. Checks if player is at Home Outpost.\r\n * 2. Replenishes Health/Stamina.\r\n * 3. Triggers Cinematic Fade.\r\n * 4. Advances Time (Day/Night cycle) - Placeholder for now.\r\n * 5. Saves Game.\r\n */\r\n\r\nimport { Logger } from '@core/Logger';\r\nimport { EventBus } from '@core/EventBus';\r\nimport { GameConstants, getConfig } from '@data/GameConstants';\r\nimport { AudioManager } from '../audio/AudioManager';\r\nimport { VFXController } from '@vfx/VFXController';\r\nimport { GameState } from '@core/State';\r\nimport { Registry } from '@core/Registry';\r\n\r\nimport type { IGame } from '../types/core.d';\r\nimport type { Hero } from '../gameplay/Hero';\r\n\r\nclass RestSystem {\r\n    game: IGame | null = null;\r\n\r\n    constructor() {\r\n        Logger.info('[RestSystem] Constructed');\r\n    }\r\n\r\n    init(game: IGame) {\r\n        this.game = game;\r\n        this.initListeners();\r\n        Logger.info('[RestSystem] Initialized');\r\n    }\r\n\r\n    initListeners() {\r\n        if (EventBus) {\r\n            EventBus.on(GameConstants.Events.REQUEST_REST, () => this.handleRest());\r\n        }\r\n    }\r\n\r\n    handleRest() {\r\n        if (!this.game || !this.game.hero) return;\r\n        const hero = this.game.hero as Hero;\r\n\r\n        // Validation (Double check location)\r\n        if (!hero.isAtHomeOutpost) {\r\n            Logger.warn('[RestSystem] Cannot rest outside home outpost', {\r\n                x: hero.x,\r\n                y: hero.y,\r\n                isAtHome: hero.isAtHomeOutpost\r\n            });\r\n            return;\r\n        }\r\n\r\n        Logger.info('[RestSystem] Resting...');\r\n\r\n        // 1. Play Rest Melody SFX\r\n        if (AudioManager) AudioManager.playSFX('sfx_rest_melody');\r\n\r\n        // 2. Trigger Cinematic Fade via UIManager\r\n        if (EventBus) {\r\n            EventBus.emit(GameConstants.Events.UI_FADE_SCREEN, {\r\n                onMidpoint: () => this.performRestLogic(hero)\r\n            });\r\n        } else {\r\n            // Fallback (Instant)\r\n            this.performRestLogic(hero);\r\n        }\r\n    }\r\n\r\n    performRestLogic(hero: Hero) {\r\n        Logger.info('[RestSystem] Performing rest logic (Restore stats)...');\r\n\r\n        // Feature: Resilience Bonus\r\n        // If resting with 0 Resolve (Stamina), gain permanent +1 Max Resolve\r\n        if (hero.stamina <= 0.1) {\r\n            // 0.1 epsilon for float safety\r\n            hero.maxStamina += 1;\r\n            Logger.info(\r\n                `[RestSystem] Resilience Bonus! Max Stamina increased to ${hero.maxStamina}`\r\n            );\r\n\r\n            // Visual feedback for bonus?\r\n            if (VFXController && hero) {\r\n                // Use spawnFloatingText if available\r\n                if (typeof VFXController.spawnFloatingText === 'function') {\r\n                    const T = GameConstants.Timing;\r\n                    VFXController.spawnFloatingText(\r\n                        '+1 MAX RES',\r\n                        hero.x,\r\n                        hero.y - T.FLOATING_TEXT_Y_OFFSET,\r\n                        '#FFD700',\r\n                        T.FLOATING_TEXT_DURATION\r\n                    );\r\n                }\r\n            }\r\n        } else {\r\n            // Advisory Hint\r\n            if (VFXController && typeof VFXController.spawnFloatingText === 'function') {\r\n                const T = GameConstants.Timing;\r\n                VFXController.spawnFloatingText(\r\n                    'Hint: Rest at 0 Resolve for Bonus!',\r\n                    hero.x,\r\n                    hero.y - T.FLOATING_TEXT_Y_OFFSET,\r\n                    '#CCCCCC',\r\n                    T.FLOATING_TEXT_DURATION\r\n                );\r\n            }\r\n        }\r\n\r\n        // Recover Stats\r\n        hero.health = hero.maxHealth;\r\n        hero.stamina = hero.maxStamina;\r\n\r\n        // Save Game\r\n        if (GameState) {\r\n            // GameState might auto-save on set, but we can force explicit save if needed\r\n            // For now, just updating gold/inventory in GameState is handled elsewhere\r\n            Logger.info('[RestSystem] Game Saved (Simulated)');\r\n        }\r\n\r\n        // Respawn Resources?\r\n        // In the future, this advances the \"Day\" and respawns resources logic in ResourceSystem/SpawnManager\r\n\r\n        // Feedback\r\n        Logger.info('[RestSystem] Rest Complete. HP/Stamina Restored.');\r\n\r\n        // Emit events for UI updates\r\n        if (EventBus) {\r\n            EventBus.emit(GameConstants.Events.HERO_HEALTH_CHANGE, {\r\n                current: hero.health,\r\n                max: hero.maxHealth\r\n            });\r\n            EventBus.emit(GameConstants.Events.HERO_STAMINA_CHANGE, {\r\n                current: hero.stamina,\r\n                max: hero.maxStamina\r\n            });\r\n            // EventBus.emit('GAME_SAVED');\r\n        }\r\n    }\r\n}\r\n\r\n// Create singleton and export\r\nconst restSystem = new RestSystem();\r\nif (Registry) Registry.register('RestSystem', restSystem);\r\n\r\nexport { RestSystem, restSystem };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\systems\\TimeSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\systems\\VFXTriggerService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\systems\\WeatherSystem.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'force' is assigned a value but never used. Allowed unused args must match /^_/u.","line":89,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":89,"endColumn":27}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * WeatherSystem\r\n * Manages weather states based on the current season and RNG.\r\n *\r\n * Responsibilities:\r\n * - Listens for Season changes to update weather probabilities\r\n * - Periodically rolls for weather changes\r\n * - Emits WEATHER_CHANGE events\r\n */\r\n\r\nimport { Logger } from '@core/Logger';\r\nimport { EventBus } from '@core/EventBus';\r\nimport { GameConstants, getConfig } from '@data/GameConstants';\r\nimport { Registry } from '@core/Registry';\r\nimport type { IGame } from '../types/core.d';\r\n\r\nclass WeatherSystem {\r\n    // Property declarations\r\n    game: IGame | null = null;\r\n    currentWeather: string = 'CLEAR';\r\n    currentSeason: string = 'SPRING';\r\n    nextChangeCheck: number = 0;\r\n    config: typeof GameConstants.Weather;\r\n    overrideEnabled: boolean = false;\r\n\r\n    constructor() {\r\n        this.config = GameConstants.Weather;\r\n    }\r\n\r\n    init(game: IGame) {\r\n        this.game = game;\r\n\r\n        // Subscribe to events\r\n        EventBus.on(GameConstants.Events.SEASON_CHANGE, this.handleSeasonChange.bind(this));\r\n\r\n        // Initial weather roll\r\n        this.rollWeather();\r\n\r\n        Logger.info('[WeatherSystem] Initialized');\r\n    }\r\n\r\n    /**\r\n     * Set a weather override\r\n     * @param {string|null} type - Weather type or 'auto' to disable\r\n     */\r\n    setWeatherOverride(type: string | null) {\r\n        if (!type || type === 'auto') {\r\n            this.overrideEnabled = false;\r\n            Logger.info('[WeatherSystem] Override Disabled (Auto)');\r\n            // Force a roll to pick new weather naturally\r\n            this.rollWeather();\r\n            return;\r\n        }\r\n\r\n        this.overrideEnabled = true;\r\n        this.setWeather(type);\r\n        Logger.info(`[WeatherSystem] Override Enabled: ${type}`);\r\n    }\r\n\r\n    update(dt: number) {\r\n        // Skip auto changes when override is active\r\n        if (this.overrideEnabled) return;\r\n\r\n        // We use TimeSystem's time, but we can also track our own interval\r\n        // Simple Real-time check is fine\r\n        this.nextChangeCheck -= dt / (getConfig().Time.WEATHER_DECAY_RATE || 5000);\r\n\r\n        if (this.nextChangeCheck <= 0) {\r\n            this.tryChangeWeather();\r\n            this.nextChangeCheck = this.config.CHANGE_INTERVAL;\r\n        }\r\n    }\r\n\r\n    handleSeasonChange(data: { season: string }) {\r\n        this.currentSeason = data.season;\r\n        Logger.info(\r\n            `[WeatherSystem] Season updated to ${this.currentSeason}, rerolling weather...`\r\n        );\r\n        // Force a weather change on season start (if not overridden)\r\n        if (!this.overrideEnabled) {\r\n            this.tryChangeWeather(true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attempt to change weather\r\n     * @param {boolean} force - If true, guarantees a roll happens (though result might be same)\r\n     */\r\n    tryChangeWeather(force = false) {\r\n        // RNG roll could simply be weighted based on season\r\n        this.rollWeather();\r\n    }\r\n\r\n    rollWeather() {\r\n        // Get probabilities for current season\r\n        const probs = this.config.PROBABILITIES[this.currentSeason as keyof typeof this.config.PROBABILITIES];\r\n        if (!probs) return;\r\n\r\n        const roll = Math.random();\r\n        let cumulative = 0;\r\n        let selectedWeather = 'CLEAR'; // Default\r\n\r\n        for (const [type, chance] of Object.entries(probs) as [string, number][]) {\r\n            cumulative += chance;\r\n            if (roll <= cumulative) {\r\n                selectedWeather = type;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (selectedWeather !== this.currentWeather) {\r\n            this.setWeather(selectedWeather);\r\n        }\r\n    }\r\n\r\n    setWeather(type: string) {\r\n        this.currentWeather = type;\r\n        Logger.info(`[WeatherSystem] Weather Changed to: ${type}`);\r\n\r\n        EventBus.emit(GameConstants.Events.WEATHER_CHANGE, {\r\n            type: type,\r\n            intensity: 1.0 // Future: Variable intensity\r\n        });\r\n    }\r\n}\r\n\r\n// Create singleton and export\r\nconst weatherSystem = new WeatherSystem();\r\n\r\n// Register at module load time (before Game.init looks for it)\r\nRegistry.register('WeatherSystem', weatherSystem);\r\n\r\nexport { WeatherSystem, weatherSystem };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\ChunkManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\ChunkManagerDelegation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\ChunkManagerHeroSpawn.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\ChunkManagerLoader.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\ChunkManagerObjects.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\ChunkManagerSerialization.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\ChunkManagerViewport.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\EditorContext.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ZoneCategory' is defined but never used.","line":1,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":22,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"ZoneCategory"},"fix":{"range":[0,48],"text":""},"desc":"Remove unused import declaration."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ZoneCategory } from '@data/ZoneConfig';\r\n\r\nexport interface RegistryDict {\r\n    [id: string]: { width?: number; height?: number } | undefined;\r\n}\r\n\r\nexport interface EntityRegistry {\r\n    nodes?: RegistryDict;\r\n    enemies?: RegistryDict;\r\n    resources?: RegistryDict;\r\n    items?: RegistryDict;\r\n    environment?: RegistryDict;\r\n}\r\n\r\n/**\r\n * EditorContext\r\n * \r\n * Shared state for Map Editor sub-systems.\r\n * Replaces legacy 'window' global storage.\r\n */\r\nexport const EditorContext = {\r\n    // Entity Data for rendering sizes\r\n    registry: {} as EntityRegistry,\r\n\r\n    // Visibility Filters  tracks HIDDEN zone IDs. Empty = everything visible.\r\n    hiddenZoneIds: new Set<string>()\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\GroundSystem.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'CHUNK_SIZE' is assigned a value but never used.","line":117,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":117,"endColumn":38}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as PIXI from 'pixi.js';\r\nimport { MapEditorConfig } from './MapEditorConfig';\r\nimport { ChunkData } from './MapEditorTypes';\r\nimport { GroundPalette } from '@data/ZonePalette';\r\nimport { ZoneCategory } from '@data/ZoneConfig';\r\nimport { GroundBlendRenderer } from '@core/rendering/GroundBlendRenderer';\r\nimport { applyPaintOps, applyRestoreSplat } from './GroundSystemSplat';\r\nimport { resolvePaletteId } from './GroundSystemPalette';\r\nimport { getAssetData, preloadPaletteAssets, AssetCaches } from './GroundSystemAssets';\r\nimport { computeTileTexture } from './GroundSystemTileTexture';\r\n\r\n/**\r\n * GroundSystem  Ground rendering for map editor chunks.\r\n * Manages tile textures, splat painting, caching, and procedural ground blending.\r\n */\r\nexport class GroundSystem {\r\n    private renderer: GroundBlendRenderer;\r\n    private spriteCache: Map<string, PIXI.Sprite[][]> = new Map();\r\n    private caches: AssetCaches = {\r\n        dataCache: new Map(),\r\n        textureCache: {}\r\n    };\r\n\r\n    constructor() {\r\n        this.renderer = new GroundBlendRenderer();\r\n    }\r\n\r\n    public clearCache() {\r\n        this.spriteCache.clear();\r\n        this.caches.dataCache.clear();\r\n        this.caches.textureCache = {};\r\n    }\r\n\r\n    public async renderChunk(\r\n        chunkContainer: PIXI.Container,\r\n        data: ChunkData,\r\n        chunkX: number,\r\n        chunkY: number,\r\n        worldData?: Map<string, ChunkData>\r\n    ) {\r\n        const chunkKey = data.id;\r\n\r\n        const existing = chunkContainer.getChildByLabel('ground_layer');\r\n        if (existing) existing.destroy({ children: true });\r\n\r\n        const groundLayer = new PIXI.Container();\r\n        groundLayer.label = 'ground_layer';\r\n        groundLayer.zIndex = 0;\r\n        chunkContainer.addChildAt(groundLayer, 0);\r\n\r\n        const { CHUNK_SIZE, SPLAT_RES } = MapEditorConfig;\r\n        const splatData = data.splatMap\r\n            ? new Uint8ClampedArray(data.splatMap)\r\n            : new Uint8ClampedArray(SPLAT_RES * SPLAT_RES);\r\n\r\n        const uniquePaletteIds = new Set<string>();\r\n        for (let ly = 0; ly < CHUNK_SIZE; ly++) {\r\n            for (let lx = 0; lx < CHUNK_SIZE; lx++) {\r\n                const tileKey = `${lx},${ly}`;\r\n                const zoneMap = (data.zones && data.zones[tileKey]) || {};\r\n                const biome = zoneMap[ZoneCategory.BIOME];\r\n                const modifier = zoneMap['terrain'] || zoneMap[ZoneCategory.CIVILIZATION] || null;\r\n                const pid = resolvePaletteId(\r\n                    biome,\r\n                    modifier,\r\n                    worldData ? { chunkKey, lx, ly, data, worldData } : undefined\r\n                );\r\n                if (pid) uniquePaletteIds.add(pid);\r\n            }\r\n        }\r\n\r\n        const preloadedAssets = await preloadPaletteAssets(uniquePaletteIds);\r\n\r\n        for (let ly = 0; ly < CHUNK_SIZE; ly++) {\r\n            for (let lx = 0; lx < CHUNK_SIZE; lx++) {\r\n                const tileKey = `${lx},${ly}`;\r\n                const zoneMap = (data.zones && data.zones[tileKey]) || {};\r\n                const biome = zoneMap[ZoneCategory.BIOME];\r\n                const modifier = zoneMap['terrain'] || zoneMap[ZoneCategory.CIVILIZATION] || null;\r\n                const pid = resolvePaletteId(\r\n                    biome,\r\n                    modifier,\r\n                    worldData ? { chunkKey, lx, ly, data, worldData } : undefined\r\n                );\r\n\r\n                if (pid) {\r\n                    const assets = preloadedAssets.get(pid);\r\n                    if (assets) {\r\n                        await this.updateTile(\r\n                            chunkKey,\r\n                            lx,\r\n                            ly,\r\n                            data,\r\n                            groundLayer,\r\n                            pid,\r\n                            splatData,\r\n                            assets,\r\n                            worldData\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public async updateTile(\r\n        chunkKey: string,\r\n        lx: number,\r\n        ly: number,\r\n        data: ChunkData,\r\n        groundLayer: PIXI.Container,\r\n        resolvedPaletteId: string | null = null,\r\n        splatDataOverride?: Uint8ClampedArray,\r\n        preloadedAssets?: unknown,\r\n        worldData?: Map<string, ChunkData>\r\n    ) {\r\n        const { TILE_SIZE, CHUNK_SIZE, SPLAT_RES } = MapEditorConfig;\r\n\r\n        if (!resolvedPaletteId) {\r\n            const tileKey = `${lx},${ly}`;\r\n            const zoneMap = (data.zones && data.zones[tileKey]) || {};\r\n            const biome = zoneMap[ZoneCategory.BIOME];\r\n            const modifier = zoneMap['terrain'] || zoneMap[ZoneCategory.CIVILIZATION] || null;\r\n            resolvedPaletteId = resolvePaletteId(\r\n                biome,\r\n                modifier,\r\n                worldData ? { chunkKey, lx, ly, data, worldData } : undefined\r\n            );\r\n        }\r\n\r\n        if (!resolvedPaletteId) {\r\n            const sprite = this.getCachedSprite(chunkKey, lx, ly);\r\n            if (sprite) {\r\n                sprite.destroy();\r\n                if (this.spriteCache.has(chunkKey)) {\r\n                    this.spriteCache.get(chunkKey)![lx][ly] = null;\r\n                }\r\n            }\r\n            return;\r\n        }\r\n\r\n        const palette = GroundPalette[resolvedPaletteId] || GroundPalette['default'];\r\n        const splatData =\r\n            splatDataOverride ??\r\n            (data.splatMap\r\n                ? new Uint8ClampedArray(data.splatMap)\r\n                : new Uint8ClampedArray(SPLAT_RES * SPLAT_RES));\r\n\r\n        const loadAsset = (id: string, isHeightMap?: boolean) =>\r\n            getAssetData(id, !!isHeightMap, this.caches);\r\n\r\n        const texture = await computeTileTexture(\r\n            chunkKey,\r\n            lx,\r\n            ly,\r\n            data,\r\n            splatData,\r\n            worldData,\r\n            preloadedAssets as Parameters<typeof computeTileTexture>[6],\r\n            loadAsset,\r\n            palette,\r\n            this.caches.textureCache,\r\n            this.renderer\r\n        );\r\n\r\n        let sprite = this.getCachedSprite(chunkKey, lx, ly);\r\n        if (sprite) {\r\n            if (sprite.texture && (sprite.texture as { _isGenerated?: boolean })._isGenerated) {\r\n                sprite.texture.destroy(true);\r\n            }\r\n            sprite.texture = texture;\r\n        } else {\r\n            sprite = new PIXI.Sprite(texture);\r\n            sprite.x = lx * TILE_SIZE;\r\n            sprite.y = ly * TILE_SIZE;\r\n            sprite.width = TILE_SIZE;\r\n            sprite.height = TILE_SIZE;\r\n            groundLayer.addChild(sprite);\r\n            this.setCachedSprite(chunkKey, lx, ly, sprite);\r\n        }\r\n    }\r\n\r\n    private getCachedSprite(chunkKey: string, lx: number, ly: number): PIXI.Sprite | null {\r\n        if (!this.spriteCache.has(chunkKey)) return null;\r\n        const c = this.spriteCache.get(chunkKey)!;\r\n        if (!c[lx]) return null;\r\n        return c[lx][ly];\r\n    }\r\n\r\n    private setCachedSprite(chunkKey: string, lx: number, ly: number, sprite: PIXI.Sprite) {\r\n        if (!this.spriteCache.has(chunkKey)) {\r\n            const arr = Array(MapEditorConfig.CHUNK_SIZE)\r\n                .fill(null)\r\n                .map(() => Array(MapEditorConfig.CHUNK_SIZE).fill(null));\r\n            this.spriteCache.set(chunkKey, arr);\r\n        }\r\n        this.spriteCache.get(chunkKey)![lx][ly] = sprite;\r\n    }\r\n\r\n    public async paintSplatBatch(\r\n        ops: { x: number; y: number; radius: number; intensity: number }[],\r\n        soft: boolean,\r\n        worldData: Map<string, ChunkData>,\r\n        loadedChunks: Map<string, PIXI.Container>\r\n    ): Promise<{ chunkKey: string; idx: number; oldVal: number; newVal: number }[]> {\r\n        if (ops.length === 0) return [];\r\n        const { changeMap, dirtyTiles } = applyPaintOps(ops, soft, worldData);\r\n        const allChanges = Array.from(changeMap.values());\r\n\r\n        const promises: Promise<void>[] = [];\r\n        for (const [chunkKey, tiles] of dirtyTiles) {\r\n            const chunk = loadedChunks.get(chunkKey);\r\n            if (!chunk) continue;\r\n            let groundLayer = chunk.getChildByLabel('ground_layer') as PIXI.Container;\r\n            if (!groundLayer) {\r\n                groundLayer = new PIXI.Container();\r\n                groundLayer.label = 'ground_layer';\r\n                chunk.addChildAt(groundLayer, 0);\r\n            }\r\n            const data = worldData.get(chunkKey)!;\r\n            for (const tKey of tiles) {\r\n                const [lx, ly] = tKey.split(',').map(Number);\r\n                promises.push(\r\n                    this.updateTile(\r\n                        chunkKey,\r\n                        lx,\r\n                        ly,\r\n                        data,\r\n                        groundLayer,\r\n                        undefined,\r\n                        undefined,\r\n                        undefined,\r\n                        worldData\r\n                    )\r\n                );\r\n            }\r\n        }\r\n        await Promise.all(promises);\r\n        return allChanges;\r\n    }\r\n\r\n    public async paintSplat(\r\n        worldX: number,\r\n        worldY: number,\r\n        radius: number,\r\n        intensity: number,\r\n        soft: boolean,\r\n        worldData: Map<string, ChunkData>,\r\n        loadedChunks: Map<string, PIXI.Container>\r\n    ): Promise<{ chunkKey: string; idx: number; oldVal: number; newVal: number }[]> {\r\n        const { changeMap, dirtyTiles } = applyPaintOps(\r\n            [{ x: worldX, y: worldY, radius, intensity }],\r\n            soft,\r\n            worldData\r\n        );\r\n        const changes = Array.from(changeMap.values());\r\n\r\n        const promises: Promise<void>[] = [];\r\n        for (const [chunkKey, tiles] of dirtyTiles) {\r\n            const chunk = loadedChunks.get(chunkKey);\r\n            if (!chunk) continue;\r\n            let groundLayer = chunk.getChildByLabel('ground_layer') as PIXI.Container;\r\n            if (!groundLayer) {\r\n                groundLayer = new PIXI.Container();\r\n                groundLayer.label = 'ground_layer';\r\n                chunk.addChildAt(groundLayer, 0);\r\n            }\r\n            const data = worldData.get(chunkKey)!;\r\n            for (const tKey of tiles) {\r\n                const [lx, ly] = tKey.split(',').map(Number);\r\n                promises.push(\r\n                    this.updateTile(\r\n                        chunkKey,\r\n                        lx,\r\n                        ly,\r\n                        data,\r\n                        groundLayer,\r\n                        undefined,\r\n                        undefined,\r\n                        undefined,\r\n                        worldData\r\n                    )\r\n                );\r\n            }\r\n        }\r\n        await Promise.all(promises);\r\n        return changes;\r\n    }\r\n\r\n    public async restoreSplatData(\r\n        changesByChunk: Map<string, { idx: number; oldVal: number; newVal: number }[]>,\r\n        undo: boolean,\r\n        worldData: Map<string, ChunkData>,\r\n        loadedChunks: Map<string, PIXI.Container>\r\n    ) {\r\n        const dirtyTiles = applyRestoreSplat(changesByChunk, undo, worldData);\r\n\r\n        const promises: Promise<void>[] = [];\r\n        for (const [chunkKey, tiles] of dirtyTiles) {\r\n            const chunk = loadedChunks.get(chunkKey);\r\n            if (!chunk) continue;\r\n            let groundLayer = chunk.getChildByLabel('ground_layer') as PIXI.Container;\r\n            if (!groundLayer) {\r\n                groundLayer = new PIXI.Container();\r\n                groundLayer.label = 'ground_layer';\r\n                chunk.addChildAt(groundLayer, 0);\r\n            }\r\n            const data = worldData.get(chunkKey)!;\r\n            for (const tKey of tiles) {\r\n                const [lx, ly] = tKey.split(',').map(Number);\r\n                promises.push(\r\n                    this.updateTile(\r\n                        chunkKey,\r\n                        lx,\r\n                        ly,\r\n                        data,\r\n                        groundLayer,\r\n                        undefined,\r\n                        undefined,\r\n                        undefined,\r\n                        worldData\r\n                    )\r\n                );\r\n            }\r\n        }\r\n        await Promise.all(promises);\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\GroundSystemAssets.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\GroundSystemPalette.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ZoneCategory' is defined but never used.","line":6,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":22,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"ZoneCategory"},"fix":{"range":[174,222],"text":""},"desc":"Remove unused import declaration."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * GroundSystemPalette - Palette resolution for ground blending\r\n */\r\nimport { GroundPalette } from '@data/ZonePalette';\r\nimport { ChunkData } from './MapEditorTypes';\r\nimport { ZoneCategory } from '@data/ZoneConfig';\r\n\r\nexport interface ResolvePaletteCtx {\r\n    chunkKey: string;\r\n    lx: number;\r\n    ly: number;\r\n    data: ChunkData;\r\n    worldData: Map<string, ChunkData>;\r\n}\r\n\r\n/**\r\n * Resolves the Palette ID from biome and modifier.\r\n\r\n * Weight alone drives the visual (3-layer blend);\r\n * no neighbor-aware or terrain-specific overrides (terrain_coast, terrain_water, etc.).\r\n */\r\nexport function resolvePaletteId(\r\n    biomeId: string | undefined,\r\n    modifierId: string | null,\r\n    _ctx?: ResolvePaletteCtx\r\n): string | null {\r\n    if (!biomeId) return null;\r\n\r\n    const normalizedBiome = GroundPalette[biomeId]\r\n        ? biomeId\r\n        : biomeId.startsWith('biome_')\r\n          ? biomeId\r\n          : `biome_${biomeId}`;\r\n\r\n    if (!modifierId) return normalizedBiome;\r\n    const compositeId = `${normalizedBiome}_${modifierId}`;\r\n    return GroundPalette[compositeId] ? compositeId : normalizedBiome;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\GroundSystemSplat.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'CHUNK_SIZE' is assigned a value but never used.","line":62,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":62,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * GroundSystemSplat - Splat weight sampling and paint operations\r\n */\r\nimport * as PIXI from 'pixi.js';\r\nimport { MapEditorConfig } from './MapEditorConfig';\r\nimport { ChunkData } from './MapEditorTypes';\r\n\r\n/** Sample splat weight; reads from neighbor chunk when at boundaries. */\r\nexport function getSplatWeight(\r\n    chunkKey: string,\r\n    sampleX: number,\r\n    sampleY: number,\r\n    data: ChunkData,\r\n    worldData?: Map<string, ChunkData>\r\n): number {\r\n    const SPLAT_RES = MapEditorConfig.SPLAT_RES;\r\n\r\n    if (sampleX >= 0 && sampleX < SPLAT_RES && sampleY >= 0 && sampleY < SPLAT_RES) {\r\n        const idx = sampleY * SPLAT_RES + sampleX;\r\n        const arr = data.splatMap;\r\n        return (arr && idx < arr.length ? arr[idx] : 0) ?? 0;\r\n    }\r\n    if (!worldData) return 0;\r\n\r\n    const [cx, cy] = chunkKey.split(',').map(Number);\r\n    const nCx = cx + Math.floor(sampleX / SPLAT_RES);\r\n    const nCy = cy + Math.floor(sampleY / SPLAT_RES);\r\n    const nKey = `${nCx},${nCy}`;\r\n    const nData = worldData.get(nKey);\r\n\r\n    if (nData?.splatMap && nData.splatMap.length > 0) {\r\n        const nLx = ((sampleX % SPLAT_RES) + SPLAT_RES) % SPLAT_RES;\r\n        const nLy = ((sampleY % SPLAT_RES) + SPLAT_RES) % SPLAT_RES;\r\n        const idx = nLy * SPLAT_RES + nLx;\r\n        if (idx < nData.splatMap!.length) return nData.splatMap![idx];\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\nexport type PaintOp = { x: number; y: number; radius: number; intensity: number };\r\n\r\nexport type GroundSystemUpdateTile = (\r\n    chunkKey: string,\r\n    lx: number,\r\n    ly: number,\r\n    data: ChunkData,\r\n    groundLayer: PIXI.Container,\r\n    resolvedPaletteId?: string | null,\r\n    splatDataOverride?: Uint8ClampedArray,\r\n    preloadedAssets?: Map<string, unknown>,\r\n    worldData?: Map<string, ChunkData>\r\n) => Promise<void>;\r\n\r\nexport function applyPaintOps(\r\n    ops: PaintOp[],\r\n    soft: boolean,\r\n    worldData: Map<string, ChunkData>\r\n): { changeMap: Map<string, { chunkKey: string; idx: number; oldVal: number; newVal: number }>; dirtyTiles: Map<string, Set<string>> } {\r\n    const changeMap = new Map<string, { chunkKey: string; idx: number; oldVal: number; newVal: number }>();\r\n    const dirtyTiles = new Map<string, Set<string>>();\r\n    const { CHUNK_SIZE, TILE_SIZE } = MapEditorConfig;\r\n    const SPLAT_CELL_SIZE = TILE_SIZE / 4;\r\n    const SPLATS_PER_CHUNK = MapEditorConfig.SPLAT_RES;\r\n\r\n    for (const op of ops) {\r\n        const centerSplatX = Math.floor(op.x / SPLAT_CELL_SIZE);\r\n        const centerSplatY = Math.floor(op.y / SPLAT_CELL_SIZE);\r\n        const rCeil = Math.ceil(op.radius);\r\n\r\n        for (let dx = -rCeil; dx <= rCeil; dx++) {\r\n            for (let dy = -rCeil; dy <= rCeil; dy++) {\r\n                const distSq = dx * dx + dy * dy;\r\n                if (distSq > op.radius * op.radius) continue;\r\n                let factor = 1;\r\n                if (soft && op.radius > 1.5) {\r\n                    const dist = Math.sqrt(distSq);\r\n                    factor = Math.max(0, 1 - dist / op.radius);\r\n                    factor = factor * factor * (3 - 2 * factor);\r\n                }\r\n                const sx = centerSplatX + dx;\r\n                const sy = centerSplatY + dy;\r\n                const chunkX = Math.floor(sx / SPLATS_PER_CHUNK);\r\n                const chunkY = Math.floor(sy / SPLATS_PER_CHUNK);\r\n                const chunkKey = `${chunkX},${chunkY}`;\r\n\r\n                let data = worldData.get(chunkKey);\r\n                if (!data) {\r\n                    data = {\r\n                        id: chunkKey,\r\n                        objects: [],\r\n                        zones: {},\r\n                        splatMap: Array.from(new Uint8ClampedArray(SPLATS_PER_CHUNK * SPLATS_PER_CHUNK))\r\n                    };\r\n                    worldData.set(chunkKey, data);\r\n                }\r\n                if (!data.splatMap?.length) {\r\n                    data.splatMap = Array.from(new Uint8ClampedArray(SPLATS_PER_CHUNK * SPLATS_PER_CHUNK));\r\n                }\r\n                const localSx = ((sx % SPLATS_PER_CHUNK) + SPLATS_PER_CHUNK) % SPLATS_PER_CHUNK;\r\n                const localSy = ((sy % SPLATS_PER_CHUNK) + SPLATS_PER_CHUNK) % SPLATS_PER_CHUNK;\r\n                const idx = localSy * SPLATS_PER_CHUNK + localSx;\r\n                const cellKey = `${chunkKey}:${idx}`;\r\n                const val = data.splatMap[idx] || 0;\r\n                const newVal = Math.min(255, Math.max(0, val + op.intensity * factor));\r\n                if (Math.abs(val - newVal) > 0.5) {\r\n                    const existing = changeMap.get(cellKey);\r\n                    changeMap.set(cellKey, {\r\n                        chunkKey,\r\n                        idx,\r\n                        oldVal: existing?.oldVal ?? val,\r\n                        newVal\r\n                    });\r\n                    data.splatMap[idx] = newVal;\r\n                    const tileX = Math.floor(localSx / 4);\r\n                    const tileY = Math.floor(localSy / 4);\r\n                    if (!dirtyTiles.has(chunkKey)) dirtyTiles.set(chunkKey, new Set());\r\n                    dirtyTiles.get(chunkKey)!.add(`${tileX},${tileY}`);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return { changeMap, dirtyTiles };\r\n}\r\n\r\nexport function applyRestoreSplat(\r\n    changesByChunk: Map<string, { idx: number; oldVal: number; newVal: number }[]>,\r\n    undo: boolean,\r\n    worldData: Map<string, ChunkData>\r\n): Map<string, Set<string>> {\r\n    const dirtyTiles = new Map<string, Set<string>>();\r\n    const SPLATS_PER_CHUNK = MapEditorConfig.SPLAT_RES;\r\n\r\n    for (const [chunkKey, changes] of changesByChunk) {\r\n        const data = worldData.get(chunkKey);\r\n        if (!data || !data.splatMap) continue;\r\n\r\n        changes.forEach((c) => {\r\n            const val = undo ? c.oldVal : c.newVal;\r\n            data.splatMap![c.idx] = val;\r\n\r\n            const localSy = Math.floor(c.idx / SPLATS_PER_CHUNK);\r\n            const localSx = c.idx % SPLATS_PER_CHUNK;\r\n            const tileX = Math.floor(localSx / 4);\r\n            const tileY = Math.floor(localSy / 4);\r\n            const tKey = `${tileX},${tileY}`;\r\n\r\n            if (!dirtyTiles.has(chunkKey)) dirtyTiles.set(chunkKey, new Set());\r\n            dirtyTiles.get(chunkKey)!.add(tKey);\r\n        });\r\n    }\r\n    return dirtyTiles;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\GroundSystemTileTexture.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\MapEditorBrushCursor.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'MapEditorConfig' is defined but never used.","line":5,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":25,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"MapEditorConfig"},"fix":{"range":[114,166],"text":""},"desc":"Remove unused import declaration."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * MapEditorBrushCursor - Brush cursor drawing for zone/ground modes\r\n */\r\nimport * as PIXI from 'pixi.js';\r\nimport { MapEditorConfig } from './MapEditorConfig';\r\n\r\nexport interface BrushCursorParams {\r\n    brushCursor: PIXI.Graphics;\r\n    worldX: number;\r\n    worldY: number;\r\n    editingMode: 'object' | 'manipulation';\r\n    currentTool: string;\r\n    brushSize: number;\r\n    zoom: number;\r\n    shiftKey: boolean;\r\n}\r\n\r\nexport function updateBrushCursor(params: BrushCursorParams): void {\r\n    const { brushCursor } = params;\r\n    brushCursor.visible = false;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\MapEditorConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\MapEditorCore.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ZoneConfig' is defined but never used.","line":6,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":20,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"ZoneConfig"},"fix":{"range":[243,254],"text":""},"desc":"Remove unused variable \"ZoneConfig\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ZoneCategory' is defined but never used.","line":6,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":34,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"ZoneCategory"},"fix":{"range":[234,294],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'PlaceObjectCommand' is defined but never used.","line":12,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":28,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"PlaceObjectCommand"},"fix":{"range":[545,612],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'RemoveObjectCommand' is defined but never used.","line":13,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":29,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"RemoveObjectCommand"},"fix":{"range":[614,683],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'AddWaypointCommand' is defined but never used.","line":14,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":28,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"AddWaypointCommand"},"fix":{"range":[685,752],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'RemoveWaypointCommand' is defined but never used.","line":15,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":31,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"RemoveWaypointCommand"},"fix":{"range":[754,827],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'UpdateWaypointRegionCommand' is defined but never used.","line":16,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":16,"endColumn":37,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"UpdateWaypointRegionCommand"},"fix":{"range":[829,914],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'AddManualTownCommand' is defined but never used.","line":17,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":17,"endColumn":30,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"AddManualTownCommand"},"fix":{"range":[916,987],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'AddManualStationCommand' is defined but never used.","line":18,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":18,"endColumn":33,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"AddManualStationCommand"},"fix":{"range":[989,1066],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'RemoveManualTownCommand' is defined but never used.","line":19,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":33,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"RemoveManualTownCommand"},"fix":{"range":[1068,1145],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'RemoveManualStationCommand' is defined but never used.","line":20,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":20,"endColumn":36,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"RemoveManualStationCommand"},"fix":{"range":[1147,1230],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'SetManualTownAtCommand' is defined but never used.","line":21,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":21,"endColumn":32,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"SetManualTownAtCommand"},"fix":{"range":[1232,1307],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'SetManualStationRegionCommand' is defined but never used.","line":22,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":22,"endColumn":39,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"SetManualStationRegionCommand"},"fix":{"range":[1309,1398],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'updateCursorCoords' is defined but never used.","line":35,"column":38,"nodeType":"Identifier","messageId":"unusedVar","endLine":35,"endColumn":56,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"updateCursorCoords"},"fix":{"range":[1926,1946],"text":""},"desc":"Remove unused variable \"updateCursorCoords\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'updateBrushCursor' is defined but never used.","line":37,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":37,"endColumn":27,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"updateBrushCursor"},"fix":{"range":[2082,2141],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'screenToWorld' is defined but never used.","line":38,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":38,"endColumn":23,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"screenToWorld"},"fix":{"range":[2152,2166],"text":""},"desc":"Remove unused variable \"screenToWorld\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'toCanvasCoords' is defined but never used.","line":38,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":38,"endColumn":39,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"toCanvasCoords"},"fix":{"range":[2143,2216],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'handleZoomViewport' is defined but never used.","line":39,"column":24,"nodeType":"Identifier","messageId":"unusedVar","endLine":39,"endColumn":42,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"handleZoomViewport"},"fix":{"range":[2227,2260],"text":""},"desc":"Remove unused variable \"handleZoomViewport\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'executeTool' is defined but never used.","line":42,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":42,"endColumn":21,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"executeTool"},"fix":{"range":[2424,2473],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'SPLINE_HIT_THRESHOLD_WORLD' is defined but never used.","line":49,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":49,"endColumn":31,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"SPLINE_HIT_THRESHOLD_WORLD"},"fix":{"range":[2759,2786],"text":""},"desc":"Remove unused variable \"SPLINE_HIT_THRESHOLD_WORLD\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isWorldPointOnSplinePath' is defined but never used.","line":50,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":50,"endColumn":29,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"isWorldPointOnSplinePath"},"fix":{"range":[2785,2816],"text":""},"desc":"Remove unused variable \"isWorldPointOnSplinePath\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getNearestLegIndexForWorldPoint' is defined but never used.","line":51,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":51,"endColumn":36,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"getNearestLegIndexForWorldPoint"},"fix":{"range":[2816,2854],"text":""},"desc":"Remove unused variable \"getNearestLegIndexForWorldPoint\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getWaypointInsertionIndex' is defined but never used.","line":52,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":52,"endColumn":30,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"getWaypointInsertionIndex"},"fix":{"range":[2745,2922],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_err' is defined but never used.","line":270,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":270,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":24,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as PIXI from 'pixi.js';\r\nimport { Logger } from '@core/Logger';\r\nimport { MapEditorConfig } from './MapEditorConfig';\r\nimport { ChunkManager } from './ChunkManager';\r\nimport { ChunkData, MapObject } from './MapEditorTypes';\r\nimport { ZoneConfig, ZoneCategory } from '@data/ZoneConfig';\r\nimport { EditorContext } from './EditorContext';\r\nimport { CommandManager } from './commands/CommandManager';\r\n\r\nimport { BatchObjectCommand } from './commands/BatchObjectCommand';\r\nimport { MoveObjectCommand } from './commands/MoveObjectCommand';\r\nimport { PlaceObjectCommand } from './commands/PlaceObjectCommand';\r\nimport { RemoveObjectCommand } from './commands/RemoveObjectCommand';\r\nimport { AddWaypointCommand } from './commands/AddWaypointCommand';\r\nimport { RemoveWaypointCommand } from './commands/RemoveWaypointCommand';\r\nimport { UpdateWaypointRegionCommand } from './commands/UpdateWaypointRegionCommand';\r\nimport { AddManualTownCommand } from './commands/AddManualTownCommand';\r\nimport { AddManualStationCommand } from './commands/AddManualStationCommand';\r\nimport { RemoveManualTownCommand } from './commands/RemoveManualTownCommand';\r\nimport { RemoveManualStationCommand } from './commands/RemoveManualStationCommand';\r\nimport { SetManualTownAtCommand } from './commands/SetManualTownAtCommand';\r\nimport { SetManualStationRegionCommand } from './commands/SetManualStationRegionCommand';\r\nimport { SetHeroSpawnCommand } from './commands/SetHeroSpawnCommand';\r\nimport { EditorCommand } from './commands/EditorCommand';\r\nimport type { Mapgen4Param } from './Mapgen4Generator';\r\nimport type { ManualStation, RailroadWaypointEntry } from '../../world/MapDataService';\r\nimport {\r\n    buildProceduralCache,\r\n    drawProceduralToCanvas,\r\n    updateRailroadMeshes,\r\n    worldToMeshViewport,\r\n    type ProceduralCache,\r\n    type RailroadMeshState\r\n} from './MapEditorProceduralRenderer';\r\nimport { createZoomUI, updateZoomUI, updateCursorCoords } from './MapEditorUIOverlays';\r\nimport { createScaleReferenceOverlay, type ScaleReferenceOverlay } from './MapEditorScaleReference';\r\nimport { updateBrushCursor } from './MapEditorBrushCursor';\r\nimport { screenToWorld, toCanvasCoords } from './MapEditorInputHandlers';\r\nimport { handleZoom as handleZoomViewport, resetZoomToGame } from './MapEditorViewport';\r\nimport { createHistoryUI } from './MapEditorHistoryOverlay';\r\nimport { findRegionAt } from './Mapgen4RegionUtils';\r\nimport { executeTool } from './MapEditorToolUse';\r\nimport { preloadRegistry } from './MapEditorRegistry';\r\nimport { AssetLoader } from '@core/AssetLoader';\r\nimport { createPixiApp } from './MapEditorMount';\r\nimport { runMapEditorUpdate } from './MapEditorUpdate';\r\nimport { EntityLoader } from '@entities/EntityLoader';\r\nimport {\r\n    SPLINE_HIT_THRESHOLD_WORLD,\r\n    isWorldPointOnSplinePath,\r\n    getNearestLegIndexForWorldPoint,\r\n    getWaypointInsertionIndex\r\n} from './MapEditorRailroadUtils';\r\nimport { MapEditorDebugOverlay } from './MapEditorDebugOverlay';\r\nimport { MapEditorWaypointManager } from './MapEditorWaypointManager';\r\nimport { MapEditorManipulationHandles } from './MapEditorManipulationHandles';\r\nimport { getDebugOverlayHost, getWaypointManagerHost, getManipulationHandlesHost } from './MapEditorHosts';\r\nimport { setupInputListeners, type InputState } from './MapEditorInput';\r\n\r\n/**\r\n * MapEditorCore\r\n *\r\n * The central controller for the Map Editor tool.\r\n * Manages the PixiJS Application, Input Handling, and Tool State.\r\n */\r\nexport class MapEditorCore {\r\n    private app: PIXI.Application | null = null;\r\n    private container: HTMLElement | null = null;\r\n    private worldContainer: PIXI.Container | null = null;\r\n    private chunkManager: ChunkManager | null = null;\r\n    private proceduralCanvas: HTMLCanvasElement | null = null;\r\n    private proceduralSprite: PIXI.Sprite | null = null;\r\n    private procCache: ProceduralCache | null = null;\r\n    private railroadState: RailroadMeshState = {\r\n        railroadMeshContainer: null,\r\n        railroadMeshes: [],\r\n        cacheKey: null\r\n    };\r\n    private lastMainViewViewportKey: string | null = null;\r\n    private selectedAsset: { id: string; category: string } | null = null;\r\n    private brushCursor: PIXI.Graphics | null = null;\r\n\r\n    // State\r\n    private isInitialized: boolean = false;\r\n    private currentTool: 'brush' | 'eraser' | 'select' = 'brush';\r\n    private currentLayer: number = MapEditorConfig.Layers.GROUND;\r\n\r\n    // Zone Editor State\r\n    private editingMode: 'object' | 'manipulation' = 'object';\r\n\r\n    // Viewport State\r\n    private zoom: number = 1.0; // Default to 100% (Gameplay parity)\r\n    private inputState: InputState = {\r\n        isDragging: false,\r\n        isPainting: false,\r\n        isSpacePressed: false,\r\n        lastMousePosition: { x: 0, y: 0 },\r\n        currentObjectActions: []\r\n    };\r\n    private inputCleanup: (() => void) | null = null;\r\n\r\n    private selectedObject: MapObject | null = null;\r\n    private onNextClickAction: ((x: number, y: number) => void) | null = null;\r\n\r\n    private scaleReferenceOverlay: ScaleReferenceOverlay | null = null;\r\n\r\n    /** Debug: show train station order numbers above each station polygon. */\r\n    private debugShowStationNumbers = false;\r\n    private debugShowSplinePath = false;\r\n\r\n    private readonly debugOverlay = new MapEditorDebugOverlay();\r\n    private readonly waypointManager = new MapEditorWaypointManager();\r\n    private readonly manipulationHandles = new MapEditorManipulationHandles();\r\n\r\n    /** Manual towns (region IDs). When non-empty, override procedural towns. */\r\n    private manualTowns: number[] = [];\r\n    /** Manual stations with order. When non-empty, railroad uses this order. */\r\n    private manualStations: ManualStation[] = [];\r\n    /** Waypoints per leg for railroad shaping. */\r\n    private railroadWaypoints: RailroadWaypointEntry[] = [];\r\n    /** Callback when manual data changes (e.g. dashboard refresh, save). */\r\n    private onManualDataChange: (() => void) | null = null;\r\n    /** Callback when any command is executed (object placed/moved/deleted, etc). */\r\n    private onCommandExecuted: (() => void) | null = null;\r\n\r\n    // Commands\r\n    private commandManager: CommandManager;\r\n\r\n    constructor() {\r\n        this.commandManager = new CommandManager();\r\n        Logger.info('[MapEditorCore] Instantiated');\r\n    }\r\n\r\n    public executeCommand(cmd: EditorCommand): void {\r\n        this.commandManager.execute(cmd);\r\n        this.onCommandExecuted?.();\r\n    }\r\n\r\n    public selectAsset(id: string, category: string) {\r\n        this.selectedAsset = { id, category };\r\n        this.editingMode = 'object';\r\n        // Preload so the actual asset appears immediately on first placement (no placeholder)\r\n        AssetLoader.preloadImage(id);\r\n\r\n        this.currentTool = 'brush';\r\n        Logger.info(`[MapEditor] Selected: ${id} (${category})`);\r\n    }\r\n\r\n    public async mount(\r\n        containerId: string,\r\n        dataFetcher?: (\r\n            category: string\r\n        ) => Promise<{ entities: Array<{ id: string;[key: string]: unknown }> }>\r\n    ): Promise<void> {\r\n        if (this.isInitialized) return;\r\n\r\n        this.container = document.getElementById(containerId);\r\n        if (!this.container) {\r\n            Logger.error(`[MapEditorCore] Container #${containerId} not found`);\r\n            return;\r\n        }\r\n\r\n        Logger.info('[MapEditorCore] Mounting...');\r\n\r\n        // Ensure EntityRegistry is populated so AssetLoader uses same image paths as game\r\n        await EntityLoader.load();\r\n\r\n        preloadRegistry(dataFetcher);\r\n\r\n        const result = await createPixiApp(this.container, this.zoom);\r\n        this.app = result.app;\r\n        this.worldContainer = result.worldContainer;\r\n        this.proceduralCanvas = result.proceduralCanvas;\r\n        this.proceduralSprite = result.proceduralSprite;\r\n        this.chunkManager = result.chunkManager;\r\n        this.brushCursor = result.brushCursor;\r\n        this.zoom = result.initialZoom;\r\n\r\n        this.setupInputListeners();\r\n        this.setupEntityUpdateListener();\r\n        this.app.ticker.add(this.update, this);\r\n        this.createUIOverlays();\r\n\r\n        this.scaleReferenceOverlay = await createScaleReferenceOverlay(this.app, {\r\n            onHeroSpawnClick: () => this.enterHeroSpawnPlacementMode()\r\n        });\r\n\r\n        this.isInitialized = true;\r\n\r\n        Logger.info('[MapEditorCore] Initialized successfully');\r\n    }\r\n\r\n    private setupEntityUpdateListener(): void {\r\n        if (typeof window === 'undefined' || typeof BroadcastChannel === 'undefined') return;\r\n        const channel = new BroadcastChannel('game-entity-updates');\r\n        channel.onmessage = (event) => {\r\n            const d = event.data;\r\n            if (d?.type !== 'ENTITY_UPDATE' || !d.updates) return;\r\n            const u = d.updates as Record<string, unknown>;\r\n            const hasDisplayChange =\r\n                'display.width' in u ||\r\n                'display.height' in u ||\r\n                'display.sizeScale' in u ||\r\n                'display.scale' in u ||\r\n                'width' in u ||\r\n                'height' in u ||\r\n                'sizeScale' in u ||\r\n                'scale' in u;\r\n            if (hasDisplayChange && this.chunkManager) {\r\n                this.chunkManager.refreshObjectSprites();\r\n            }\r\n        };\r\n    }\r\n\r\n    public setMode(mode: 'object' | 'manipulation') {\r\n        this.editingMode = mode;\r\n        Logger.info(`[MapEditor] Mode set to ${mode}`);\r\n    }\r\n\r\n    public setGridOpacity(opacity: number) { this.chunkManager?.setGridOpacity(opacity); }\r\n\r\n    private createUIOverlays() {\r\n        createZoomUI(this.container, () => this.resetZoomToGame());\r\n        createHistoryUI(this.container, this.commandManager);\r\n        updateZoomUI(this.zoom);\r\n    }\r\n\r\n    private resetZoomToGame(): void {\r\n        if (!this.app || !this.worldContainer) return;\r\n        const { zoom, worldX, worldY } = resetZoomToGame({\r\n            canvasWidth: this.app.canvas.width,\r\n            canvasHeight: this.app.canvas.height,\r\n            worldContainer: this.worldContainer,\r\n            zoom: this.zoom\r\n        });\r\n        this.zoom = zoom;\r\n        this.worldContainer.scale.set(zoom);\r\n        this.worldContainer.x = worldX;\r\n        this.worldContainer.y = worldY;\r\n        this.updateZoomUI();\r\n    }\r\n\r\n    private updateZoomUI() { updateZoomUI(this.zoom); }\r\n\r\n    public unmount(): void {\r\n        if (!this.isInitialized || !this.app) return;\r\n        Logger.info('[MapEditorCore] Unmounting...');\r\n        this.app.ticker.remove(this.update, this);\r\n        this.scaleReferenceOverlay?.destroy();\r\n        this.scaleReferenceOverlay = null;\r\n        this.debugOverlay.destroy();\r\n        this.waypointManager.destroy();\r\n        this.manipulationHandles.destroy();\r\n        this.inputCleanup?.();\r\n        this.inputCleanup = null;\r\n        this.app.destroy(true, { children: true });\r\n        this.app = this.container = this.worldContainer = this.chunkManager = null;\r\n        this.proceduralCanvas = null;\r\n        this.proceduralSprite = null;\r\n        this.procCache = null;\r\n        this.railroadState = { railroadMeshContainer: null, railroadMeshes: [], cacheKey: null };\r\n        this.lastMainViewViewportKey = null;\r\n        this.isInitialized = false;\r\n    }\r\n\r\n    private update(_ticker: PIXI.Ticker): void {\r\n        if (!this.chunkManager || !this.app || !this.worldContainer) return;\r\n        try {\r\n            runMapEditorUpdate(this.app, this.worldContainer, this.zoom, this.chunkManager);\r\n        } catch (_err) {\r\n            /* viewport/load errors logged elsewhere */\r\n        }\r\n        this.drawProceduralToMainView();\r\n        this.scaleReferenceOverlay?.update(this.zoom, this.app.canvas.width, this.app.canvas.height);\r\n        try {\r\n            this.debugOverlay.update(this.getDebugOverlayHost());\r\n        } catch (err) {\r\n            Logger.warn('[MapEditor] debugOverlay.update error', err);\r\n        }\r\n        this.waypointManager.update(this.getWaypointManagerHost());\r\n        this.manipulationHandles.update(this.getManipulationHandlesHost());\r\n    }\r\n\r\n    /** Resolve world coords to mesh region ID. Returns null if no procedural cache. */\r\n    public getRegionAtWorld(worldX: number, worldY: number): number | null {\r\n        if (!this.procCache) return null;\r\n        const { mesh } = this.procCache.meshAndMap;\r\n        const { cellRegions } = this.procCache;\r\n        const worldSize = MapEditorConfig.WORLD_WIDTH_TILES * MapEditorConfig.TILE_SIZE;\r\n        const meshPerWorld = 1000 / worldSize;\r\n        const meshX = worldX * meshPerWorld;\r\n        const meshY = worldY * meshPerWorld;\r\n        return findRegionAt(mesh, meshX, meshY, cellRegions);\r\n    }\r\n\r\n    private getDebugOverlayHost() {\r\n        return getDebugOverlayHost(this, {\r\n            procCache: this.procCache,\r\n            worldContainer: this.worldContainer,\r\n            app: this.app,\r\n            zoom: this.zoom,\r\n            debugShowStationNumbers: this.debugShowStationNumbers,\r\n            debugShowSplinePath: this.debugShowSplinePath\r\n        });\r\n    }\r\n\r\n    private getWaypointManagerHost() {\r\n        return getWaypointManagerHost(this, {\r\n            procCache: this.procCache,\r\n            worldContainer: this.worldContainer,\r\n            app: this.app,\r\n            zoom: this.zoom,\r\n            manualStations: this.manualStations,\r\n            railroadWaypoints: this.railroadWaypoints,\r\n            editingMode: this.editingMode,\r\n            debugShowStationNumbers: this.debugShowStationNumbers,\r\n            debugShowSplinePath: this.debugShowSplinePath\r\n        });\r\n    }\r\n\r\n    private getManipulationHandlesHost() {\r\n        return getManipulationHandlesHost(this, {\r\n            procCache: this.procCache,\r\n            worldContainer: this.worldContainer,\r\n            app: this.app,\r\n            zoom: this.zoom,\r\n            manualTowns: this.manualTowns,\r\n            manualStations: this.manualStations,\r\n            editingMode: this.editingMode\r\n        });\r\n    }\r\n\r\n    private setupInputListeners(): void {\r\n        const { cleanup } = setupInputListeners(this, this.inputState);\r\n        this.inputCleanup = cleanup;\r\n    }\r\n\r\n    /** Trigger canvas resize (e.g. when sidebars change layout). Responds to ResizeObserver. */\r\n    public resize(): void {\r\n        this.app?.resize?.();\r\n    }\r\n\r\n    /** Invalidate viewport cache so procedural map redraws on next frame. Use on resize; do not regenerate cache. */\r\n    public invalidateProceduralViewport(): void {\r\n        this.lastMainViewViewportKey = null;\r\n    }\r\n\r\n    public setDebugStationNumbers(show: boolean): void {\r\n        this.debugShowStationNumbers = show;\r\n    }\r\n\r\n    public getDebugStationNumbers(): boolean {\r\n        return this.debugShowStationNumbers;\r\n    }\r\n\r\n    public setDebugShowSplinePath(show: boolean): void {\r\n        this.debugShowSplinePath = show;\r\n    }\r\n\r\n    public getDebugShowSplinePath(): boolean {\r\n        return this.debugShowSplinePath;\r\n    }\r\n\r\n    public getChunkManager(): ChunkManager | null { return this.chunkManager; }\r\n\r\n    public setSelectedObject(obj: MapObject | null): void { this.selectedObject = obj; }\r\n    public getSelectedObject(): MapObject | null { return this.selectedObject; }\r\n\r\n    public clearOnNextClickAction(): void { this.onNextClickAction = null; }\r\n    public getOnNextClickAction(): ((x: number, y: number) => void) | null { return this.onNextClickAction; }\r\n    public setOnNextClickAction(fn: ((x: number, y: number) => void) | null): void {\r\n        this.onNextClickAction = fn;\r\n    }\r\n\r\n    // --- Accessors for UI/Input ---\r\n    public getApp() { return this.app; }\r\n    public getWorldContainer() { return this.worldContainer; }\r\n    public getProcCache() { return this.procCache; }\r\n    public getZoom() { return this.zoom; }\r\n    public setZoom(z: number) {\r\n        this.zoom = z;\r\n        if (this.worldContainer) {\r\n            this.worldContainer.scale.set(z);\r\n        }\r\n    }\r\n    public triggerZoomUIUpdate() { this.updateZoomUI(); }\r\n    public getEditingMode() { return this.editingMode; }\r\n    public getCurrentTool() { return this.currentTool; }\r\n    public getSelectedAsset() { return this.selectedAsset; }\r\n    public getBrushCursor() { return this.brushCursor; }\r\n    public getCommandManager() { return this.commandManager; }\r\n    public getWaypointManager() { return this.waypointManager; }\r\n\r\n    public enterHeroSpawnPlacementMode(): void {\r\n        if (!this.chunkManager || !this.app || !this.worldContainer) return;\r\n        const viewport = this.getViewportWorldRect();\r\n        if (!viewport) return;\r\n        const centerX = viewport.x + viewport.width / 2;\r\n        const centerY = viewport.y + viewport.height / 2;\r\n        this.executeCommand(new SetHeroSpawnCommand(this.chunkManager, Math.round(centerX), Math.round(centerY)));\r\n        Logger.info(`[MapEditor] Hero spawn set to view center: ${Math.round(centerX)}, ${Math.round(centerY)}`);\r\n    }\r\n\r\n    public moveSelectedObjectTo(newX: number, newY: number): boolean {\r\n        if (!this.selectedObject || !this.chunkManager) return false;\r\n        const { x, y, id } = this.selectedObject;\r\n        this.commandManager.execute(new MoveObjectCommand(this.chunkManager, x, y, newX, newY, id));\r\n        this.selectedObject = { id, x: newX, y: newY };\r\n        this.onCommandExecuted?.();\r\n        return true;\r\n    }\r\n\r\n    public removeSelectedObject(): boolean {\r\n        if (!this.selectedObject || !this.chunkManager) return false;\r\n        const { x, y, id } = this.selectedObject;\r\n        this.commandManager.execute(\r\n            new BatchObjectCommand(this.chunkManager, [{ type: 'remove', x, y, assetId: id }])\r\n        );\r\n        this.selectedObject = null;\r\n        this.onCommandExecuted?.();\r\n        return true;\r\n    }\r\n\r\n    /** Get the mapgen4 param from the current procedural cache (what is actually displayed). Use for save. */\r\n    public getMapgen4Param(): Mapgen4Param | null {\r\n        return this.procCache?.param ?? null;\r\n    }\r\n\r\n    /** Update procedural preview  builds cache when param changes. Uses manual towns/stations/waypoints when set. */\r\n    public async setProceduralPreview(param: Mapgen4Param): Promise<void> {\r\n        const manual: import('./Mapgen4Generator').ManualTownsAndRailroads | undefined =\r\n            this.manualTowns.length > 0 ||\r\n                this.manualStations.length > 0 ||\r\n                this.railroadWaypoints.length > 0\r\n                ? {\r\n                    manualTowns: this.manualTowns.length > 0 ? [...this.manualTowns] : undefined,\r\n                    manualStations: this.manualStations.length > 0 ? this.manualStations.map((s) => ({ ...s })) : undefined,\r\n                    railroadWaypoints: this.railroadWaypoints.length > 0 ? this.railroadWaypoints.map((w) => ({ ...w })) : undefined\r\n                }\r\n                : undefined;\r\n        let newCache: import('./MapEditorProceduralRenderer').ProceduralCache;\r\n        try {\r\n            newCache = await buildProceduralCache(param, manual);\r\n        } catch (err) {\r\n            Logger.error('[MapEditor] buildProceduralCache failed (possibly OOM)', err);\r\n            return;\r\n        }\r\n        const wantedStations = this.manualStations.length >= 2;\r\n        const newPathEmpty = newCache.railroadPath.length < 2;\r\n        const hadPath = (this.procCache?.railroadPath?.length ?? 0) >= 2;\r\n        if (wantedStations && newPathEmpty && this.procCache && hadPath) {\r\n            this.procCache = {\r\n                ...newCache,\r\n                railroadPath: this.procCache.railroadPath,\r\n                railroadCrossings: this.procCache.railroadCrossings,\r\n                railroadStationIds: this.procCache.railroadStationIds\r\n            };\r\n        } else {\r\n            this.procCache = newCache;\r\n        }\r\n        if (this.railroadState.railroadMeshContainer) {\r\n            this.railroadState.railroadMeshContainer.destroy({ children: true });\r\n            this.railroadState.railroadMeshContainer = null;\r\n        }\r\n        for (const m of this.railroadState.railroadMeshes) m.destroy();\r\n        this.railroadState = { railroadMeshContainer: null, railroadMeshes: [], cacheKey: null };\r\n        this.updateRailroadMeshesFromCache();\r\n        this.lastMainViewViewportKey = null;\r\n    }\r\n\r\n    /**\r\n     * Draw cached mesh to a canvas (e.g. sidebar). Uses full viewport (0..1000) if viewport omitted.\r\n     * Returns true if drawn; false if no cache.\r\n     */\r\n    public drawCachedToCanvas(\r\n        canvas: HTMLCanvasElement,\r\n        viewport?: { x: number; y: number; width: number; height: number }\r\n    ): boolean {\r\n        if (!this.procCache) return false;\r\n        return drawProceduralToCanvas(this.procCache, canvas, viewport, EditorContext.hiddenZoneIds);\r\n    }\r\n\r\n    /** Update railroad PIXI meshes when cache or visibility changes. Uses spline mesh for gapless rendering. */\r\n    private updateRailroadMeshesFromCache(): void {\r\n        if (!this.procCache || !this.worldContainer) return;\r\n        this.railroadState = updateRailroadMeshes(\r\n            this.procCache,\r\n            this.worldContainer,\r\n            EditorContext.hiddenZoneIds,\r\n            this.railroadState,\r\n            true\r\n        );\r\n    }\r\n\r\n    /** Draw procedural map to offscreen canvas; display via PIXI sprite on stage. */\r\n    private drawProceduralToMainView(): void {\r\n        if (!this.procCache || !this.proceduralCanvas || !this.proceduralSprite || !this.app || !this.worldContainer) return;\r\n        const maxSize = MapEditorConfig.MAX_PROCEDURAL_CANVAS_SIZE;\r\n        const w = Math.min(this.app.canvas.width, maxSize);\r\n        const h = Math.min(this.app.canvas.height, maxSize);\r\n        if (w < 1 || h < 1) return;\r\n\r\n        const { vpX, vpY, vpW, vpH } = worldToMeshViewport(\r\n            this.worldContainer,\r\n            this.zoom,\r\n            w,\r\n            h\r\n        );\r\n        if (!Number.isFinite(vpX + vpY + vpW + vpH) || vpW < 1 || vpH < 1) return;\r\n        const visKey = [...EditorContext.hiddenZoneIds].sort().join(',');\r\n        const vpKey = `${Math.round(vpX * 10) / 10},${Math.round(vpY * 10) / 10},${Math.round(vpW * 10) / 10},${Math.round(vpH * 10) / 10}|${visKey}`;\r\n        if (vpKey === this.lastMainViewViewportKey) return;\r\n        this.lastMainViewViewportKey = vpKey;\r\n\r\n        // Resize offscreen canvas if needed; rebuild texture source when dimensions change\r\n        if (this.proceduralCanvas.width !== w || this.proceduralCanvas.height !== h) {\r\n            this.proceduralCanvas.width = w;\r\n            this.proceduralCanvas.height = h;\r\n            const newSource = new PIXI.CanvasSource({ resource: this.proceduralCanvas, dynamic: true });\r\n            const oldTexture = this.proceduralSprite.texture;\r\n            this.proceduralSprite.texture = new PIXI.Texture({ source: newSource });\r\n            oldTexture.destroy();\r\n        }\r\n\r\n        // Railroad rendered as PIXI spline mesh (gapless); skip on canvas.\r\n        drawProceduralToCanvas(\r\n            this.procCache,\r\n            this.proceduralCanvas,\r\n            { x: vpX, y: vpY, width: vpW, height: vpH },\r\n            EditorContext.hiddenZoneIds,\r\n            true\r\n        );\r\n\r\n        this.proceduralSprite.width = w;\r\n        this.proceduralSprite.height = h;\r\n        this.proceduralSprite.texture.source.update();\r\n    }\r\n\r\n    public getViewportWorldRect(): { x: number; y: number; width: number; height: number } | null {\r\n        if (!this.app || !this.worldContainer) return null;\r\n        const w = this.app.canvas.width / this.zoom;\r\n        const h = this.app.canvas.height / this.zoom;\r\n        return { x: -this.worldContainer.x / this.zoom, y: -this.worldContainer.y / this.zoom, width: w, height: h };\r\n    }\r\n    public centerViewOn(worldX: number, worldY: number): void {\r\n        if (!this.app || !this.worldContainer) return;\r\n        const cx = this.app.canvas.width / 2;\r\n        const cy = this.app.canvas.height / 2;\r\n        this.worldContainer.x = cx - worldX * this.zoom;\r\n        this.worldContainer.y = cy - worldY * this.zoom;\r\n    }\r\n    public serialize(): {\r\n        version: number;\r\n        chunks: ChunkData[];\r\n        heroSpawn?: import('./MapEditorTypes').HeroSpawnPosition;\r\n        manualTowns?: number[];\r\n        manualStations?: import('../../world/MapDataService').ManualStation[];\r\n        railroadWaypoints?: import('../../world/MapDataService').RailroadWaypointEntry[];\r\n    } | null {\r\n        const base = this.chunkManager?.serialize() ?? null;\r\n        if (!base) return null;\r\n        const out: NonNullable<ReturnType<MapEditorCore['serialize']>> = { ...base };\r\n        if (this.manualTowns.length > 0) out.manualTowns = [...this.manualTowns];\r\n        if (this.manualStations.length > 0) out.manualStations = this.manualStations.map((s) => ({ ...s }));\r\n        if (this.railroadWaypoints.length > 0) out.railroadWaypoints = this.railroadWaypoints.map((w) => ({ ...w }));\r\n        return out;\r\n    }\r\n    public loadData(data: {\r\n        version?: number;\r\n        chunks?: ChunkData[];\r\n        heroSpawn?: import('./MapEditorTypes').HeroSpawnPosition;\r\n        manualTowns?: number[];\r\n        manualStations?: import('../../world/MapDataService').ManualStation[];\r\n        railroadWaypoints?: import('../../world/MapDataService').RailroadWaypointEntry[];\r\n    }): void {\r\n        this.chunkManager?.deserialize(data);\r\n        this.commandManager.clear();\r\n        this.manualTowns = Array.isArray(data.manualTowns) ? [...data.manualTowns] : [];\r\n        this.manualStations = Array.isArray(data.manualStations)\r\n            ? data.manualStations.map((s) => ({ regionId: s.regionId, order: s.order }))\r\n            : [];\r\n        this.railroadWaypoints = Array.isArray(data.railroadWaypoints)\r\n            ? data.railroadWaypoints.map((w) => ({ legIndex: w.legIndex, regionId: w.regionId }))\r\n            : [];\r\n        this.onManualDataChange?.();\r\n    }\r\n\r\n    public setOnManualDataChange(fn: (() => void) | null): void {\r\n        this.onManualDataChange = fn;\r\n    }\r\n    public setOnCommandExecuted(fn: (() => void) | null): void {\r\n        this.onCommandExecuted = fn;\r\n    }\r\n    public getManualTowns(): number[] {\r\n        return [...this.manualTowns];\r\n    }\r\n    public getManualStations(): ManualStation[] {\r\n        return this.manualStations.map((s) => ({ ...s }));\r\n    }\r\n    public getRailroadWaypoints(): RailroadWaypointEntry[] {\r\n        return this.railroadWaypoints.map((w) => ({ ...w }));\r\n    }\r\n    public addManualTown(regionId: number): void {\r\n        if (this.manualTowns.includes(regionId)) return;\r\n        this.manualTowns.push(regionId);\r\n        this.onManualDataChange?.();\r\n    }\r\n    public removeManualTown(regionId: number): void {\r\n        this.manualTowns = this.manualTowns.filter((r) => r !== regionId);\r\n        this.onManualDataChange?.();\r\n    }\r\n    public addManualStation(regionId: number, order: number): void {\r\n        const next = order <= 0\r\n            ? (this.manualStations.reduce((m, s) => Math.max(m, s.order), 0) + 1)\r\n            : order;\r\n        this.manualStations.push({ regionId, order: next });\r\n        this.onManualDataChange?.();\r\n    }\r\n    public setStationOrder(index: number, order: number): void {\r\n        if (index < 0 || index >= this.manualStations.length) return;\r\n        this.manualStations[index] = { ...this.manualStations[index]!, order };\r\n        this.onManualDataChange?.();\r\n    }\r\n    /** Move town at index to a new polygon. Removes duplicate if regionId already exists at another index. */\r\n    public setManualTownAt(index: number, regionId: number): void {\r\n        if (index < 0 || index >= this.manualTowns.length) return;\r\n        const out: number[] = [];\r\n        for (let i = 0; i < this.manualTowns.length; i++) {\r\n            if (i === index) {\r\n                out.push(regionId);\r\n            } else if (this.manualTowns[i] !== regionId) {\r\n                out.push(this.manualTowns[i]);\r\n            }\r\n        }\r\n        this.manualTowns = out;\r\n        this.onManualDataChange?.();\r\n    }\r\n    /** Move station at index to a new polygon (keeps order). */\r\n    public setManualStationRegion(index: number, regionId: number): void {\r\n        if (index < 0 || index >= this.manualStations.length) return;\r\n        this.manualStations[index] = { ...this.manualStations[index]!, regionId };\r\n        this.onManualDataChange?.();\r\n    }\r\n    public removeManualStation(regionId: number): void {\r\n        this.manualStations = this.manualStations.filter((s) => s.regionId !== regionId);\r\n        this.onManualDataChange?.();\r\n    }\r\n    public addWaypoint(legIndex: number, regionId: number, insertIndex?: number): void {\r\n        const waypoint = { legIndex, regionId };\r\n        if (insertIndex !== undefined) {\r\n            let legCount = 0;\r\n            let inserted = false;\r\n            for (let i = 0; i < this.railroadWaypoints.length; i++) {\r\n                if (this.railroadWaypoints[i]!.legIndex === legIndex) {\r\n                    if (legCount === insertIndex) {\r\n                        this.railroadWaypoints.splice(i, 0, waypoint);\r\n                        inserted = true;\r\n                        break;\r\n                    }\r\n                    legCount++;\r\n                }\r\n            }\r\n            if (!inserted) {\r\n                this.railroadWaypoints.push(waypoint);\r\n            }\r\n        } else {\r\n            this.railroadWaypoints.push(waypoint);\r\n        }\r\n        this.onManualDataChange?.();\r\n    }\r\n    public updateWaypointRegion(legIndex: number, waypointIndex: number, regionId: number): void {\r\n        const entries = this.railroadWaypoints.filter((w) => w.legIndex === legIndex);\r\n        if (waypointIndex < 0 || waypointIndex >= entries.length) return;\r\n        const globalIdx = this.railroadWaypoints.indexOf(entries[waypointIndex]!);\r\n        if (globalIdx >= 0) this.railroadWaypoints[globalIdx] = { legIndex, regionId };\r\n        this.onManualDataChange?.();\r\n    }\r\n    public removeWaypoint(legIndex: number, waypointIndex: number): void {\r\n        const entries = this.railroadWaypoints\r\n            .map((w, i) => ({ w, i }))\r\n            .filter(({ w }) => w.legIndex === legIndex);\r\n        if (waypointIndex < 0 || waypointIndex >= entries.length) return;\r\n        const globalIdx = entries[waypointIndex]!.i;\r\n        this.railroadWaypoints.splice(globalIdx, 1);\r\n        this.onManualDataChange?.();\r\n    }\r\n\r\n    private refreshZoneRendering() { this.chunkManager?.refreshZones(); }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\MapEditorDebugOverlay.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\MapEditorHistoryOverlay.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\MapEditorHosts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\MapEditorInput.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'PIXI' is defined but never used.","line":1,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":22,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"PIXI"},"fix":{"range":[0,37],"text":""},"desc":"Remove unused import declaration."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type * as PIXI from 'pixi.js';\nimport { Logger } from '@core/Logger';\nimport { screenToWorld, toCanvasCoords } from './MapEditorInputHandlers';\nimport { handleZoom as handleZoomViewport } from './MapEditorViewport';\nimport { updateCursorCoords } from './MapEditorUIOverlays';\nimport { updateBrushCursor } from './MapEditorBrushCursor';\nimport { executeTool } from './MapEditorToolUse';\nimport {\n    isWorldPointOnSplinePath,\n    SPLINE_HIT_THRESHOLD_WORLD,\n    getNearestLegIndexForWorldPoint,\n    getWaypointInsertionIndex\n} from './MapEditorRailroadUtils';\n\nimport { AddManualTownCommand } from './commands/AddManualTownCommand';\nimport { AddManualStationCommand } from './commands/AddManualStationCommand';\nimport { AddWaypointCommand } from './commands/AddWaypointCommand';\nimport { RemoveWaypointCommand } from './commands/RemoveWaypointCommand';\nimport { BatchObjectCommand } from './commands/BatchObjectCommand';\nimport type { MapEditorCore } from './MapEditorCore';\nimport type { ObjectAction } from './MapEditorState';\nimport type { ManualStation } from '../../world/MapDataService';\n\nexport interface InputState {\n    isDragging: boolean;\n    isPainting: boolean;\n    isSpacePressed: boolean;\n    lastMousePosition: { x: number; y: number };\n    currentObjectActions: ObjectAction[];\n}\n\nexport function setupInputListeners(\n    core: MapEditorCore,\n    state: InputState\n): { cleanup: () => void } {\n    const handleZoomBind = (e: WheelEvent) => handleZoom(e, core);\n    const handleMouseDownBind = (e: MouseEvent) => handleMouseDown(e, core, state);\n    const handleContextMenuBind = (e: MouseEvent) => handleContextMenu(e, core);\n    const handleMouseMoveBind = (e: MouseEvent) => handleMouseMove(e, core, state);\n    const handleMouseUpBind = (e: MouseEvent) => handleMouseUp(e, core, state);\n\n    const handleKeyDown = (e: KeyboardEvent) => {\n        if (e.code === 'Space') state.isSpacePressed = true;\n        if ((e.ctrlKey || e.metaKey) && e.code === 'KeyZ') {\n            e.preventDefault();\n            if (e.shiftKey) {\n                core.getCommandManager().redo();\n            } else {\n                core.getCommandManager().undo();\n            }\n        }\n        if ((e.ctrlKey || e.metaKey) && e.code === 'KeyY') {\n            e.preventDefault();\n            core.getCommandManager().redo();\n        }\n    };\n\n    const handleKeyUp = (e: KeyboardEvent) => {\n        if (e.code === 'Space') state.isSpacePressed = false;\n    };\n\n    const canvas = core.getApp()?.canvas;\n    if (canvas) {\n        canvas.addEventListener('wheel', handleZoomBind, { passive: false });\n        canvas.addEventListener('mousedown', handleMouseDownBind);\n        canvas.addEventListener('contextmenu', handleContextMenuBind);\n    }\n    window.addEventListener('mousemove', handleMouseMoveBind);\n    window.addEventListener('mouseup', handleMouseUpBind);\n    window.addEventListener('keydown', handleKeyDown);\n    window.addEventListener('keyup', handleKeyUp);\n\n    return {\n        cleanup: () => {\n            if (canvas) {\n                canvas.removeEventListener('wheel', handleZoomBind);\n                canvas.removeEventListener('mousedown', handleMouseDownBind);\n                canvas.removeEventListener('contextmenu', handleContextMenuBind);\n            }\n            window.removeEventListener('mousemove', handleMouseMoveBind);\n            window.removeEventListener('mouseup', handleMouseUpBind);\n            window.removeEventListener('keydown', handleKeyDown);\n            window.removeEventListener('keyup', handleKeyUp);\n        }\n    };\n}\n\nfunction handleZoom(e: WheelEvent, core: MapEditorCore): void {\n    const app = core.getApp();\n    const worldContainer = core.getWorldContainer();\n    if (!app || !worldContainer) return;\n\n    handleZoomViewport(e, {\n        app,\n        worldContainer,\n        zoom: core.getZoom(),\n        onZoomChange: (v) => core.setZoom(v),\n        onWorldContainerMove: (x, y) => {\n            worldContainer.x = x;\n            worldContainer.y = y;\n        },\n        onZoomUIUpdate: () => core.triggerZoomUIUpdate()\n    });\n}\n\nfunction handleMouseDown(e: MouseEvent, core: MapEditorCore, state: InputState): void {\n    const app = core.getApp();\n    const worldContainer = core.getWorldContainer();\n\n    if (e.button === 1 || (e.button === 0 && state.isSpacePressed && app)) {\n        state.isDragging = true;\n        const { x, y } = toCanvasCoords(e.clientX, e.clientY, app.canvas);\n        state.lastMousePosition = { x, y };\n    } else if (e.button === 0) {\n        const onNextClickAction = core.getOnNextClickAction();\n        if (onNextClickAction && app && worldContainer) {\n            const { worldX, worldY } = screenToWorld(e, app, worldContainer, core.getZoom());\n            core.clearOnNextClickAction();\n            onNextClickAction(worldX, worldY);\n            return;\n        }\n        if (core.getEditingMode() !== 'manipulation') state.isPainting = true;\n        useTool(e, core, state);\n    }\n}\n\nfunction handleMouseMove(e: MouseEvent, core: MapEditorCore, state: InputState): void {\n    const app = core.getApp();\n    const worldContainer = core.getWorldContainer();\n\n    if (state.isDragging && worldContainer && app) {\n        const { x, y } = toCanvasCoords(e.clientX, e.clientY, app.canvas);\n        const dx = x - state.lastMousePosition.x;\n        const dy = y - state.lastMousePosition.y;\n\n        worldContainer.x += dx;\n        worldContainer.y += dy;\n\n        state.lastMousePosition = { x, y };\n    }\n\n    if (state.isPainting) {\n        useTool(e, core, state);\n    }\n\n    if (worldContainer && app) {\n        const zoom = core.getZoom();\n        const { worldX, worldY } = screenToWorld(e, app, worldContainer, zoom);\n        updateCursorCoords(worldX, worldY);\n        const brushCursor = core.getBrushCursor();\n        if (brushCursor) {\n            updateBrushCursor({\n                brushCursor,\n                worldX,\n                worldY,\n                editingMode: core.getEditingMode(),\n                currentTool: core.getCurrentTool(),\n                brushSize: 1,\n                zoom,\n                shiftKey: e.shiftKey\n            });\n        }\n    }\n}\n\nfunction handleMouseUp(_e: MouseEvent, core: MapEditorCore, state: InputState): void {\n    state.isDragging = false;\n    state.isPainting = false;\n    if (state.currentObjectActions.length > 0) {\n        core.getCommandManager().record(\n            new BatchObjectCommand(core.getChunkManager()!, [...state.currentObjectActions])\n        );\n        state.currentObjectActions = [];\n        Logger.info('[MapEditor] Object Batch Recorded');\n    }\n}\n\nfunction handleContextMenu(e: MouseEvent, core: MapEditorCore): void {\n    e.preventDefault();\n    const app = core.getApp();\n    const worldContainer = core.getWorldContainer();\n    if (!app || !worldContainer) return;\n\n    const zoom = core.getZoom();\n    const { worldX, worldY } = screenToWorld(e, app, worldContainer, zoom);\n\n    const procCache = core.getProcCache();\n    const railroadWaypoints = core.getRailroadWaypoints();\n    const waypointManager = core.getWaypointManager();\n\n    const waypointAt = waypointManager.getWaypointHandleAtWorldCoords(\n        { procCache, railroadWaypoints },\n        worldX,\n        worldY\n    );\n\n    if (waypointAt !== null) {\n        showMenu(e.clientX, e.clientY, [\n            {\n                label: 'Remove spline waypoint',\n                action: () => {\n                    core.executeCommand(\n                        new RemoveWaypointCommand(\n                            core,\n                            waypointAt.legIndex,\n                            waypointAt.waypointIndex\n                        )\n                    );\n                    Logger.info('[MapEditor] Removed spline waypoint for leg', waypointAt.legIndex);\n                }\n            }\n        ]);\n        return;\n    }\n\n    const regionId = core.getRegionAtWorld(worldX, worldY);\n    if (regionId == null) return;\n\n    const items = [\n        {\n            label: 'Place town',\n            action: () => {\n                core.executeCommand(new AddManualTownCommand(core, regionId));\n                Logger.info('[MapEditor] Placed town at region', regionId);\n            }\n        },\n        {\n            label: 'Place station',\n            action: () => {\n                const manualStations = core.getManualStations();\n                const nextOrder =\n                    manualStations.reduce(\n                        (m: number, s: ManualStation) => Math.max(m, s.order),\n                        0\n                    ) + 1;\n                core.executeCommand(new AddManualStationCommand(core, regionId, nextOrder));\n                Logger.info('[MapEditor] Placed station', nextOrder, 'at region', regionId);\n            }\n        }\n    ];\n\n    if (isWorldPointOnSplinePath(procCache, worldX, worldY, SPLINE_HIT_THRESHOLD_WORLD)) {\n        const leg = getNearestLegIndexForWorldPoint(\n            procCache,\n            (wx, wy) => core.getRegionAtWorld(wx, wy),\n            worldX,\n            worldY\n        );\n        if (leg !== null) {\n            items.push({\n                label: 'Add spline point',\n                action: () => {\n                    const insertIndex = getWaypointInsertionIndex(\n                        procCache,\n                        leg,\n                        railroadWaypoints,\n                        worldX,\n                        worldY\n                    );\n                    core.executeCommand(new AddWaypointCommand(core, leg, regionId, insertIndex));\n                    Logger.info('[MapEditor] Added spline point (waypoint) for leg', leg);\n                }\n            });\n        }\n    }\n\n    showMenu(e.clientX, e.clientY, items);\n}\n\nfunction showMenu(x: number, y: number, items: { label: string; action: () => void }[]) {\n    const menu = document.createElement('div');\n    menu.style.cssText =\n        'position:fixed;background:#2d2d2d;border:1px solid #555;border-radius:6px;padding:4px 0;min-width:140px;z-index:10000;box-shadow:0 4px 12px rgba(0,0,0,0.4);';\n    menu.style.left = `${x}px`;\n    menu.style.top = `${y}px`;\n\n    items.forEach(({ label, action }) => {\n        const btn = document.createElement('button');\n        btn.type = 'button';\n        btn.textContent = label;\n        btn.style.cssText =\n            'display:block;width:100%;padding:8px 14px;border:none;background:transparent;color:#eee;text-align:left;cursor:pointer;font-size:13px;';\n        btn.addEventListener('mouseenter', () => {\n            btn.style.background = '#3d3d3d';\n        });\n        btn.addEventListener('mouseleave', () => {\n            btn.style.background = 'transparent';\n        });\n        btn.addEventListener('click', () => {\n            action();\n            menu.remove();\n        });\n        menu.appendChild(btn);\n    });\n\n    document.body.appendChild(menu);\n    const close = () => {\n        menu.remove();\n        document.removeEventListener('click', close);\n    };\n    requestAnimationFrame(() => document.addEventListener('click', close));\n}\n\nfunction useTool(e: MouseEvent, core: MapEditorCore, state: InputState): void {\n    const chunkManager = core.getChunkManager();\n    const worldContainer = core.getWorldContainer();\n    const app = core.getApp();\n\n    if (!chunkManager || !worldContainer || !app) return;\n    if (core.getEditingMode() === 'manipulation') return;\n\n    const { worldX, worldY } = screenToWorld(e, app, worldContainer, core.getZoom());\n\n    executeTool(\n        worldX,\n        worldY,\n        e,\n        {\n            currentTool: core.getCurrentTool(),\n            editingMode: core.getEditingMode(),\n            brushSize: 1,\n            selectedAsset: core.getSelectedAsset()\n        },\n        chunkManager,\n        core.getCommandManager(),\n        state.currentObjectActions,\n        {\n            onObjectAction: (action) => state.currentObjectActions.push(action)\n        }\n    );\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\MapEditorInputHandlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\MapEditorManipulationHandles.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'zoom' is assigned a value but never used.","line":37,"column":49,"nodeType":"Identifier","messageId":"unusedVar","endLine":37,"endColumn":53}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * MapEditorManipulationHandles\r\n *\r\n * Manipulation handles for towns and stations when mode is 'manipulation'.\r\n * Draggable circles; on drop, updates town/station region.\r\n */\r\nimport * as PIXI from 'pixi.js';\r\nimport type { ManualStation } from '../../world/MapDataService';\r\nimport type { ProceduralCache } from './MapEditorProceduralRenderer';\r\nimport { MESH_TO_WORLD, getRegionHandleRadiusWorld } from './MapEditorRailroadUtils';\r\nimport { screenToWorld } from './MapEditorInputHandlers';\r\n\r\nexport interface ManipulationHandlesHost {\r\n    procCache: ProceduralCache | null;\r\n    worldContainer: PIXI.Container | null;\r\n    app: PIXI.Application | null;\r\n    zoom: number;\r\n    manualTowns: number[];\r\n    manualStations: ManualStation[];\r\n    editingMode: string;\r\n    onSetTownAt: (index: number, regionId: number) => void;\r\n    onSetStationRegion: (index: number, regionId: number) => void;\r\n    getRegionAtWorld: (worldX: number, worldY: number) => number | null;\r\n}\r\n\r\nexport class MapEditorManipulationHandles {\r\n    private container: PIXI.Container | null = null;\r\n    private dragging: { type: 'town'; index: number } | { type: 'station'; index: number } | null =\r\n        null;\r\n    private host: ManipulationHandlesHost | null = null;\r\n    private lastKey = '';\r\n    private readonly boundPointerMove = (e: PointerEvent) => this.handlePointerMove(e);\r\n    private readonly boundPointerUp = () => this.handlePointerUp();\r\n\r\n    update(host: ManipulationHandlesHost): void {\r\n        this.host = host;\r\n        const { procCache, worldContainer, app, zoom, manualTowns, manualStations, editingMode } =\r\n            host;\r\n\r\n        if (!worldContainer || !app) return;\r\n        if (editingMode !== 'manipulation') {\r\n            if (this.container) this.container.visible = false;\r\n            this.lastKey = '';\r\n            return;\r\n        }\r\n        if (!procCache) {\r\n            if (this.container) this.container.visible = false;\r\n            this.lastKey = '';\r\n            return;\r\n        }\r\n\r\n        if (this.dragging) return;\r\n\r\n        const key = `manual-${manualTowns.join(',')}-${manualStations.map((s) => `${s.regionId}:${s.order}`).join(',')}`;\r\n        if (key === this.lastKey) return;\r\n        this.lastKey = key;\r\n\r\n        if (!this.container) {\r\n            this.container = new PIXI.Container();\r\n            this.container.zIndex = 1000;\r\n            this.container.eventMode = 'static';\r\n            worldContainer.addChild(this.container);\r\n        }\r\n        this.container.visible = true;\r\n        this.container.removeChildren().forEach((c) => c.destroy({ children: true }));\r\n\r\n        const mesh = procCache.meshAndMap.mesh;\r\n\r\n        const addHandle = (\r\n            worldX: number,\r\n            worldY: number,\r\n            radiusWorld: number,\r\n            fillColor: number,\r\n            type: 'town' | 'station',\r\n            index: number\r\n        ) => {\r\n            const g = new PIXI.Graphics();\r\n            g.circle(0, 0, radiusWorld);\r\n            g.fill({ color: fillColor, alpha: 0.9 });\r\n            g.stroke({ width: 2, color: 0xffffff });\r\n            g.position.set(worldX, worldY);\r\n            g.eventMode = 'static';\r\n            g.cursor = 'grab';\r\n            (g as unknown as { manipulationType: 'town' | 'station' }).manipulationType = type;\r\n            (g as unknown as { manipulationIndex: number }).manipulationIndex = index;\r\n            g.on('pointerdown', (e: PIXI.FederatedPointerEvent) => {\r\n                e.stopPropagation();\r\n                this.dragging = type === 'town' ? { type: 'town', index } : { type: 'station', index };\r\n                window.addEventListener('pointermove', this.boundPointerMove);\r\n                window.addEventListener('pointerup', this.boundPointerUp);\r\n            });\r\n            this.container!.addChild(g);\r\n        };\r\n\r\n        manualTowns.forEach((regionId, i) => {\r\n            const worldX = mesh.x_of_r(regionId) * MESH_TO_WORLD;\r\n            const worldY = mesh.y_of_r(regionId) * MESH_TO_WORLD;\r\n            const radiusWorld = getRegionHandleRadiusWorld(mesh, regionId);\r\n            addHandle(worldX, worldY, radiusWorld, 0x22aa44, 'town', i);\r\n        });\r\n        manualStations.forEach((s, i) => {\r\n            const worldX = mesh.x_of_r(s.regionId) * MESH_TO_WORLD;\r\n            const worldY = mesh.y_of_r(s.regionId) * MESH_TO_WORLD;\r\n            const radiusWorld = getRegionHandleRadiusWorld(mesh, s.regionId);\r\n            addHandle(worldX, worldY, radiusWorld, 0xffaa44, 'station', i);\r\n        });\r\n    }\r\n\r\n    private handlePointerMove(e: PointerEvent): void {\r\n        if (!this.dragging || !this.container) return;\r\n        const host = this.host;\r\n        if (!host?.app || !host?.worldContainer) return;\r\n        const { worldX, worldY } = screenToWorld(\r\n            e as unknown as MouseEvent,\r\n            host.app,\r\n            host.worldContainer,\r\n            host.zoom\r\n        );\r\n        const child = this.container.children.find((c) => {\r\n            const type = (c as unknown as { manipulationType: 'town' | 'station' }).manipulationType;\r\n            const index = (c as unknown as { manipulationIndex: number }).manipulationIndex;\r\n            return (\r\n                type === this.dragging!.type &&\r\n                index === (this.dragging as { type: 'town' | 'station'; index: number }).index\r\n            );\r\n        });\r\n        if (child) child.position.set(worldX, worldY);\r\n    }\r\n\r\n    private handlePointerUp(): void {\r\n        if (!this.dragging || !this.container) return;\r\n        const host = this.host;\r\n        if (!host?.app || !host?.worldContainer) return;\r\n        window.removeEventListener('pointermove', this.boundPointerMove);\r\n        window.removeEventListener('pointerup', this.boundPointerUp);\r\n        const child = this.container.children.find((c) => {\r\n            const type = (c as unknown as { manipulationType: 'town' | 'station' }).manipulationType;\r\n            const index = (c as unknown as { manipulationIndex: number }).manipulationIndex;\r\n            return (\r\n                type === this.dragging!.type &&\r\n                index === (this.dragging as { type: 'town' | 'station'; index: number }).index\r\n            );\r\n        });\r\n        const drag = this.dragging;\r\n        this.dragging = null;\r\n        if (child) {\r\n            const regionId = host.getRegionAtWorld(child.position.x, child.position.y);\r\n            if (regionId != null) {\r\n                if (drag.type === 'town') host.onSetTownAt(drag.index, regionId);\r\n                else host.onSetStationRegion(drag.index, regionId);\r\n            }\r\n        }\r\n    }\r\n\r\n    destroy(): void {\r\n        this.host = null;\r\n        this.container = null;\r\n        this.dragging = null;\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\MapEditorMount.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\MapEditorProceduralRenderer.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'buildMeshAndMap' is defined but never used.","line":16,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":16,"endColumn":25,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"buildMeshAndMap"},"fix":{"range":[713,729],"text":""},"desc":"Remove unused variable \"buildMeshAndMap\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'computeTownsAndRoads' is defined but never used.","line":16,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":16,"endColumn":47,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"computeTownsAndRoads"},"fix":{"range":[728,750],"text":""},"desc":"Remove unused variable \"computeTownsAndRoads\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'buildCellRegions' is defined but never used.","line":19,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":26,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"buildCellRegions"},"fix":{"range":[928,945],"text":""},"desc":"Remove unused variable \"buildCellRegions\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'computeRegionDistanceFromWater' is defined but never used.","line":19,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":58,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"computeRegionDistanceFromWater"},"fix":{"range":[919,1007],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'COAST_MAX_POLYGON_STEPS' is defined but never used.","line":20,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":20,"endColumn":33,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"COAST_MAX_POLYGON_STEPS"},"fix":{"range":[1009,1072],"text":""},"desc":"Remove unused import declaration."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * MapEditorProceduralRenderer  Unified canvas-based procedural map rendering.\r\n *\r\n * Main view and sidebar both use drawProceduralToCanvas (same code path).\r\n * Main view: draws current viewport to procedural canvas each frame when viewport changes.\r\n * Sidebar: draws full map (0..1000) to proc-preview-canvas.\r\n * Railroad meshes remain PIXI (in worldContainer) when enabled.\r\n */\r\n\r\nimport * as PIXI from 'pixi.js';\r\nimport { MapEditorConfig } from './MapEditorConfig';\r\nimport { AssetLoader } from '@core/AssetLoader';\r\nimport { drawCachedMeshToCanvas } from './Mapgen4PreviewRenderer';\r\nimport { Logger } from '@core/Logger';\r\nimport { createRailroadMeshes } from './RailroadMeshRenderer';\r\nimport { buildMeshAndMap, computeTownsAndRoads, type ManualTownsAndRailroads } from './Mapgen4Generator';\r\nimport type { Mapgen4Param } from './Mapgen4Param';\r\nimport type { MeshAndMap } from './Mapgen4Generator';\r\nimport { buildCellRegions, computeRegionDistanceFromWater } from './Mapgen4RegionUtils';\r\nimport { COAST_MAX_POLYGON_STEPS } from './Mapgen4ZoneMapping';\r\nimport { runMapgenWorker } from './MapgenWorkerClient';\r\n\r\nexport interface ProceduralCache {\r\n    meshAndMap: MeshAndMap;\r\n    param: Mapgen4Param;\r\n    towns: import('./Mapgen4Generator').TownSite[];\r\n    roadSegments: import('./Mapgen4Generator').RoadSegment[];\r\n    railroadPath: number[];\r\n    railroadCrossings: import('./Mapgen4Generator').RailroadCrossing[];\r\n    railroadStationIds: number[];\r\n    /** For worldregion hit-test (context menu, waypoints). */\r\n    cellRegions: number[][];\r\n    /** Cached BFS distance from water (region  distance); avoids per-frame recompute. */\r\n    distanceFromWater: Map<number, number>;\r\n}\r\n\r\nexport interface RailroadMeshState {\r\n    railroadMeshContainer: PIXI.Container | null;\r\n    railroadMeshes: PIXI.Mesh[];\r\n    cacheKey: string | null;\r\n}\r\n\r\n/** Compute viewport in mesh coords (0..1000) from world container and zoom. */\r\nexport function worldToMeshViewport(\r\n    worldContainer: PIXI.Container,\r\n    zoom: number,\r\n    canvasW: number,\r\n    canvasH: number\r\n): { vpX: number; vpY: number; vpW: number; vpH: number } {\r\n    const viewX = -worldContainer.x / zoom;\r\n    const viewY = -worldContainer.y / zoom;\r\n    const viewW = canvasW / zoom;\r\n    const viewH = canvasH / zoom;\r\n    const MESH_PER_WORLD = 1000 / (MapEditorConfig.WORLD_WIDTH_TILES * MapEditorConfig.TILE_SIZE);\r\n    return {\r\n        vpX: viewX * MESH_PER_WORLD,\r\n        vpY: viewY * MESH_PER_WORLD,\r\n        vpW: viewW * MESH_PER_WORLD,\r\n        vpH: viewH * MESH_PER_WORLD\r\n    };\r\n}\r\n\r\n/** Update railroad PIXI meshes when cache or visibility changes. */\r\nexport function updateRailroadMeshes(\r\n    cache: ProceduralCache,\r\n    worldContainer: PIXI.Container,\r\n    hiddenZoneIds: Set<string>,\r\n    prev: RailroadMeshState,\r\n    usePixiMesh = false\r\n): RailroadMeshState {\r\n    const visKey = [...hiddenZoneIds].sort().join(',');\r\n    const pathKey = cache.railroadPath.join(',');\r\n    const cacheKey = `${cache.param.meshSeed}|${visKey}|${pathKey}`;\r\n    const useRailroadMesh =\r\n        usePixiMesh && cache.param.railroads?.enabled && cache.railroadPath.length >= 2;\r\n\r\n    if (!useRailroadMesh) {\r\n        for (const m of prev.railroadMeshes) m.destroy();\r\n        if (prev.railroadMeshContainer) {\r\n            prev.railroadMeshContainer.destroy({ children: true });\r\n        }\r\n        return { railroadMeshContainer: null, railroadMeshes: [], cacheKey: null };\r\n    }\r\n\r\n    if (cacheKey === prev.cacheKey && prev.railroadMeshContainer) return prev;\r\n\r\n    let railroadMeshContainer = prev.railroadMeshContainer;\r\n    let railroadMeshes = prev.railroadMeshes;\r\n\r\n    if (!railroadMeshContainer) {\r\n        railroadMeshContainer = new PIXI.Container();\r\n        railroadMeshContainer.zIndex = -0.9;\r\n        worldContainer.addChild(railroadMeshContainer);\r\n    }\r\n    for (const m of railroadMeshes) m.destroy();\r\n    try {\r\n        railroadMeshes = createRailroadMeshes(\r\n            cache.meshAndMap.mesh,\r\n            cache.meshAndMap.map,\r\n            cache.railroadPath,\r\n            railroadMeshContainer,\r\n            cache.railroadStationIds\r\n        );\r\n    } catch (err) {\r\n        Logger.error('[MapEditorProceduralRenderer] createRailroadMeshes failed (possibly OOM)', err);\r\n        railroadMeshes = [];\r\n    }\r\n    return { railroadMeshContainer, railroadMeshes, cacheKey };\r\n}\r\n\r\n/** Build procedural cache from param. Preloads railroad assets when enabled. Optional manual data overrides procedural towns/stations/waypoints. */\r\nexport async function buildProceduralCache(\r\n    param: Mapgen4Param,\r\n    manual?: ManualTownsAndRailroads\r\n): Promise<ProceduralCache> {\r\n    const workerResult = await runMapgenWorker(param, manual);\r\n    const { mesh, map, townsAndRoads, cellRegions, distanceFromWater } = workerResult;\r\n    const meshAndMap = { mesh, map };\r\n    const { towns, roadSegments, railroadPath, railroadCrossings, railroadStationIds } = townsAndRoads;\r\n\r\n    if (param.railroads?.enabled && railroadPath.length >= 2) {\r\n        const preloads: Promise<unknown>[] = [];\r\n        for (const biome of ['grasslands', 'tundra', 'desert', 'badlands']) {\r\n            preloads.push(AssetLoader.preloadImage(`ground_base_gravel_${biome}_01`));\r\n            preloads.push(AssetLoader.preloadImage(`arch_railtrack_metal_${biome}_clean`));\r\n            preloads.push(AssetLoader.preloadImage(`arch_railtrack_wood_01_${biome}_clean`));\r\n            preloads.push(AssetLoader.preloadImage(`arch_railtrack_wood_02_${biome}_clean`));\r\n            preloads.push(AssetLoader.preloadImage(`arch_railtrack_wood_03_${biome}_clean`));\r\n        }\r\n        await Promise.all(preloads);\r\n    }\r\n\r\n    return {\r\n        meshAndMap,\r\n        param,\r\n        towns,\r\n        roadSegments,\r\n        railroadPath,\r\n        railroadCrossings,\r\n        railroadStationIds,\r\n        cellRegions,\r\n        distanceFromWater\r\n    };\r\n}\r\n\r\n/** Draw cached procedural map to canvas. Returns true if drawn. */\r\nexport function drawProceduralToCanvas(\r\n    cache: ProceduralCache,\r\n    canvas: HTMLCanvasElement,\r\n    viewport?: { x: number; y: number; width: number; height: number },\r\n    hiddenZoneIds?: Set<string>,\r\n    skipRailroad?: boolean\r\n): boolean {\r\n    const vpX = viewport?.x ?? 0;\r\n    const vpY = viewport?.y ?? 0;\r\n    const vpW = viewport?.width ?? 1000;\r\n    const vpH = viewport?.height ?? 1000;\r\n    drawCachedMeshToCanvas(\r\n        canvas,\r\n        cache.meshAndMap.mesh,\r\n        cache.meshAndMap.map,\r\n        cache.param,\r\n        vpX,\r\n        vpY,\r\n        vpW,\r\n        vpH,\r\n        cache.towns,\r\n        cache.roadSegments,\r\n        cache.railroadPath,\r\n        cache.railroadCrossings,\r\n        cache.railroadStationIds,\r\n        hiddenZoneIds ?? new Set(),\r\n        skipRailroad ?? false,\r\n        cache.distanceFromWater\r\n    );\r\n    return true;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\MapEditorRailroadUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\MapEditorRegistry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\MapEditorScaleReference.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\MapEditorState.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ZoneCategory' is defined but never used.","line":9,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":22,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"ZoneCategory"},"fix":{"range":[258,306],"text":""},"desc":"Remove unused import declaration."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * MapEditorState\r\n *\r\n * Holds mutable editing state for the Map Editor.\r\n * Editing mode, tool state, brush state, selection, and manual railroad data.\r\n * Pure data container; no PIXI or DOM.\r\n */\r\nimport type { MapObject } from './MapEditorTypes';\r\nimport { ZoneCategory } from '@data/ZoneConfig';\r\nimport type { ManualStation, RailroadWaypointEntry } from '../../world/MapDataService';\r\n\r\nexport type EditingMode = 'object' | 'manipulation';\r\nexport type CurrentTool = 'brush' | 'eraser' | 'select';\r\nexport type ObjectAction = { type: 'add' | 'remove'; x: number; y: number; assetId: string };\r\n\r\nexport class MapEditorState {\r\n    isInitialized = false;\r\n    currentTool: CurrentTool = 'brush';\r\n    currentLayer = 0;\r\n\r\n    editingMode: EditingMode = 'object';\r\n    brushSize = 1;\r\n    hiddenZoneIds = new Set<string>();\r\n\r\n    selectedAsset: { id: string; category: string } | null = null;\r\n    selectedObject: MapObject | null = null;\r\n\r\n    currentObjectActions: ObjectAction[] = [];\r\n\r\n    debugShowStationNumbers = false;\r\n    debugShowSplinePath = false;\r\n\r\n    manualTowns: number[] = [];\r\n    manualStations: ManualStation[] = [];\r\n    railroadWaypoints: RailroadWaypointEntry[] = [];\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\MapEditorToolUse.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Logger' is defined but never used.","line":4,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":16,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"Logger"},"fix":{"range":[77,115],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'TILE_SIZE' is assigned a value but never used.","line":32,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":32,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * MapEditorToolUse - Tool execution logic (ground, object, zone)\r\n */\r\nimport { Logger } from '@core/Logger';\r\nimport { MapEditorConfig } from './MapEditorConfig';\r\nimport { PlaceObjectCommand } from './commands/PlaceObjectCommand';\r\nimport { RemoveObjectCommand } from './commands/RemoveObjectCommand';\r\nimport type { ChunkManager } from './ChunkManager';\r\nimport type { CommandManager } from './commands/CommandManager';\r\n\r\nexport interface ToolUseState {\r\n    currentTool: string;\r\n    editingMode: 'object' | 'zone' | 'ground' | 'manipulation';\r\n    brushSize: number;\r\n    selectedAsset: { id: string; category: string } | null;\r\n}\r\n\r\nexport interface ToolUseCallbacks {\r\n    onObjectAction: (action: { type: 'add' | 'remove'; x: number; y: number; assetId: string }) => void;\r\n}\r\n\r\nexport function executeTool(\r\n    worldX: number,\r\n    worldY: number,\r\n    e: MouseEvent,\r\n    state: ToolUseState,\r\n    chunkManager: ChunkManager,\r\n    commandManager: CommandManager,\r\n    currentObjectActions: Array<{ type: 'add' | 'remove'; x: number; y: number; assetId: string }>,\r\n    callbacks: ToolUseCallbacks\r\n): void {\r\n    const { TILE_SIZE } = MapEditorConfig;\r\n\r\n    if (\r\n        state.currentTool === 'brush' &&\r\n        state.editingMode === 'object' &&\r\n        state.selectedAsset\r\n    ) {\r\n        const actionType = e.shiftKey ? 'remove' : 'add';\r\n\r\n        const existing = currentObjectActions.find(\r\n            (a) =>\r\n                Math.abs(a.x - worldX) < 1 &&\r\n                Math.abs(a.y - worldY) < 1 &&\r\n                a.type === actionType\r\n        );\r\n\r\n        if (!existing) {\r\n            let cmd;\r\n            if (actionType === 'add') {\r\n                cmd = new PlaceObjectCommand(chunkManager, worldX, worldY, state.selectedAsset.id);\r\n            } else {\r\n                // If removing, we need to know what asset was there to undo properly\r\n                const obj = chunkManager.getObjectAt(worldX, worldY);\r\n                if (obj) {\r\n                    cmd = new RemoveObjectCommand(chunkManager, worldX, worldY, obj.id);\r\n                } else {\r\n                    return; // Nothing to remove\r\n                }\r\n            }\r\n\r\n            commandManager.execute(cmd);\r\n\r\n            callbacks.onObjectAction({\r\n                type: actionType,\r\n                x: worldX,\r\n                y: worldY,\r\n                assetId: state.selectedAsset.id\r\n            });\r\n        }\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\MapEditorTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\MapEditorUIOverlays.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\MapEditorUpdate.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\MapEditorViewport.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'PIXI' is defined but never used.","line":7,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":22,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"PIXI"},"fix":{"range":[170,207],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'MapEditorConfig' is defined but never used.","line":8,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":25,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"MapEditorConfig"},"fix":{"range":[209,261],"text":""},"desc":"Remove unused import declaration."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * MapEditorViewport\r\n *\r\n * Viewport and zoom state. Handles pan, zoom, screen-to-world conversion.\r\n * No PIXI rendering; operates on container coordinates.\r\n */\r\nimport type * as PIXI from 'pixi.js';\r\nimport { MapEditorConfig } from './MapEditorConfig';\r\nimport { handleZoom as handleZoomImpl, screenToWorld, toCanvasCoords } from './MapEditorInputHandlers';\r\nimport { computeZoomReset } from './MapEditorZoomReset';\r\n\r\nexport interface ViewportHost {\r\n    app: { canvas: HTMLCanvasElement } | null;\r\n    worldContainer: { x: number; y: number; scale: { set: (v: number) => void } } | null;\r\n    zoom: number;\r\n    onZoomChange: (v: number) => void;\r\n    onWorldContainerMove: (x: number, y: number) => void;\r\n    onZoomUIUpdate: () => void;\r\n}\r\n\r\nexport function handleZoom(e: WheelEvent, host: ViewportHost): void {\r\n    handleZoomImpl(\r\n        e,\r\n        host.app!,\r\n        host.worldContainer,\r\n        host.zoom,\r\n        (v) => host.onZoomChange(v),\r\n        (x, y) => host.onWorldContainerMove(x, y),\r\n        host.onZoomUIUpdate\r\n    );\r\n}\r\n\r\nexport function screenToWorldCoords(\r\n    e: MouseEvent,\r\n    app: { canvas: HTMLCanvasElement },\r\n    worldContainer: { x: number; y: number },\r\n    zoom: number\r\n): { worldX: number; worldY: number } {\r\n    return screenToWorld(e, app, worldContainer, zoom);\r\n}\r\n\r\nexport { toCanvasCoords };\r\n\r\nexport function getViewportWorldRect(\r\n    app: { canvas: HTMLCanvasElement } | null,\r\n    worldContainer: { x: number; y: number } | null,\r\n    zoom: number\r\n): { x: number; y: number; width: number; height: number } | null {\r\n    if (!app || !worldContainer) return null;\r\n    const w = app.canvas.width / zoom;\r\n    const h = app.canvas.height / zoom;\r\n    return {\r\n        x: -worldContainer.x / zoom,\r\n        y: -worldContainer.y / zoom,\r\n        width: w,\r\n        height: h\r\n    };\r\n}\r\n\r\nexport function centerViewOn(\r\n    app: { canvas: HTMLCanvasElement },\r\n    worldContainer: { x: number; y: number },\r\n    zoom: number,\r\n    worldX: number,\r\n    worldY: number\r\n): void {\r\n    const cx = app.canvas.width / 2;\r\n    const cy = app.canvas.height / 2;\r\n    worldContainer.x = cx - worldX * zoom;\r\n    worldContainer.y = cy - worldY * zoom;\r\n}\r\n\r\nexport function resetZoomToGame(params: {\r\n    canvasWidth: number;\r\n    canvasHeight: number;\r\n    worldContainer: { x: number; y: number; scale: { set: (v: number) => void } };\r\n    zoom: number;\r\n}): { zoom: number; worldX: number; worldY: number } {\r\n    return computeZoomReset(params);\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\MapEditorWaypointManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'zoom' is assigned a value but never used.","line":45,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":45,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'onRemoveWaypoint' is assigned a value but never used.","line":51,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":51,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'onUpdateWaypointRegion' is assigned a value but never used.","line":52,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":52,"endColumn":35},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getRegionAtWorld' is assigned a value but never used.","line":53,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":53,"endColumn":29}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * MapEditorWaypointManager\r\n *\r\n * Waypoint handle overlay: blue midpoints, orange draggable waypoints.\r\n * Right-click waypoint to remove; add via context menu on spline path.\r\n */\r\nimport * as PIXI from 'pixi.js';\r\nimport type { RailroadWaypointEntry } from '../../world/MapDataService';\r\nimport type { ProceduralCache } from './MapEditorProceduralRenderer';\r\nimport { MESH_TO_WORLD, getRegionHandleRadiusWorld } from './MapEditorRailroadUtils';\r\nimport { screenToWorld } from './MapEditorInputHandlers';\r\n\r\nexport interface WaypointManagerHost {\r\n    procCache: ProceduralCache | null;\r\n    worldContainer: PIXI.Container | null;\r\n    app: PIXI.Application | null;\r\n    zoom: number;\r\n    manualStations: { regionId: number; order: number }[];\r\n    railroadWaypoints: RailroadWaypointEntry[];\r\n    editingMode: string;\r\n    debugShowStationNumbers: boolean;\r\n    debugShowSplinePath: boolean;\r\n    onRemoveWaypoint: (legIndex: number, waypointIndex: number) => void;\r\n    onUpdateWaypointRegion: (legIndex: number, waypointIndex: number, regionId: number) => void;\r\n    getRegionAtWorld: (worldX: number, worldY: number) => number | null;\r\n}\r\n\r\nexport class MapEditorWaypointManager {\r\n    private container: PIXI.Container | null = null;\r\n    private dragging: { legIndex: number; waypointIndex: number } | null = null;\r\n    private host: WaypointManagerHost | null = null;\r\n    private lastKey: string = '';\r\n    private readonly boundPointerMove = (e: PointerEvent) => this.handlePointerMove(e);\r\n    private readonly boundPointerUp = () => this.handlePointerUp();\r\n    /** Reused to avoid per-frame allocation. */\r\n    private readonly waypointsByLeg = new Map<number, { regionId: number; waypointIndex: number }[]>();\r\n\r\n    update(host: WaypointManagerHost): void {\r\n        this.host = host;\r\n        if (this.dragging) return;\r\n        const {\r\n            procCache,\r\n            worldContainer,\r\n            app,\r\n            zoom,\r\n            manualStations,\r\n            railroadWaypoints,\r\n            editingMode,\r\n            debugShowStationNumbers,\r\n            debugShowSplinePath,\r\n            onRemoveWaypoint,\r\n            onUpdateWaypointRegion,\r\n            getRegionAtWorld\r\n        } = host;\r\n\r\n        if (!worldContainer || !app) return;\r\n        const show =\r\n            manualStations.length >= 2 &&\r\n            procCache &&\r\n            procCache.railroadStationIds.length >= 2 &&\r\n            (editingMode !== 'manipulation' || debugShowStationNumbers || debugShowSplinePath);\r\n\r\n        if (!show) {\r\n            if (this.container) this.container.visible = false;\r\n            this.lastKey = '';\r\n            return;\r\n        }\r\n\r\n        const key = `${editingMode}|${debugShowStationNumbers}|${debugShowSplinePath}|${procCache!.railroadStationIds.join(',')}|${railroadWaypoints.map(w => w.regionId).join(',')}`;\r\n        if (this.lastKey === key && this.container?.visible) return;\r\n        this.lastKey = key;\r\n\r\n        if (!this.container) {\r\n            this.container = new PIXI.Container();\r\n            this.container.zIndex = 1000;\r\n            this.container.eventMode = 'static';\r\n            worldContainer.addChild(this.container);\r\n        }\r\n        this.container.visible = true;\r\n        this.container.removeChildren().forEach((c) => c.destroy({ children: true }));\r\n\r\n        const mesh = procCache!.meshAndMap.mesh;\r\n        const stationIds = procCache!.railroadStationIds;\r\n        const n = stationIds.length;\r\n\r\n        for (let legIndex = 0; legIndex < n; legIndex++) {\r\n            const fromR = stationIds[legIndex]!;\r\n            const toR = stationIds[(legIndex + 1) % n]!;\r\n            const mx = (mesh.x_of_r(fromR) + mesh.x_of_r(toR)) / 2;\r\n            const my = (mesh.y_of_r(fromR) + mesh.y_of_r(toR)) / 2;\r\n            const worldX = mx * MESH_TO_WORLD;\r\n            const worldY = my * MESH_TO_WORLD;\r\n            const radiusWorld = Math.min(\r\n                getRegionHandleRadiusWorld(mesh, fromR),\r\n                getRegionHandleRadiusWorld(mesh, toR)\r\n            );\r\n            const midCircle = new PIXI.Graphics();\r\n            midCircle.circle(0, 0, radiusWorld);\r\n            midCircle.fill({ color: 0x4488ff, alpha: 0.7 });\r\n            midCircle.stroke({ width: 2, color: 0xffffff });\r\n            midCircle.position.set(worldX, worldY);\r\n            midCircle.eventMode = 'none';\r\n            this.container.addChild(midCircle);\r\n        }\r\n\r\n        this.waypointsByLeg.clear();\r\n        for (const w of railroadWaypoints) {\r\n            const list = this.waypointsByLeg.get(w.legIndex) ?? [];\r\n            list.push({ regionId: w.regionId, waypointIndex: list.length });\r\n            this.waypointsByLeg.set(w.legIndex, list);\r\n        }\r\n        this.waypointsByLeg.forEach((list, legIndex) => {\r\n            list.forEach(({ regionId, waypointIndex }) => {\r\n                const wx = mesh.x_of_r(regionId) * MESH_TO_WORLD;\r\n                const wy = mesh.y_of_r(regionId) * MESH_TO_WORLD;\r\n                const radiusWorld = getRegionHandleRadiusWorld(mesh, regionId);\r\n                const g = new PIXI.Graphics();\r\n                g.circle(0, 0, radiusWorld);\r\n                g.fill({ color: 0xffaa44, alpha: 0.9 });\r\n                g.stroke({ width: 2, color: 0xffffff });\r\n                g.position.set(wx, wy);\r\n                g.eventMode = 'static';\r\n                g.cursor = 'grab';\r\n                (g as unknown as { legIndex: number; waypointIndex: number }).legIndex = legIndex;\r\n                (g as unknown as { waypointIndex: number }).waypointIndex = waypointIndex;\r\n                g.on('pointerdown', (e: PIXI.FederatedPointerEvent) => {\r\n                    e.stopPropagation();\r\n                    this.dragging = { legIndex, waypointIndex };\r\n                    window.addEventListener('pointermove', this.boundPointerMove);\r\n                    window.addEventListener('pointerup', this.boundPointerUp);\r\n                });\r\n                this.container!.addChild(g);\r\n            });\r\n        });\r\n    }\r\n\r\n    /** Returns { legIndex, waypointIndex } if (worldX, worldY) is inside an orange waypoint handle. */\r\n    getWaypointHandleAtWorldCoords(\r\n        host: Pick<WaypointManagerHost, 'procCache' | 'railroadWaypoints'>,\r\n        worldX: number,\r\n        worldY: number\r\n    ): { legIndex: number; waypointIndex: number } | null {\r\n        const { procCache, railroadWaypoints } = host;\r\n        if (!procCache || railroadWaypoints.length === 0) return null;\r\n        const mesh = procCache.meshAndMap.mesh;\r\n        this.waypointsByLeg.clear();\r\n        for (const w of railroadWaypoints) {\r\n            const list = this.waypointsByLeg.get(w.legIndex) ?? [];\r\n            list.push({ regionId: w.regionId, waypointIndex: list.length });\r\n            this.waypointsByLeg.set(w.legIndex, list);\r\n        }\r\n        for (const [legIndex, list] of this.waypointsByLeg) {\r\n            for (const { regionId, waypointIndex } of list) {\r\n                const wx = mesh.x_of_r(regionId) * MESH_TO_WORLD;\r\n                const wy = mesh.y_of_r(regionId) * MESH_TO_WORLD;\r\n                const r = getRegionHandleRadiusWorld(mesh, regionId);\r\n                const dSq = (worldX - wx) ** 2 + (worldY - wy) ** 2;\r\n                if (dSq <= r * r) return { legIndex, waypointIndex };\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private handlePointerMove(e: PointerEvent): void {\r\n        if (!this.dragging || !this.container) return;\r\n        const host = this.host;\r\n        if (!host?.app || !host?.worldContainer) return;\r\n        const { worldX, worldY } = screenToWorld(\r\n            e as unknown as MouseEvent,\r\n            host.app,\r\n            host.worldContainer,\r\n            host.zoom\r\n        );\r\n        const child = this.container.children.find((c) => {\r\n            const d = c as unknown as { legIndex: number; waypointIndex: number };\r\n            return (\r\n                d.legIndex === this.dragging!.legIndex &&\r\n                d.waypointIndex === this.dragging!.waypointIndex\r\n            );\r\n        });\r\n        if (child) child.position.set(worldX, worldY);\r\n    }\r\n\r\n    private handlePointerUp(): void {\r\n        if (!this.dragging || !this.container) return;\r\n        const host = this.host;\r\n        if (!host?.app || !host?.worldContainer) return;\r\n        window.removeEventListener('pointermove', this.boundPointerMove);\r\n        window.removeEventListener('pointerup', this.boundPointerUp);\r\n        const child = this.container.children.find((c) => {\r\n            const d = c as unknown as { legIndex: number; waypointIndex: number };\r\n            return (\r\n                d.legIndex === this.dragging!.legIndex &&\r\n                d.waypointIndex === this.dragging!.waypointIndex\r\n            );\r\n        });\r\n        const regionId = child ? host.getRegionAtWorld(child.position.x, child.position.y) : null;\r\n        if (regionId != null) {\r\n            host.onUpdateWaypointRegion(\r\n                this.dragging.legIndex,\r\n                this.dragging.waypointIndex,\r\n                regionId\r\n            );\r\n        }\r\n        this.dragging = null;\r\n    }\r\n\r\n    destroy(): void {\r\n        this.host = null;\r\n        this.container = null;\r\n        this.dragging = null;\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\MapEditorZoomReset.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\MapRenderer.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'MapEditorConfig' is defined but never used.","line":3,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":25,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"MapEditorConfig"},"fix":{"range":[36,88],"text":""},"desc":"Remove unused import declaration."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport * as PIXI from 'pixi.js';\r\nimport { MapEditorConfig } from './MapEditorConfig';\r\n\r\n/**\r\n * MapRenderer  Placeholder for future map data rendering via PixiJS.\r\n * Map editor currently uses ChunkManager + GroundSystem + ObjectSystem directly.\r\n */\r\nexport class MapRenderer {\r\n    private stage: PIXI.Container;\r\n\r\n    constructor(stage: PIXI.Container) {\r\n        this.stage = stage;\r\n    }\r\n\r\n    // Future methods:\r\n    // renderTile(chunk, x, y, assetId)\r\n    // renderObject(chunk, x, y, assetId)\r\n    // refreshChunk(chunk)\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\Mapgen4BiomeConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\Mapgen4CurveUtils.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'loop2Len' is assigned a value but never used.","line":224,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":224,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'i' is defined but never used. Allowed unused args must match /^_/u.","line":289,"column":38,"nodeType":"Identifier","messageId":"unusedVar","endLine":289,"endColumn":39}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Mapgen4CurveUtils  Path manipulations (curves, loop fixers, smoothing)\r\n */\r\n\r\n/**\r\n * Insert intermediate waypoints with gentle perpendicular offset for train-track-like curves.\r\n * Real tracks don't have sharp corners; they use gradual arcs. This adds 12 points per segment\r\n * with a small outward bulge (away from centroid for closed loops).\r\n */\r\nexport function insertGentleCurveWaypoints(\r\n    points: { x: number; y: number }[],\r\n    isClosed: boolean,\r\n    offsetFactor = 0.08\r\n): { x: number; y: number }[] {\r\n    const n = points.length;\r\n    if (n < 2) return points;\r\n\r\n    let cx = 0;\r\n    let cy = 0;\r\n    for (const pt of points) {\r\n        cx += pt.x;\r\n        cy += pt.y;\r\n    }\r\n    cx /= n;\r\n    cy /= n;\r\n\r\n    const result: { x: number; y: number }[] = [];\r\n    const count = isClosed ? n : n - 1;\r\n\r\n    for (let i = 0; i < count; i++) {\r\n        const a = points[i];\r\n        const b = points[(i + 1) % n];\r\n        result.push({ x: a.x, y: a.y });\r\n\r\n        const dx = b.x - a.x;\r\n        const dy = b.y - a.y;\r\n        const segLen = Math.hypot(dx, dy) || 1e-10;\r\n        const ux = dx / segLen;\r\n        const uy = dy / segLen;\r\n        const perpX = -uy;\r\n        const perpY = ux;\r\n\r\n        const midX = (a.x + b.x) / 2;\r\n        const midY = (a.y + b.y) / 2;\r\n        const toCentroidX = cx - midX;\r\n        const toCentroidY = cy - midY;\r\n        const outward = perpX * toCentroidX + perpY * toCentroidY < 0;\r\n        const sign = outward ? 1 : -1;\r\n\r\n        const offset = segLen * offsetFactor * sign;\r\n        const m1 = {\r\n            x: midX + perpX * offset * 0.6,\r\n            y: midY + perpY * offset * 0.6\r\n        };\r\n        result.push(m1);\r\n    }\r\n\r\n    if (!isClosed) result.push({ x: points[n - 1].x, y: points[n - 1].y });\r\n    return result;\r\n}\r\n\r\n/** Cos threshold: below this, corner is sharp and gets arc waypoints. cos=0.7  45. */\r\nconst ARC_CORNER_COS_THRESHOLD = 0.7;\r\n\r\n/** Default arc radius in mesh units for railroad curves. */\r\nconst DEFAULT_ARC_RADIUS_MESH = 20;\r\n\r\n/**\r\n * Insert arc waypoints at sharp corners. Replaces sharp vertices with 23 points along a circular arc.\r\n * Produces wide, gradual curves instead of sharp angles.\r\n */\r\nexport function insertArcWaypointsAtCorners(\r\n    points: { x: number; y: number }[],\r\n    isClosed: boolean,\r\n    minRadiusMesh = DEFAULT_ARC_RADIUS_MESH,\r\n    preserveIndices?: Set<number>\r\n): { x: number; y: number }[] {\r\n    const n = points.length;\r\n    if (n < 3) return points;\r\n\r\n    const result: { x: number; y: number }[] = [];\r\n    const p = (i: number) => points[((i % n) + n) % n];\r\n    const start = isClosed ? 0 : 1;\r\n    const end = isClosed ? n : n - 1;\r\n\r\n    if (!isClosed) result.push({ x: points[0].x, y: points[0].y });\r\n\r\n    for (let i = start; i < end; i++) {\r\n        const p1 = p(i);\r\n\r\n        if (preserveIndices?.has(i)) {\r\n            result.push({ x: p1.x, y: p1.y });\r\n            continue;\r\n        }\r\n\r\n        const p0 = p(i - 1);\r\n        const p2 = p(i + 1);\r\n\r\n        const v1x = p1.x - p0.x;\r\n        const v1y = p1.y - p0.y;\r\n        const v2x = p2.x - p1.x;\r\n        const v2y = p2.y - p1.y;\r\n        const len1 = Math.hypot(v1x, v1y) || 1e-10;\r\n        const len2 = Math.hypot(v2x, v2y) || 1e-10;\r\n        const d1x = v1x / len1;\r\n        const d1y = v1y / len1;\r\n        const d2x = v2x / len2;\r\n        const d2y = v2y / len2;\r\n        const cos = d1x * d2x + d1y * d2y;\r\n\r\n        if (cos >= ARC_CORNER_COS_THRESHOLD) {\r\n            result.push({ x: p1.x, y: p1.y });\r\n            continue;\r\n        }\r\n\r\n        const theta = Math.acos(Math.max(-1, Math.min(1, cos)));\r\n        const halfAngle = theta / 2;\r\n        if (halfAngle < 0.01 || halfAngle > Math.PI / 2 - 0.01) {\r\n            result.push({ x: p1.x, y: p1.y });\r\n            continue;\r\n        }\r\n\r\n        const tanHalf = Math.tan(halfAngle);\r\n        let distAlong = minRadiusMesh / tanHalf;\r\n        // Clamp so arc does not extend past segment midpoints  prevents curling into itself at sharp turns\r\n        const maxDistAlong = Math.min(len1, len2) * 0.45;\r\n        distAlong = Math.min(distAlong, maxDistAlong);\r\n        if (distAlong < 1) {\r\n            result.push({ x: p1.x, y: p1.y });\r\n            continue;\r\n        }\r\n        const effectiveRadius = distAlong * tanHalf;\r\n        const a = { x: p1.x - d1x * distAlong, y: p1.y - d1y * distAlong };\r\n        const b = { x: p1.x + d2x * distAlong, y: p1.y + d2y * distAlong };\r\n\r\n        const bisectorX = d1x + d2x;\r\n        const bisectorY = d1y + d2y;\r\n        const bisectorLen = Math.hypot(bisectorX, bisectorY) || 1e-10;\r\n        const bx = bisectorX / bisectorLen;\r\n        const by = bisectorY / bisectorLen;\r\n        const distToCenter = effectiveRadius / Math.sin(halfAngle);\r\n        const cx = p1.x + bx * distToCenter;\r\n        const cy = p1.y + by * distToCenter;\r\n\r\n        const angleA = Math.atan2(a.y - cy, a.x - cx);\r\n        const angleB = Math.atan2(b.y - cy, b.x - cx);\r\n        let dAngle = angleB - angleA;\r\n        if (dAngle > Math.PI) dAngle -= 2 * Math.PI;\r\n        if (dAngle < -Math.PI) dAngle += 2 * Math.PI;\r\n\r\n        result.push(a);\r\n        for (let k = 1; k < 3; k++) {\r\n            const t = k / 3;\r\n            const angle = angleA + t * dAngle;\r\n            result.push({\r\n                x: cx + effectiveRadius * Math.cos(angle),\r\n                y: cy + effectiveRadius * Math.sin(angle)\r\n            });\r\n        }\r\n        result.push(b);\r\n    }\r\n\r\n    if (!isClosed) result.push({ x: points[n - 1].x, y: points[n - 1].y });\r\n    return result;\r\n}\r\n\r\n/**\r\n * Remove self-intersections from a closed path. When two non-adjacent segments cross,\r\n * removes the smaller loop. Prefers removing the loop that does NOT contain preserved indices (stations).\r\n * preserveIndices: indices in points that are stations  we keep the loop that contains them.\r\n */\r\nexport function removeSelfIntersections(\r\n    points: { x: number; y: number }[],\r\n    isClosed: boolean,\r\n    preserveIndices?: Set<number>\r\n): { x: number; y: number }[] {\r\n    const n = points.length;\r\n    if (n < 4) return points;\r\n    if (!isClosed) return points;\r\n\r\n    const eps = 1e-9;\r\n\r\n    function segmentsIntersect(\r\n        a: { x: number; y: number },\r\n        b: { x: number; y: number },\r\n        c: { x: number; y: number },\r\n        d: { x: number; y: number }\r\n    ): boolean {\r\n        const denom = (b.x - a.x) * (d.y - c.y) - (b.y - a.y) * (d.x - c.x);\r\n        if (Math.abs(denom) < eps) return false;\r\n        const t = ((c.x - a.x) * (d.y - c.y) - (c.y - a.y) * (d.x - c.x)) / denom;\r\n        const s = ((c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x)) / denom;\r\n        return t > eps && t < 1 - eps && s > eps && s < 1 - eps;\r\n    }\r\n\r\n    function segmentsAdjacent(i: number, j: number, len: number): boolean {\r\n        return (i + 1) % len === j || (j + 1) % len === i;\r\n    }\r\n\r\n    function countPreservedInLoop(loopIndices: number[]): number {\r\n        if (!preserveIndices || preserveIndices.size === 0) return 0;\r\n        return loopIndices.filter((idx) => preserveIndices!.has(idx)).length;\r\n    }\r\n\r\n    let current = points.slice();\r\n    let preserved = preserveIndices ? new Set(preserveIndices) : undefined;\r\n    let changed = true;\r\n\r\n    while (changed) {\r\n        changed = false;\r\n        const m = current.length;\r\n        if (m < 4) break;\r\n\r\n        for (let i = 0; i < m && !changed; i++) {\r\n            const a = current[i]!;\r\n            const b = current[(i + 1) % m]!;\r\n            for (let j = i + 2; j < m && !changed; j++) {\r\n                if (segmentsAdjacent(i, j, m)) continue;\r\n                const c = current[j]!;\r\n                const d = current[(j + 1) % m]!;\r\n                if (!segmentsIntersect(a, b, c, d)) continue;\r\n\r\n                const loop1Len = j - i;\r\n                const loop2Len = m - j + i;\r\n                const loop1Indices = Array.from({ length: loop1Len }, (_, k) => i + 1 + k);\r\n                const loop2Indices = [\r\n                    ...Array.from({ length: m - j - 1 }, (_, k) => j + 1 + k),\r\n                    ...Array.from({ length: i + 1 }, (_, k) => k)\r\n                ];\r\n                const preserved1 = preserved ? countPreservedInLoop(loop1Indices) : 0;\r\n                const preserved2 = preserved ? countPreservedInLoop(loop2Indices) : 0;\r\n\r\n                if (preserved1 > 0 && preserved2 > 0) {\r\n                    continue;\r\n                }\r\n\r\n                let removeFirst: boolean;\r\n                if (preserved1 > preserved2) {\r\n                    removeFirst = true;\r\n                } else if (preserved2 > preserved1) {\r\n                    removeFirst = false;\r\n                } else {\r\n                    removeFirst = loop1Indices.length <= loop2Indices.length;\r\n                }\r\n\r\n                if (removeFirst) {\r\n                    current = [...current.slice(0, i + 1), ...current.slice(j + 1)];\r\n                    if (preserved) {\r\n                        preserved = new Set(\r\n                            [...preserved]\r\n                                .filter((idx) => idx <= i || idx > j)\r\n                                .map((idx) => (idx > j ? idx - (j - i) : idx))\r\n                        );\r\n                    }\r\n                } else {\r\n                    current = current.slice(i + 1, j + 1);\r\n                    if (preserved) {\r\n                        preserved = new Set(\r\n                            [...preserved].filter((idx) => idx > i && idx <= j).map((idx) => idx - (i + 1))\r\n                        );\r\n                    }\r\n                }\r\n                changed = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    return current.length >= 3 ? current : points;\r\n}\r\n\r\n/**\r\n * Smooth a path by moving each point toward its neighbors (Laplacian smoothing).\r\n * Reduces jaggedness from polygon-by-polygon placement. iterations=23, lambda=0.5.\r\n * fixedIndices: indices that stay fixed (e.g. station points).\r\n */\r\nexport function smoothPath(\r\n    points: { x: number; y: number }[],\r\n    isClosed: boolean,\r\n    iterations = 3,\r\n    lambda = 0.5,\r\n    fixedIndices?: Set<number>\r\n): { x: number; y: number }[] {\r\n    const n = points.length;\r\n    if (n < 3) return points;\r\n\r\n    let current = points.map((p) => ({ x: p.x, y: p.y }));\r\n\r\n    for (let iter = 0; iter < iterations; iter++) {\r\n        const next = current.map((p, i) => ({ x: p.x, y: p.y }));\r\n        const prev = (i: number) => current[(i - 1 + n) % n]!;\r\n        const succ = (i: number) => current[(i + 1) % n]!;\r\n\r\n        for (let i = 0; i < n; i++) {\r\n            if (fixedIndices?.has(i)) continue;\r\n            const p = current[i]!;\r\n            const pPrev = prev(i);\r\n            const pSucc = succ(i);\r\n            const midX = (pPrev.x + pSucc.x) / 2;\r\n            const midY = (pPrev.y + pSucc.y) / 2;\r\n            next[i] = {\r\n                x: (1 - lambda) * p.x + lambda * midX,\r\n                y: (1 - lambda) * p.y + lambda * midY\r\n            };\r\n        }\r\n        current = next;\r\n    }\r\n\r\n    return current;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\Mapgen4Generator.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'buildRailroadSplineMeshData' is defined but never used.","line":23,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":23,"endColumn":37,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"buildRailroadSplineMeshData"},"fix":{"range":[918,988],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'PREVIEW_MAP_SIZE' is assigned a value but never used.","line":37,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":37,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'railroadPath' is assigned a value but never used.","line":149,"column":34,"nodeType":"Identifier","messageId":"unusedVar","endLine":149,"endColumn":46}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Mapgen4Generator  Run mapgen4 and rasterize to editor ChunkData.\r\n * Orchestrates mesh building, towns/roads/railroads, preview, and rasterization.\r\n */\r\n\r\nimport { Logger } from '@core/Logger';\r\nimport { MapEditorConfig } from './MapEditorConfig';\r\nimport type { ChunkData } from './MapEditorTypes';\r\nimport { buildMesh, makeDefaultConstraints } from './mapgen4/buildMesh';\r\nimport Mapgen4Map from './mapgen4/map';\r\nimport type { MapConstraints } from './mapgen4/map';\r\nimport type { Mesh } from './mapgen4/types';\r\nimport { runRoadGenerator } from './RoadGenerator';\r\nimport { runRailroadGenerator } from './RailroadGenerator';\r\nimport {\r\n    buildCellRegions,\r\n    findRegionAt,\r\n    MAPGEN4_MAP_SIZE,\r\n    computeRegionDistanceFromWater\r\n} from './Mapgen4RegionUtils';\r\nimport { mapgen4ToZones, COAST_MAX_POLYGON_STEPS } from './Mapgen4ZoneMapping';\r\nimport { isTileOnRiver } from './Mapgen4RiverUtils';\r\nimport { buildRailroadSplineMeshData } from './RailroadSplineBuilder';\r\n\r\nimport type { Mapgen4Param } from './Mapgen4Param';\r\nexport type { TownSite, RoadSegment, RailroadCrossing, Mapgen4Param } from './Mapgen4Param';\r\nexport type { TownsParam, RoadsParam, RailroadsParam } from './Mapgen4Param';\r\n\r\nexport { buildRailroadSplineMeshData } from './RailroadSplineBuilder';\r\nexport { mapgen4ToZones } from './Mapgen4ZoneMapping';\r\n\r\nexport interface MeshAndMap {\r\n    mesh: Mesh;\r\n    map: Mapgen4Map;\r\n}\r\n\r\nconst PREVIEW_MAP_SIZE = 1000;\r\n\r\n/** Build mesh + map from params (expensive). Call once when params change. */\r\nexport function buildMeshAndMap(param: Mapgen4Param): MeshAndMap {\r\n    const { mesh, t_peaks } = buildMesh(param.meshSeed, param.spacing, param.mountainSpacing);\r\n    const constraints: MapConstraints = makeDefaultConstraints(\r\n        param.elevation.seed,\r\n        param.elevation.island\r\n    );\r\n    const map = new Mapgen4Map(mesh, t_peaks, { spacing: param.spacing });\r\n    map.assignElevation(param.elevation, constraints);\r\n    map.assignRainfall(param.biomes);\r\n    map.assignRivers(param.rivers);\r\n    return { mesh, map };\r\n}\r\n\r\n/** Manual editor data: when present, overrides procedural towns/stations/waypoints. */\r\nexport interface ManualTownsAndRailroads {\r\n    manualTowns?: number[];\r\n    manualStations?: { regionId: number; order: number }[];\r\n    railroadWaypoints?: { legIndex: number; regionId: number }[];\r\n}\r\n\r\n/** Compute towns, roads, and railroads from manual data only. No procedural towns or railroads. */\r\nexport function computeTownsAndRoads(\r\n    mesh: Mesh,\r\n    map: Mapgen4Map,\r\n    param: Mapgen4Param,\r\n    manual?: ManualTownsAndRailroads\r\n): {\r\n    towns: import('./TownGenerator').TownSite[];\r\n    roadSegments: import('./RoadGenerator').RoadSegment[];\r\n    railroadPath: number[];\r\n    railroadCrossings: import('./RailroadGenerator').RailroadCrossing[];\r\n    railroadStationIds: number[];\r\n} {\r\n    const townsParam = param.towns;\r\n    const defaultZoneId = townsParam?.defaultZoneId ?? 'zone_grasslands';\r\n\r\n    const towns: import('./TownGenerator').TownSite[] =\r\n        manual?.manualTowns && manual.manualTowns.length > 0\r\n            ? manual.manualTowns.map((regionId) => ({ regionId, zoneId: defaultZoneId }))\r\n            : [];\r\n\r\n    const roadsOk =\r\n        param.roads?.enabled &&\r\n        param.roads &&\r\n        (towns.length >= 2 || (param.roads.coverageGridSize ?? 0) >= 2);\r\n    const roadSegments = roadsOk\r\n        ? runRoadGenerator(\r\n            mesh,\r\n            map,\r\n            towns.map((t) => t.regionId),\r\n            {\r\n                shortcutsPerTown: param.roads.shortcutsPerTown ?? 1,\r\n                riverCrossingCost: param.roads.riverCrossingCost ?? 1.2,\r\n                seed: param.roads.seed ?? param.meshSeed,\r\n                coverageGridSize: param.roads.coverageGridSize ?? 0,\r\n                slopeWeight: param.roads.slopeWeight ?? 3,\r\n                waypointCurviness: param.roads.waypointCurviness ?? 0.15\r\n            },\r\n            param.rivers\r\n        )\r\n        : [];\r\n\r\n    const railroadsOk =\r\n        param.railroads?.enabled &&\r\n        param.railroads &&\r\n        (manual?.manualStations?.length ?? 0) >= 2;\r\n    let railroadPath: number[] = [];\r\n    let railroadCrossings: import('./RailroadGenerator').RailroadCrossing[] = [];\r\n    let railroadStationIds: number[] = [];\r\n    if (railroadsOk && manual?.manualStations && manual.manualStations.length >= 2) {\r\n        const sorted = [...manual.manualStations].sort((a, b) => a.order - b.order);\r\n        const explicitOrder = sorted.map((s) => s.regionId);\r\n        railroadStationIds = explicitOrder;\r\n        try {\r\n            const waypointsByLeg: number[][] = [];\r\n            if (manual.railroadWaypoints?.length) {\r\n                for (const w of manual.railroadWaypoints) {\r\n                    const i = w.legIndex;\r\n                    while (waypointsByLeg.length <= i) waypointsByLeg.push([]);\r\n                    waypointsByLeg[i]!.push(w.regionId);\r\n                }\r\n            }\r\n            const overrides: import('./RailroadGenerator').RailroadGeneratorOverrides = {\r\n                explicitStationOrder: explicitOrder,\r\n                waypointsByLeg: waypointsByLeg.length ? waypointsByLeg : undefined\r\n            };\r\n            const result = runRailroadGenerator(\r\n                mesh,\r\n                map,\r\n                param.rivers,\r\n                townsParam?.townRadius ?? 30,\r\n                overrides\r\n            );\r\n            railroadPath = result.path;\r\n            railroadCrossings = result.crossings;\r\n            railroadStationIds = result.stationRegionIds;\r\n        } catch (err) {\r\n            Logger.warn('[Mapgen4] Railroad generation failed:', err);\r\n            railroadPath = [];\r\n            railroadCrossings = [];\r\n        }\r\n    }\r\n\r\n    return { towns, roadSegments, railroadPath, railroadCrossings, railroadStationIds };\r\n}\r\n\r\n/** Generate world data from mapgen4 params and rasterize to ChunkData map. */\r\nexport function generateMapgen4(param: Mapgen4Param): Map<string, ChunkData> {\r\n    const { mesh, map } = buildMeshAndMap(param);\r\n    const { towns, roadSegments, railroadPath, railroadCrossings } = computeTownsAndRoads(\r\n        mesh,\r\n        map,\r\n        param\r\n    );\r\n\r\n    const cellRegions = buildCellRegions(mesh);\r\n    const worldW = MapEditorConfig.WORLD_WIDTH_TILES;\r\n    const worldH = MapEditorConfig.WORLD_HEIGHT_TILES;\r\n    const CHUNK_SIZE = MapEditorConfig.CHUNK_SIZE;\r\n    const townRadiusSq = (param.towns?.townRadius ?? 30) ** 2;\r\n\r\n    const worldData = new Map<string, ChunkData>();\r\n    const distanceFromWater = computeRegionDistanceFromWater(mesh, map, COAST_MAX_POLYGON_STEPS);\r\n\r\n    for (let ty = 0; ty < worldH; ty++) {\r\n        for (let tx = 0; tx < worldW; tx++) {\r\n            const cx = Math.floor(tx / CHUNK_SIZE);\r\n            const cy = Math.floor(ty / CHUNK_SIZE);\r\n            const chunkKey = `${cx},${cy}`;\r\n            if (!worldData.has(chunkKey)) {\r\n                worldData.set(chunkKey, {\r\n                    id: chunkKey,\r\n                    objects: [],\r\n                    zones: {}\r\n                });\r\n            }\r\n            const chunk = worldData.get(chunkKey)!;\r\n            const lx = ((tx % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;\r\n            const ly = ((ty % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;\r\n            const tileKey = `${lx},${ly}`;\r\n\r\n            const x = ((tx + 0.5) / worldW) * MAPGEN4_MAP_SIZE;\r\n            const y = ((ty + 0.5) / worldH) * MAPGEN4_MAP_SIZE;\r\n            const r = findRegionAt(mesh, x, y, cellRegions);\r\n            const elevation = map.elevation_r[r];\r\n            const rainfall = map.rainfall_r[r];\r\n            const isRiver = isTileOnRiver(x, y, r, mesh, map.flow_s, param.rivers, param.spacing);\r\n            const dist = distanceFromWater.get(r);\r\n            chunk.zones![tileKey] = mapgen4ToZones(\r\n                elevation,\r\n                rainfall,\r\n                isRiver,\r\n                x,\r\n                y,\r\n                param.meshSeed,\r\n                dist\r\n            );\r\n\r\n            for (const t of towns) {\r\n                const txMesh = mesh.x_of_r(t.regionId);\r\n                const tyMesh = mesh.y_of_r(t.regionId);\r\n                if ((x - txMesh) ** 2 + (y - tyMesh) ** 2 <= townRadiusSq) {\r\n                    chunk.zones![tileKey]['civilization'] = t.zoneId;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    for (const seg of roadSegments) {\r\n        if (!seg.crossesRiver) continue;\r\n        const x1 = mesh.x_of_r(seg.r1);\r\n        const y1 = mesh.y_of_r(seg.r1);\r\n        const x2 = mesh.x_of_r(seg.r2);\r\n        const y2 = mesh.y_of_r(seg.r2);\r\n        const steps = Math.ceil(Math.hypot(x2 - x1, y2 - y1) / 2);\r\n        for (let i = 0; i <= steps; i++) {\r\n            const t = i / steps;\r\n            const mx = x1 + t * (x2 - x1);\r\n            const my = y1 + t * (y2 - y1);\r\n            const tileX = Math.floor((mx / MAPGEN4_MAP_SIZE) * worldW);\r\n            const tileY = Math.floor((my / MAPGEN4_MAP_SIZE) * worldH);\r\n            if (tileX >= 0 && tileX < worldW && tileY >= 0 && tileY < worldH) {\r\n                const cx = Math.floor(tileX / CHUNK_SIZE);\r\n                const cy = Math.floor(tileY / CHUNK_SIZE);\r\n                const chunkKey = `${cx},${cy}`;\r\n                const chunk = worldData.get(chunkKey);\r\n                if (chunk && chunk.zones) {\r\n                    const lx = ((tileX % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;\r\n                    const ly = ((tileY % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;\r\n                    const tileKey = `${lx},${ly}`;\r\n                    if (!chunk.zones[tileKey]) chunk.zones[tileKey] = {};\r\n                    chunk.zones[tileKey]['civilization'] = 'civ_bridge';\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    for (const cross of railroadCrossings) {\r\n        if (!cross.crossesRiver) continue;\r\n        const x1 = mesh.x_of_r(cross.r1);\r\n        const y1 = mesh.y_of_r(cross.r1);\r\n        const x2 = mesh.x_of_r(cross.r2);\r\n        const y2 = mesh.y_of_r(cross.r2);\r\n        const steps = Math.ceil(Math.hypot(x2 - x1, y2 - y1) / 2);\r\n        for (let i = 0; i <= steps; i++) {\r\n            const t = i / steps;\r\n            const mx = x1 + t * (x2 - x1);\r\n            const my = y1 + t * (y2 - y1);\r\n            const tileX = Math.floor((mx / MAPGEN4_MAP_SIZE) * worldW);\r\n            const tileY = Math.floor((my / MAPGEN4_MAP_SIZE) * worldH);\r\n            if (tileX >= 0 && tileX < worldW && tileY >= 0 && tileY < worldH) {\r\n                const cx = Math.floor(tileX / CHUNK_SIZE);\r\n                const cy = Math.floor(tileY / CHUNK_SIZE);\r\n                const chunkKey = `${cx},${cy}`;\r\n                const chunk = worldData.get(chunkKey);\r\n                if (chunk && chunk.zones) {\r\n                    const lx = ((tileX % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;\r\n                    const ly = ((tileY % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;\r\n                    const tileKey = `${lx},${ly}`;\r\n                    if (!chunk.zones[tileKey]) chunk.zones[tileKey] = {};\r\n                    chunk.zones[tileKey]['civilization'] = 'civ_bridge';\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return worldData;\r\n}\r\n\r\n/** Serialize ChunkData map to payload for MapEditorCore.loadData(). */\r\nexport function toSerializedPayload(worldData: Map<string, ChunkData>): {\r\n    version: number;\r\n    chunks: ChunkData[];\r\n} {\r\n    const chunks: ChunkData[] = [];\r\n    worldData.forEach((chunk) => chunks.push(chunk));\r\n    return { version: 1, chunks };\r\n}\r\n\r\n/** Default mapgen4 params (match mapgen4.ts initialParams).\r\n * Includes towns, roads, railroads so the game shows civilization features\r\n * when map fetch fails (e.g. production build, no API server).\r\n */\r\nexport const DEFAULT_MAPGEN4_PARAM: Mapgen4Param = {\r\n    spacing: 5.5,\r\n    mountainSpacing: 35,\r\n    meshSeed: 12345,\r\n    elevation: {\r\n        seed: 187,\r\n        island: 0.5,\r\n        noisy_coastlines: 0.01,\r\n        hill_height: 0.02,\r\n        mountain_jagged: 0,\r\n        mountain_sharpness: 9.8,\r\n        mountain_folds: 0.05,\r\n        ocean_depth: 1.4\r\n    },\r\n    biomes: {\r\n        wind_angle_deg: 0,\r\n        raininess: 0.9,\r\n        rain_shadow: 0.5,\r\n        evaporation: 0.5\r\n    },\r\n    rivers: {\r\n        lg_min_flow: 2.7,\r\n        lg_river_width: -2.4,\r\n        flow: 0.2\r\n    },\r\n    towns: {\r\n        enabled: true,\r\n        numTowns: 6,\r\n        minSpacing: 80,\r\n        townRadius: 20,\r\n        defaultZoneId: 'civ_town',\r\n        elevationMin: 0,\r\n        elevationMax: 0.35,\r\n        rainfallMin: 0.2,\r\n        rainfallMax: 1\r\n    },\r\n    roads: {\r\n        enabled: true,\r\n        baseWidth: 256,\r\n        shortcutsPerTown: 2,\r\n        riverCrossingCost: 1.2,\r\n        coverageGridSize: 4,\r\n        slopeWeight: 4,\r\n        waypointCurviness: 0.15\r\n    },\r\n    railroads: {\r\n        enabled: true\r\n    }\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\Mapgen4MathUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\Mapgen4Param.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\Mapgen4PathUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\Mapgen4PreviewRenderer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\Mapgen4RailroadPreview.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\Mapgen4RegionUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\Mapgen4RiverUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\Mapgen4SegmentUtils.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'n' is defined but never used. Allowed unused args must match /^_/u.","line":73,"column":70,"nodeType":"Identifier","messageId":"unusedVar","endLine":73,"endColumn":71},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'stepsPerSegment' is defined but never used. Allowed unused args must match /^_/u.","line":142,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":142,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Mapgen4SegmentUtils  Splitting paths into region segments and building dense spline samples\r\n */\r\n\r\nimport type { Mesh } from './mapgen4/types';\r\nimport { catmullRom } from './Mapgen4MathUtils';\r\n\r\n/** Only segments with effectively zero chord use linear (degenerate); all others use Catmull-Rom so bending is consistent. */\r\nconst MIN_CHORD_LENGTH_FOR_SPLINE = 1e-6;\r\n\r\n/** Split path into continuous segments (break when consecutive regions are not adjacent). */\r\nexport function splitPathIntoSegments(mesh: Mesh, path: number[]): number[][] {\r\n    const segments: number[][] = [];\r\n    let current: number[] = [];\r\n    for (let i = 0; i < path.length; i++) {\r\n        const r = path[i];\r\n        if (current.length > 0) {\r\n            const prevR = current[current.length - 1];\r\n            const sides: number[] = [];\r\n            mesh.s_around_r(prevR, sides);\r\n            let adjacent = false;\r\n            for (const s of sides) {\r\n                if (s < 0) continue;\r\n                const rNext = mesh.r_begin_s(s) === prevR ? mesh.r_end_s(s) : mesh.r_begin_s(s);\r\n                if (rNext === r) {\r\n                    adjacent = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!adjacent) {\r\n                if (current.length >= 2) segments.push(current);\r\n                current = [];\r\n            }\r\n        }\r\n        current.push(r);\r\n    }\r\n    if (current.length >= 2) segments.push(current);\r\n    return segments;\r\n}\r\n\r\n/** Baseline steps (same as old fixed value); bends get more up to MAX. */\r\nconst MIN_STEPS_PER_SEGMENT = 24;\r\nconst MAX_STEPS_PER_SEGMENT = 64;\r\n\r\n/**\r\n * Steps for segment p1->p2 from bend at both ends. Uses max bend so segments entering/leaving a corner get more steps.\r\n * cos=1 (straight) -> MIN, sharp (cos=-1) -> MAX.\r\n */\r\nfunction stepsForSegment(\r\n    p0: { x: number; y: number },\r\n    p1: { x: number; y: number },\r\n    p2: { x: number; y: number },\r\n    p3: { x: number; y: number }\r\n): number {\r\n    const vInX = p1.x - p0.x;\r\n    const vInY = p1.y - p0.y;\r\n    const vMidX = p2.x - p1.x;\r\n    const vMidY = p2.y - p1.y;\r\n    const vOutX = p3.x - p2.x;\r\n    const vOutY = p3.y - p2.y;\r\n    const lenIn = Math.hypot(vInX, vInY) || 1e-10;\r\n    const lenMid = Math.hypot(vMidX, vMidY) || 1e-10;\r\n    const lenOut = Math.hypot(vOutX, vOutY) || 1e-10;\r\n    const cosAtP1 = (vInX * vMidX + vInY * vMidY) / (lenIn * lenMid);\r\n    const cosAtP2 = (vMidX * vOutX + vMidY * vOutY) / (lenMid * lenOut);\r\n    const cos = Math.min(cosAtP1, cosAtP2);\r\n    const t = (1 - Math.max(-1, Math.min(1, cos))) * 0.5;\r\n    const steps = Math.round(MIN_STEPS_PER_SEGMENT + t * (MAX_STEPS_PER_SEGMENT - MIN_STEPS_PER_SEGMENT));\r\n    return Math.max(MIN_STEPS_PER_SEGMENT, Math.min(MAX_STEPS_PER_SEGMENT, steps));\r\n}\r\n\r\n/** Tangent at junction p(0) for closed loop: (p(1) - p(n-1)) / 2 from Catmull-Rom. */\r\nfunction junctionTangent(p: (i: number) => { x: number; y: number }, n: number): number {\r\n    const dx = p(1).x - p(-1).x;\r\n    const dy = p(1).y - p(-1).y;\r\n    return Math.atan2(dy, dx);\r\n}\r\n\r\n/** Dense spline samples for CLOSED curve. Wraps lastfirst; first and last share position and angle for seamless merge. Always uses Catmull-Rom (no linear fallback). */\r\nexport function buildSplineFineSamplesClosed(\r\n    points: { x: number; y: number }[],\r\n    stepsPerSegment: number\r\n): { x: number; y: number; angle: number; cumLen: number }[] {\r\n    const n = points.length;\r\n    if (n < 3) return buildSplineFineSamples(points, stepsPerSegment);\r\n    const p = (i: number) => points[((i % n) + n) % n];\r\n    const junctionAngle = junctionTangent(p, n);\r\n\r\n    const result: { x: number; y: number; angle: number; cumLen: number }[] = [];\r\n    let cumLen = 0;\r\n    result.push({ x: p(0).x, y: p(0).y, angle: junctionAngle, cumLen: 0 });\r\n    let prev = { x: p(0).x, y: p(0).y };\r\n\r\n    for (let seg = 0; seg < n; seg++) {\r\n        const p0 = p(seg - 1);\r\n        const p1 = p(seg);\r\n        const p2 = p(seg + 1);\r\n        const p3 = p(seg + 2);\r\n        const chordLen = Math.hypot(p2.x - p1.x, p2.y - p1.y);\r\n        const useLinear = chordLen < MIN_CHORD_LENGTH_FOR_SPLINE;\r\n        const steps = stepsForSegment(p0, p1, p2, p3);\r\n\r\n        for (let k = 1; k <= steps; k++) {\r\n            const t = k / steps;\r\n            let x: number;\r\n            let y: number;\r\n            let tx: number;\r\n            let ty: number;\r\n            if (useLinear) {\r\n                x = p1.x + (p2.x - p1.x) * t;\r\n                y = p1.y + (p2.y - p1.y) * t;\r\n                tx = p2.x - p1.x;\r\n                ty = p2.y - p1.y;\r\n            } else {\r\n                const cr = catmullRom(p0, p1, p2, p3, t);\r\n                x = cr.x;\r\n                y = cr.y;\r\n                tx = cr.tx;\r\n                ty = cr.ty;\r\n            }\r\n            cumLen += Math.hypot(x - prev.x, y - prev.y);\r\n            const angle = Math.atan2(ty, tx);\r\n            result.push({ x, y, angle, cumLen });\r\n            prev = { x, y };\r\n        }\r\n    }\r\n\r\n    const totalLen = result[result.length - 1].cumLen;\r\n    result[result.length - 1] = {\r\n        x: p(0).x,\r\n        y: p(0).y,\r\n        angle: junctionAngle,\r\n        cumLen: totalLen\r\n    };\r\n    result[0].angle = junctionAngle;\r\n    return result;\r\n}\r\n\r\n/** Dense spline samples for OPEN curve. Always uses Catmull-Rom (no linear fallback). */\r\nexport function buildSplineFineSamples(\r\n    points: { x: number; y: number }[],\r\n    stepsPerSegment: number\r\n): { x: number; y: number; angle: number; cumLen: number }[] {\r\n    const n = points.length;\r\n    if (n < 2) return [];\r\n    const p = (i: number) => points[Math.max(0, Math.min(i, n - 1))];\r\n\r\n    const result: { x: number; y: number; angle: number; cumLen: number }[] = [];\r\n    let cumLen = 0;\r\n    result.push({ x: p(0).x, y: p(0).y, angle: 0, cumLen: 0 });\r\n    let prev = { x: p(0).x, y: p(0).y };\r\n\r\n    for (let seg = 0; seg < n - 1; seg++) {\r\n        const p0 = seg === 0 ? p(0) : p(seg - 1);\r\n        const p1 = p(seg);\r\n        const p2 = p(seg + 1);\r\n        const p3 = seg === n - 2 ? p(n - 1) : p(seg + 2);\r\n        const chordLen = Math.hypot(p2.x - p1.x, p2.y - p1.y);\r\n        const useLinear = chordLen < MIN_CHORD_LENGTH_FOR_SPLINE;\r\n        const steps = stepsForSegment(p0, p1, p2, p3);\r\n\r\n        for (let k = 1; k <= steps; k++) {\r\n            const t = k / steps;\r\n            let x: number;\r\n            let y: number;\r\n            let tx: number;\r\n            let ty: number;\r\n            if (useLinear) {\r\n                x = p1.x + (p2.x - p1.x) * t;\r\n                y = p1.y + (p2.y - p1.y) * t;\r\n                tx = p2.x - p1.x;\r\n                ty = p2.y - p1.y;\r\n            } else {\r\n                const cr = catmullRom(p0, p1, p2, p3, t);\r\n                x = cr.x;\r\n                y = cr.y;\r\n                tx = cr.tx;\r\n                ty = cr.ty;\r\n            }\r\n            cumLen += Math.hypot(x - prev.x, y - prev.y);\r\n            result.push({ x, y, angle: Math.atan2(ty, tx), cumLen });\r\n            prev = { x, y };\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\n/** Build arc-length parameterized spline. Sample at fixed distance intervals for tiling. */\r\nexport function buildSplineArcLengthSamples(\r\n    points: { x: number; y: number }[],\r\n    sampleInterval: number,\r\n    forceLinear = false\r\n): { x: number; y: number; angle: number }[] {\r\n    const n = points.length;\r\n    if (n < 2) return [];\r\n    const p = (i: number) => points[((i % n) + n) % n];\r\n\r\n    const fineSamples: { x: number; y: number; angle: number; cumLen: number }[] = [];\r\n    let cumLen = 0;\r\n    fineSamples.push({ x: p(0).x, y: p(0).y, angle: 0, cumLen: 0 });\r\n    let prev = { x: p(0).x, y: p(0).y };\r\n\r\n    for (let seg = 0; seg < n; seg++) {\r\n        const p1 = p(seg);\r\n        const p2 = p(seg + 1);\r\n        const steps = 20;\r\n        for (let k = 1; k <= steps; k++) {\r\n            const t = k / steps;\r\n            let x: number;\r\n            let y: number;\r\n            let tx: number;\r\n            let ty: number;\r\n            if (forceLinear) {\r\n                x = p1.x + (p2.x - p1.x) * t;\r\n                y = p1.y + (p2.y - p1.y) * t;\r\n                tx = p2.x - p1.x;\r\n                ty = p2.y - p1.y;\r\n            } else {\r\n                const p0 = p(seg - 1);\r\n                const p3 = p(seg + 2);\r\n                const cr = catmullRom(p0, p1, p2, p3, t);\r\n                x = cr.x;\r\n                y = cr.y;\r\n                tx = cr.tx;\r\n                ty = cr.ty;\r\n            }\r\n            cumLen += Math.hypot(x - prev.x, y - prev.y);\r\n            fineSamples.push({ x, y, angle: Math.atan2(ty, tx), cumLen });\r\n            prev = { x, y };\r\n        }\r\n    }\r\n\r\n    if (fineSamples.length < 2) return [];\r\n    const totalLen = fineSamples[fineSamples.length - 1].cumLen;\r\n    const tileCount = Math.max(1, Math.ceil(totalLen / sampleInterval));\r\n    const result: { x: number; y: number; angle: number }[] = [];\r\n\r\n    for (let i = 0; i <= tileCount; i++) {\r\n        const targetLen = Math.min(i * sampleInterval, totalLen);\r\n        let idx = 0;\r\n        while (idx < fineSamples.length && fineSamples[idx].cumLen < targetLen) idx++;\r\n        idx = Math.min(idx, fineSamples.length - 1);\r\n        const a = fineSamples[idx];\r\n        const b = idx > 0 ? fineSamples[idx - 1] : a;\r\n        const segLen = a.cumLen - b.cumLen;\r\n        const t = segLen > 1e-6 ? (targetLen - b.cumLen) / segLen : 1;\r\n        result.push({\r\n            x: b.x + (a.x - b.x) * t,\r\n            y: b.y + (a.y - b.y) * t,\r\n            angle: b.angle + (a.angle - b.angle) * t\r\n        });\r\n    }\r\n    return result;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\Mapgen4ZoneMapping.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\MapgenWorkerClient.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\ObjectSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\ProceduralArchitect.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'chunkManager' is defined but never used. Allowed unused args must match /^_/u.","line":46,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":46,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'chunkX' is defined but never used. Allowed unused args must match /^_/u.","line":46,"column":56,"nodeType":"Identifier","messageId":"unusedVar","endLine":46,"endColumn":62},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'chunkY' is defined but never used. Allowed unused args must match /^_/u.","line":46,"column":72,"nodeType":"Identifier","messageId":"unusedVar","endLine":46,"endColumn":78},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'chunkManager' is defined but never used. Allowed unused args must match /^_/u.","line":50,"column":26,"nodeType":"Identifier","messageId":"unusedVar","endLine":50,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'chunkX' is defined but never used. Allowed unused args must match /^_/u.","line":50,"column":54,"nodeType":"Identifier","messageId":"unusedVar","endLine":50,"endColumn":60},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'chunkY' is defined but never used. Allowed unused args must match /^_/u.","line":50,"column":70,"nodeType":"Identifier","messageId":"unusedVar","endLine":50,"endColumn":76},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'worldData' is defined but never used. Allowed unused args must match /^_/u.","line":61,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":61,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ChunkManager } from './ChunkManager';\r\nimport { ChunkData } from './MapEditorTypes';\r\nimport { Logger } from '@core/Logger';\r\nimport { createNoise2D } from 'simplex-noise';\r\nimport { MapEditorConfig } from './MapEditorConfig';\r\nimport {\r\n    WATER_TERRAIN_IDS,\r\n    WATER_SPLAT_TERRAIN_IDS\r\n} from './Mapgen4BiomeConfig';\r\nimport { ProceduralRules } from './data/ProceduralRules';\r\n\r\n/**\r\n * ProceduralArchitect  Smart generation of map content from zone state.\r\n * Handles biome-based transitions, city grid generation, organic forest clustering,\r\n * coast sync, and splat evaluation for ground blending.\r\n */\r\nexport class ProceduralArchitect {\r\n    private noise: (x: number, y: number) => number;\r\n\r\n    constructor() {\r\n        this.noise = createNoise2D();\r\n    }\r\n\r\n    /**\r\n     * Fills a specific chunk with biome-appropriate content\r\n     */\r\n    public generateChunk(\r\n        chunkManager: ChunkManager,\r\n        chunkX: number,\r\n        chunkY: number,\r\n        biomeId: string\r\n    ) {\r\n        Logger.info(`[Architect] Generating ${biomeId} for chunk ${chunkX},${chunkY}`);\r\n\r\n        switch (biomeId) {\r\n            case 'forest':\r\n                this.generateForest(chunkManager, chunkX, chunkY);\r\n                break;\r\n            case 'city':\r\n                this.generateCity(chunkManager, chunkX, chunkY);\r\n                break;\r\n            // ...\r\n        }\r\n    }\r\n\r\n    private generateForest(chunkManager: ChunkManager, chunkX: number, chunkY: number) {\r\n        // Example: Use noise to place trees\r\n    }\r\n\r\n    private generateCity(chunkManager: ChunkManager, chunkX: number, chunkY: number) {\r\n        // Example: Grid roads + Buildings\r\n    }\r\n\r\n    /**\r\n     * Processes adjacency rules for ground painting.\r\n     * Returns zone updates (pass-through) and splat operations from procedural rules.\r\n     * Splats are evaluated after zone updates are applied; for now we pass through zones only.\r\n     */\r\n    public processAdjacency(\r\n        rawUpdates: { x: number; y: number; category: string; zoneId: string | null }[],\r\n        worldData: Map<string, ChunkData>\r\n    ): {\r\n        zones: typeof rawUpdates;\r\n        splats: { x: number; y: number; radius: number; intensity: number }[];\r\n    } {\r\n        return { zones: rawUpdates, splats: [] };\r\n    }\r\n\r\n    /**\r\n     * Compute coast zone updates based on data-driven ProceduralRules.\r\n     */\r\n    public computeCoastUpdates(\r\n        worldData: Map<string, ChunkData>,\r\n        dirtyChunkKeys: Set<string>\r\n    ): { x: number; y: number; category: string; zoneId: string | null }[] {\r\n        const updates: { x: number; y: number; category: string; zoneId: string | null }[] = [];\r\n        const { CHUNK_SIZE, TILE_SIZE, Procedural } = MapEditorConfig;\r\n        const chunkSizePx = CHUNK_SIZE * TILE_SIZE;\r\n        const COAST_DEPTH = Procedural.COAST_DEPTH;\r\n\r\n        const getNeighborTerrain = (gx: number, gy: number): string | null => {\r\n            const nCX = Math.floor(gx / chunkSizePx);\r\n            const nCY = Math.floor(gy / chunkSizePx);\r\n            const nData = worldData.get(`${nCX},${nCY}`);\r\n            if (!nData?.zones) return null;\r\n            const nLX = Math.floor((gx - nCX * chunkSizePx) / TILE_SIZE);\r\n            const nLY = Math.floor((gy - nCY * chunkSizePx) / TILE_SIZE);\r\n            return nData.zones[`${nLX},${nLY}`]?.['terrain'] ?? null;\r\n        };\r\n\r\n        const ruleInfo = ProceduralRules.COASTLINE_INTERPOLATION;\r\n\r\n        // Coast extends N tiles from water; check all tiles within COAST_DEPTH steps\r\n        const hasWaterWithin = (tileLeftX: number, tileLeftY: number, steps: number): boolean => {\r\n            for (let dx = -steps; dx <= steps; dx++) {\r\n                for (let dy = -steps; dy <= steps; dy++) {\r\n                    if (dx === 0 && dy === 0) continue;\r\n                    const nx = tileLeftX + dx * TILE_SIZE;\r\n                    const ny = tileLeftY + dy * TILE_SIZE;\r\n                    const n = getNeighborTerrain(nx + TILE_SIZE / 2, ny + TILE_SIZE / 2);\r\n                    if (n && ruleInfo.requiredAdjacentZoneIds.includes(n)) return true;\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n\r\n        /** Directly adjacent to water (using rule radius). Used for ADD to respect polygon cap. */\r\n        const hasRuleRequiredNeighbor = (tileLeftX: number, tileLeftY: number): boolean => {\r\n            const steps = ruleInfo.radiusTiles;\r\n            for (let dx = -steps; dx <= steps; dx++) {\r\n                for (let dy = -steps; dy <= steps; dy++) {\r\n                    if (dx === 0 && dy === 0) continue;\r\n                    const nx = tileLeftX + dx * TILE_SIZE;\r\n                    const ny = tileLeftY + dy * TILE_SIZE;\r\n                    const t = getNeighborTerrain(nx + TILE_SIZE / 2, ny + TILE_SIZE / 2);\r\n                    if (t && ruleInfo.requiredAdjacentZoneIds.includes(t)) return true;\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n\r\n        for (const chunkKey of dirtyChunkKeys) {\r\n            const data = worldData.get(chunkKey);\r\n            if (!data?.zones) continue;\r\n            const [cx, cy] = chunkKey.split(',').map(Number);\r\n\r\n            for (const [tileKey, categories] of Object.entries(data.zones)) {\r\n                const [lx, ly] = tileKey.split(',').map(Number);\r\n                const gx = (cx * CHUNK_SIZE + lx) * TILE_SIZE;\r\n                const gy = (cy * CHUNK_SIZE + ly) * TILE_SIZE;\r\n                const biome = categories['biome'];\r\n                const terrain = categories['terrain'];\r\n                const isTargetBiome = ruleInfo.validBaseBiomes.includes(biome);\r\n\r\n                // Using hardcoded COAST_DEPTH here for the fade-out logic\r\n                const hasWaterNearby = hasWaterWithin(gx, gy, COAST_DEPTH);\r\n\r\n                if (terrain === ruleInfo.targetZoneId && !hasWaterNearby) {\r\n                    // Remove coast if no water nearby\r\n                    updates.push({\r\n                        x: gx + TILE_SIZE / 2,\r\n                        y: gy + TILE_SIZE / 2,\r\n                        category: ruleInfo.targetZoneCategory,\r\n                        zoneId: null\r\n                    });\r\n                } else if (\r\n                    isTargetBiome &&\r\n                    hasRuleRequiredNeighbor(gx, gy) &&\r\n                    terrain &&\r\n                    !WATER_TERRAIN_IDS.includes(terrain as (typeof WATER_TERRAIN_IDS)[number])\r\n                ) {\r\n                    // Add coast if directly adjacent to water and valid\r\n                    updates.push({\r\n                        x: gx + TILE_SIZE / 2,\r\n                        y: gy + TILE_SIZE / 2,\r\n                        category: ruleInfo.targetZoneCategory,\r\n                        zoneId: ruleInfo.targetZoneId\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        return updates;\r\n    }\r\n\r\n    /**\r\n     * Generate splat ops. Only WATER tiles emit splats, with a large radius so\r\n     * the gradient extends through coast tiles and bleeds into grass tiles.\r\n     * No clearing ops  they would erase the gradient; stale data is handled by regenerateSplats on load.\r\n     */\r\n    public evaluateSplats(\r\n        dirtyTiles: { x: number; y: number }[],\r\n        worldData: Map<string, ChunkData>\r\n    ): { x: number; y: number; radius: number; intensity: number }[] {\r\n        const splatResults: { x: number; y: number; radius: number; intensity: number }[] = [];\r\n        const { CHUNK_SIZE, TILE_SIZE, Procedural } = MapEditorConfig;\r\n        const chunkSizePx = CHUNK_SIZE * TILE_SIZE;\r\n        const WATER_RADIUS = Procedural.WATER_SPLAT_RADIUS;\r\n        const WATER_INTENSITY = Procedural.WATER_SPLAT_INTENSITY;\r\n\r\n        dirtyTiles.forEach((tile) => {\r\n            const chunkX = Math.floor(tile.x / chunkSizePx);\r\n            const chunkY = Math.floor(tile.y / chunkSizePx);\r\n            const key = `${chunkX},${chunkY}`;\r\n\r\n            const data = worldData.get(key);\r\n            if (!data?.zones) return;\r\n\r\n            const localX = Math.floor((tile.x - chunkX * chunkSizePx) / TILE_SIZE);\r\n            const localY = Math.floor((tile.y - chunkY * chunkSizePx) / TILE_SIZE);\r\n            const tileKey = `${localX},${localY}`;\r\n            const terrain = data.zones[tileKey]?.['terrain'];\r\n            const centerX = tile.x + TILE_SIZE / 2;\r\n            const centerY = tile.y + TILE_SIZE / 2;\r\n\r\n            if (terrain && WATER_SPLAT_TERRAIN_IDS.includes(terrain as (typeof WATER_SPLAT_TERRAIN_IDS)[number])) {\r\n                splatResults.push({\r\n                    x: centerX,\r\n                    y: centerY,\r\n                    radius: WATER_RADIUS,\r\n                    intensity: WATER_INTENSITY\r\n                });\r\n            }\r\n        });\r\n\r\n        return splatResults;\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\RailroadBlockedRegions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\RailroadDijkstra.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\RailroadGenerator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\RailroadGeneratorTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\RailroadMeshRenderer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\RailroadPathfinder.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\RailroadSplineBuilder.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isClosed' is defined but never used. Allowed unused args must match /^_/u.","line":44,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":44,"endColumn":13}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * RailroadSplineBuilder  Build railroad spline mesh from region path.\n * Train physics: long straight segments, gentle curves. Pipeline: simplify  arc corners  spline.\n */\n\nimport type { Mesh } from './mapgen4/types';\nimport { simplifyPathForSpline } from './Mapgen4MathUtils';\nimport { insertArcWaypointsAtCorners, smoothPath } from './Mapgen4CurveUtils';\nimport { buildSplineFineSamplesClosed, buildSplineFineSamples } from './Mapgen4SegmentUtils';\n\n/** Railroad tile size in world pixels  fixed in world space. */\nexport const RAILROAD_TILE_WORLD_PX = 1024;\n/** Mesh units per tile (1000 mesh = 160000 world px). */\nexport const RAILROAD_TILE_MESH = RAILROAD_TILE_WORLD_PX / (160000 / 1000);\n\n/** Douglas-Peucker tolerance. Lower = preserve more points so path stays on land. */\nconst RAILROAD_SIMPLIFY_TOLERANCE = 6;\n\n/** Arc radius for corners. Larger = gentler turns (train is rigid, turns slowly). */\nconst DEFAULT_ARC_RADIUS_MESH = 28;\n\nconst MESH_TO_WORLD = 160000 / 1000;\nconst STEPS_PER_SEGMENT = 24;\n\n/** Minimum distance (mesh units) between consecutive spline samples; thins dense clusters at bends. */\nconst MIN_SAMPLE_SPACING_MESH = 3;\n\n/** Subdivisions per segment for the polygon mesh; more = smoother strip, same spline. */\nconst SUBDIVISIONS_PER_SEGMENT = 4;\n\n/** Cap spline samples to avoid OOM from very long paths. */\nconst MAX_SPLINE_SAMPLES = 1200;\n\n/** Sample along the spline: { x, y, angle, cumLen } in mesh coords. */\nexport type RailroadSplineSample = { x: number; y: number; angle: number; cumLen: number };\n\n/**\n * Thin samples so consecutive points are at least minSpacing apart. Reduces dense clusters at bends.\n * Recomputes cumLen for the kept points.\n */\nfunction thinSamplesByMinSpacing(\n    samples: RailroadSplineSample[],\n    minSpacing: number,\n    isClosed: boolean\n): RailroadSplineSample[] {\n    if (samples.length < 2) return samples;\n    const kept: RailroadSplineSample[] = [{ ...samples[0] }];\n    let lastKept = samples[0]!;\n    for (let i = 1; i < samples.length; i++) {\n        const s = samples[i]!;\n        const isLast = i === samples.length - 1;\n        const dist = Math.hypot(s.x - lastKept.x, s.y - lastKept.y);\n        if (isLast || dist >= minSpacing) {\n            kept.push({ x: s.x, y: s.y, angle: s.angle, cumLen: 0 });\n            lastKept = s;\n        }\n    }\n    let cumLen = 0;\n    kept[0]!.cumLen = 0;\n    for (let j = 1; j < kept.length; j++) {\n        const a = kept[j - 1]!;\n        const b = kept[j]!;\n        cumLen += Math.hypot(b.x - a.x, b.y - a.y);\n        kept[j] = { ...b, cumLen };\n    }\n    return kept.length >= 2 ? kept : samples;\n}\n\n/**\n * Smooth sample positions (Laplacian: each point averaged with neighbors).\n * Recomputes angle and cumLen from the smoothed path. Closed loops only; no fixed indices.\n */\nfunction smoothSplineSamples(\n    samples: RailroadSplineSample[],\n    isClosed: boolean,\n    iterations = 2,\n    lambda = 0.45,\n    fixedIndices?: Set<number>\n): RailroadSplineSample[] {\n    if (samples.length < 3) return samples;\n    const points = samples.map((s) => ({ x: s.x, y: s.y }));\n    const smoothed = smoothPath(points, isClosed, iterations, lambda, fixedIndices);\n    const n = smoothed.length;\n    let cumLen = 0;\n    const result: RailroadSplineSample[] = [];\n    for (let i = 0; i < n; i++) {\n        const prev = smoothed[(i - 1 + n) % n]!;\n        const curr = smoothed[i]!;\n        const next = smoothed[(i + 1) % n]!;\n        if (i > 0) cumLen += Math.hypot(curr.x - prev.x, curr.y - prev.y);\n        const angle = Math.atan2(next.y - prev.y, next.x - prev.x);\n        result.push({ x: curr.x, y: curr.y, angle, cumLen });\n    }\n    if (isClosed && n >= 2) {\n        const totalLen =\n            cumLen +\n            Math.hypot(smoothed[0]!.x - smoothed[n - 1]!.x, smoothed[0]!.y - smoothed[n - 1]!.y);\n        result[n - 1] = {\n            x: smoothed[0]!.x,\n            y: smoothed[0]!.y,\n            angle: result[0]!.angle,\n            cumLen: totalLen\n        };\n    }\n    return result;\n}\n\n/**\n * Build spline samples from region path. Single source of truth for railroad spline geometry.\n * Pipeline: simplify  arc corners  Catmull-Rom (linear at sharp bends).\n * Used by both mesh builder and canvas preview so texture mesh and spline path match.\n * stationRegionIds: region IDs of towns  these points are never simplified away\n * and arcs never replace them, so the spline passes through each station.\n */\nexport function buildRailroadSplineSamples(\n    mesh: Mesh,\n    path: number[],\n    stationRegionIds?: number[]\n): RailroadSplineSample[] {\n    if (path.length < 2) return [];\n\n    const pts = path.map((r) => ({ x: mesh.x_of_r(r), y: mesh.y_of_r(r) }));\n    const isClosed = path.length >= 3 && path[0] === path[path.length - 1];\n    const rawPoints = isClosed ? pts.slice(0, -1) : pts;\n    const stationSet = stationRegionIds ? new Set(stationRegionIds) : undefined;\n    const preserveIndices =\n        stationSet && stationSet.size > 0\n            ? new Set(rawPoints.map((_, i) => i).filter((i) => stationSet!.has(path[i])))\n            : undefined;\n    const { points: simplified, preservedResultIndices } = simplifyPathForSpline(\n        rawPoints,\n        RAILROAD_SIMPLIFY_TOLERANCE,\n        preserveIndices\n    );\n\n    const arcPreserve =\n        preservedResultIndices && preservedResultIndices.size > 0\n            ? preservedResultIndices\n            : undefined;\n    const points = insertArcWaypointsAtCorners(\n        simplified,\n        isClosed,\n        DEFAULT_ARC_RADIUS_MESH,\n        arcPreserve\n    );\n\n    const rawSamples =\n        isClosed && points.length >= 3\n            ? buildSplineFineSamplesClosed(points, STEPS_PER_SEGMENT)\n            : buildSplineFineSamples(points, STEPS_PER_SEGMENT);\n\n    const thinned = thinSamplesByMinSpacing(\n        rawSamples,\n        MIN_SAMPLE_SPACING_MESH,\n        isClosed && points.length >= 3\n    );\n    const closed = isClosed && points.length >= 3;\n    const fixedSamples = new Set<number>();\n    if (closed && stationSet && stationSet.size > 0) {\n        const stationCoords = Array.from(stationSet).map((r) => ({\n            x: mesh.x_of_r(r),\n            y: mesh.y_of_r(r)\n        }));\n        for (let i = 0; i < thinned.length; i++) {\n            const s = thinned[i]!;\n            for (const sc of stationCoords) {\n                if (Math.abs(s.x - sc.x) < 0.1 && Math.abs(s.y - sc.y) < 0.1) {\n                    fixedSamples.add(i);\n                }\n            }\n        }\n    }\n    let samples = closed ? smoothSplineSamples(thinned, true, 2, 0.45, fixedSamples) : thinned;\n    if (samples.length > MAX_SPLINE_SAMPLES) {\n        const step = (samples.length - 1) / (MAX_SPLINE_SAMPLES - 1);\n        const capped: RailroadSplineSample[] = [samples[0]!];\n        for (let i = 1; i < MAX_SPLINE_SAMPLES - 1; i++) {\n            const idx = Math.round(i * step);\n            capped.push(samples[idx]!);\n        }\n        capped.push(samples[samples.length - 1]!);\n        let cumLen = 0;\n        capped[0]!.cumLen = 0;\n        for (let j = 1; j < capped.length; j++) {\n            const a = capped[j - 1]!;\n            const b = capped[j]!;\n            cumLen += Math.hypot(b.x - a.x, b.y - a.y);\n            capped[j] = { ...b, cumLen };\n        }\n        samples = capped;\n    }\n    return samples.length >= 2 ? samples : [];\n}\n\n/** One ring of the strip: left/right positions (world) and u for UV. */\ntype Ring = { lx: number; ly: number; rx: number; ry: number; u: number };\n\n/**\n * Build railroad mesh data: one continuous spline mesh.\n * Vertices follow the spline; UVs tile along arc length for seamless texture.\n * Each segment is subdivided (SUBDIVISIONS_PER_SEGMENT) for a smoother polygon strip.\n */\nexport function buildRailroadSplineMeshData(\n    mesh: Mesh,\n    path: number[],\n    stationRegionIds?: number[]\n): { positions: Float32Array; uvs: Float32Array; indices: Uint32Array }[] {\n    const samples = buildRailroadSplineSamples(mesh, path, stationRegionIds);\n    if (samples.length < 2) return [];\n\n    const isClosed = path.length >= 3 && path[0] === path[path.length - 1];\n    const halfW = RAILROAD_TILE_MESH / 2;\n    const rings: Ring[] = [];\n    for (const s of samples) {\n        const px = Math.cos(s.angle + Math.PI / 2) * halfW;\n        const py = Math.sin(s.angle + Math.PI / 2) * halfW;\n        rings.push({\n            lx: (s.x - px) * MESH_TO_WORLD,\n            ly: (s.y - py) * MESH_TO_WORLD,\n            rx: (s.x + px) * MESH_TO_WORLD,\n            ry: (s.y + py) * MESH_TO_WORLD,\n            u: s.cumLen / RAILROAD_TILE_MESH\n        });\n    }\n\n    const sub = Math.max(1, SUBDIVISIONS_PER_SEGMENT);\n    const expanded: Ring[] = [rings[0]!];\n    for (let i = 0; i < rings.length - 1; i++) {\n        const a = rings[i]!;\n        const b = rings[i + 1]!;\n        for (let k = 1; k <= sub; k++) {\n            const t = k / (sub + 1);\n            expanded.push({\n                lx: (1 - t) * a.lx + t * b.lx,\n                ly: (1 - t) * a.ly + t * b.ly,\n                rx: (1 - t) * a.rx + t * b.rx,\n                ry: (1 - t) * a.ry + t * b.ry,\n                u: (1 - t) * a.u + t * b.u\n            });\n        }\n        expanded.push(b);\n    }\n    if (isClosed && rings.length >= 3) {\n        const a = rings[rings.length - 1]!;\n        const b = rings[0]!;\n        for (let k = 1; k <= sub; k++) {\n            const t = k / (sub + 1);\n            expanded.push({\n                lx: (1 - t) * a.lx + t * b.lx,\n                ly: (1 - t) * a.ly + t * b.ly,\n                rx: (1 - t) * a.rx + t * b.rx,\n                ry: (1 - t) * a.ry + t * b.ry,\n                u: (1 - t) * a.u + t * b.u\n            });\n        }\n        expanded.push(b);\n    }\n\n    const positions: number[] = [];\n    const uvs: number[] = [];\n    for (const r of expanded) {\n        positions.push(r.lx, r.ly);\n        positions.push(r.rx, r.ry);\n        uvs.push(r.u, 0);\n        uvs.push(r.u, 1);\n    }\n\n    const indices: number[] = [];\n    const numRings = expanded.length;\n    for (let j = 0; j < numRings - 1; j++) {\n        const va = 2 * j;\n        const vb = 2 * (j + 1);\n        indices.push(va, va + 1, vb + 1);\n        indices.push(va, vb + 1, vb);\n    }\n\n    return [\n        {\n            positions: new Float32Array(positions),\n            uvs: new Float32Array(uvs),\n            indices: new Uint32Array(indices)\n        }\n    ];\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\RoadGenerator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\RoadPathUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\TownGenerator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\ZoneColorHelper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\ZoneSystem.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'cat' is defined but never used. Allowed unused args must match /^_/u.","line":231,"column":50,"nodeType":"Identifier","messageId":"unusedVar","endLine":231,"endColumn":53}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as PIXI from 'pixi.js';\r\nimport { MapEditorConfig } from './MapEditorConfig';\r\nimport { ChunkData } from './MapEditorTypes';\r\nimport { ZoneConfig, ZoneCategory } from '@data/ZoneConfig';\r\nimport { GroundSystem } from './GroundSystem';\r\nimport { ProceduralArchitect } from './ProceduralArchitect';\r\nimport { EditorContext } from './EditorContext';\r\nimport { regenerateSplats } from './ZoneSystemSplatRegen';\r\nimport { worldToChunkTile, markTileAndNeighbors } from './ZoneSystemUtils';\r\n\r\nexport class ZoneSystem {\r\n    private architect: ProceduralArchitect;\r\n\r\n    constructor(private groundSystem: GroundSystem) {\r\n        this.architect = new ProceduralArchitect();\r\n    }\r\n\r\n    /**\r\n     * Sets a zone for a specific tile.\r\n     */\r\n    public setZone(\r\n        x: number,\r\n        y: number,\r\n        category: string,\r\n        zoneId: string | null,\r\n        worldData: Map<string, ChunkData>,\r\n        loadedChunks: Map<string, PIXI.Container>\r\n    ): void {\r\n        this.setZones([{ x, y, category, zoneId }], worldData, loadedChunks);\r\n    }\r\n\r\n    public async setZones(\r\n        rawUpdates: { x: number; y: number; category: string; zoneId: string | null }[],\r\n        worldData: Map<string, ChunkData>,\r\n        loadedChunks: Map<string, PIXI.Container>\r\n    ): Promise<{ chunkKey: string; idx: number; oldVal: number; newVal: number }[]> {\r\n        const { CHUNK_SIZE, TILE_SIZE } = MapEditorConfig;\r\n\r\n        const chunksToUpdate = new Set<string>();\r\n        const dirtyGroundTiles = new Map<string, Set<string>>();\r\n\r\n        // 1. Process Updates (apply zone changes to worldData)\r\n        rawUpdates.forEach((u) => {\r\n            const { chunkKey, tileKey } = worldToChunkTile(u.x, u.y);\r\n\r\n            let data = worldData.get(chunkKey);\r\n            if (!data) {\r\n                data = { id: chunkKey, objects: [], zones: {} };\r\n                worldData.set(chunkKey, data);\r\n            }\r\n            if (!data.zones) data.zones = {};\r\n            if (!data.zones[tileKey]) data.zones[tileKey] = {};\r\n\r\n            const currentZoneId = data.zones[tileKey][u.category];\r\n            let changed = false;\r\n\r\n            if (u.zoneId === null) {\r\n                if (currentZoneId !== undefined) {\r\n                    delete data.zones[tileKey][u.category];\r\n                    changed = true;\r\n                }\r\n            } else {\r\n                if (currentZoneId !== u.zoneId) {\r\n                    data.zones[tileKey][u.category] = u.zoneId;\r\n                    changed = true;\r\n                }\r\n            }\r\n\r\n            if (changed) {\r\n                chunksToUpdate.add(chunkKey);\r\n                if (\r\n                    u.category === ZoneCategory.BIOME ||\r\n                    u.category === ZoneCategory.CIVILIZATION ||\r\n                    u.category === ZoneCategory.TERRAIN\r\n                ) {\r\n                    markTileAndNeighbors(u.x, u.y, chunkKey, tileKey, dirtyGroundTiles);\r\n                }\r\n            }\r\n        });\r\n\r\n        // 1b. Coast sync: add/remove terrain_coast on grasslands adjacent to water\r\n        const coastUpdates = this.architect.computeCoastUpdates(\r\n            worldData,\r\n            new Set(dirtyGroundTiles.keys())\r\n        );\r\n        for (const u of coastUpdates) {\r\n            const { chunkKey, tileKey } = worldToChunkTile(u.x, u.y);\r\n\r\n            const data = worldData.get(chunkKey);\r\n            if (!data) continue;\r\n            if (!data.zones) data.zones = {};\r\n            if (!data.zones[tileKey]) data.zones[tileKey] = {};\r\n\r\n            const current = data.zones[tileKey][u.category];\r\n            if (u.zoneId === null) {\r\n                if (current !== undefined) {\r\n                    delete data.zones[tileKey][u.category];\r\n                    chunksToUpdate.add(chunkKey);\r\n                    markTileAndNeighbors(u.x, u.y, chunkKey, tileKey, dirtyGroundTiles);\r\n                }\r\n            } else if (current !== u.zoneId) {\r\n                data.zones[tileKey][u.category] = u.zoneId;\r\n                chunksToUpdate.add(chunkKey);\r\n                markTileAndNeighbors(u.x, u.y, chunkKey, tileKey, dirtyGroundTiles);\r\n            }\r\n        }\r\n\r\n        // 1c. Splats for coast tiles (grass+sand blend)\r\n        const allSplatChanges: { chunkKey: string; idx: number; oldVal: number; newVal: number }[] =\r\n            [];\r\n        const dirtyTilesForSplats: { x: number; y: number }[] = [];\r\n        for (const [chunkKey, tiles] of dirtyGroundTiles) {\r\n            const [cx, cy] = chunkKey.split(',').map(Number);\r\n            for (const tileKey of tiles) {\r\n                const [lx, ly] = tileKey.split(',').map(Number);\r\n                dirtyTilesForSplats.push({\r\n                    x: (cx * CHUNK_SIZE + lx) * TILE_SIZE,\r\n                    y: (cy * CHUNK_SIZE + ly) * TILE_SIZE\r\n                });\r\n            }\r\n        }\r\n        if (dirtyTilesForSplats.length > 0) {\r\n            const splats = this.architect.evaluateSplats(dirtyTilesForSplats, worldData);\r\n            const changes = await this.groundSystem.paintSplatBatch(\r\n                splats,\r\n                true,\r\n                worldData,\r\n                loadedChunks\r\n            );\r\n            allSplatChanges.push(...changes);\r\n        }\r\n\r\n        // 2. Batch Render Overlays\r\n        chunksToUpdate.forEach((chunkKey) => {\r\n            const chunkContainer = loadedChunks.get(chunkKey);\r\n            const data = worldData.get(chunkKey);\r\n            if (chunkContainer && data && data.zones) {\r\n                this.renderZoneOverlay(chunkContainer, data.zones);\r\n            }\r\n        });\r\n\r\n        // 3. Update Ground Textures (only tiles not already re-rendered by paintSplatBatch)\r\n        const alreadyRendered = new Set<string>();\r\n        for (const c of allSplatChanges) {\r\n            const SPLATS_PER_CHUNK = MapEditorConfig.SPLAT_RES;\r\n            const localSx = c.idx % SPLATS_PER_CHUNK;\r\n            const localSy = Math.floor(c.idx / SPLATS_PER_CHUNK);\r\n            alreadyRendered.add(\r\n                `${c.chunkKey}:${Math.floor(localSx / 4)},${Math.floor(localSy / 4)}`\r\n            );\r\n        }\r\n        for (const [chunkKey, tiles] of dirtyGroundTiles) {\r\n            if (!loadedChunks.has(chunkKey)) continue;\r\n            const chunk = loadedChunks.get(chunkKey);\r\n            const data = worldData.get(chunkKey);\r\n            if (!chunk || !data) continue;\r\n            let groundLayer = chunk.getChildByLabel('ground_layer') as PIXI.Container;\r\n            if (!groundLayer) {\r\n                groundLayer = new PIXI.Container();\r\n                (groundLayer as { label?: string }).label = 'ground_layer';\r\n                chunk.addChildAt(groundLayer, 0);\r\n            }\r\n            const remaining = Array.from(tiles).filter(\r\n                (tKey) => !alreadyRendered.has(`${chunkKey}:${tKey}`)\r\n            );\r\n            if (remaining.length > 0) {\r\n                await Promise.all(\r\n                    remaining.map((tKey) => {\r\n                        const [lx, ly] = tKey.split(',').map(Number);\r\n                        return this.groundSystem.updateTile(\r\n                            chunkKey,\r\n                            lx,\r\n                            ly,\r\n                            data!,\r\n                            groundLayer,\r\n                            undefined,\r\n                            undefined,\r\n                            undefined,\r\n                            worldData\r\n                        );\r\n                    })\r\n                );\r\n            }\r\n        }\r\n\r\n        return allSplatChanges;\r\n    }\r\n\r\n    public getZone(\r\n        x: number,\r\n        y: number,\r\n        category: string,\r\n        worldData: Map<string, ChunkData>\r\n    ): string | null {\r\n        const { chunkKey, tileKey } = worldToChunkTile(x, y);\r\n        const data = worldData.get(chunkKey);\r\n        if (!data || !data.zones) return null;\r\n        return data.zones[tileKey]?.[category] || null;\r\n    }\r\n\r\n    /** Regenerate splat data from zone state. Called on map load. */\r\n    public regenerateSplats(worldData: Map<string, ChunkData>): void {\r\n        regenerateSplats(worldData, this.architect);\r\n    }\r\n\r\n    public renderZoneOverlay(\r\n        container: PIXI.Container,\r\n        zones: Record<string, Record<string, string>>\r\n    ) {\r\n        // Reuse or create a Container for zone sprites\r\n        let overlayContainer = container.getChildByLabel('zone_overlay') as PIXI.Container;\r\n        if (!overlayContainer) {\r\n            overlayContainer = new PIXI.Container();\r\n            overlayContainer.label = 'zone_overlay';\r\n            container.addChild(overlayContainer);\r\n        }\r\n\r\n        const { TILE_SIZE } = MapEditorConfig;\r\n\r\n        // Hide all existing sprites (return to pool)\r\n        for (let i = 0; i < overlayContainer.children.length; i++) {\r\n            overlayContainer.children[i].visible = false;\r\n        }\r\n\r\n        let spriteIndex = 0;\r\n\r\n        // Iterate all tiles in this chunk that have zones\r\n        for (const [tileKey, categories] of Object.entries(zones)) {\r\n            const [lx, ly] = tileKey.split(',').map(Number);\r\n\r\n            Object.entries(categories).forEach(([cat, zoneId]) => {\r\n                const def = ZoneConfig[zoneId];\r\n                const isVisible = !EditorContext.hiddenZoneIds.has(zoneId);\r\n\r\n                if (def && isVisible) {\r\n                    let sprite = overlayContainer.children[spriteIndex] as PIXI.Sprite;\r\n                    if (!sprite) {\r\n                        sprite = new PIXI.Sprite(PIXI.Texture.WHITE);\r\n                        sprite.width = TILE_SIZE;\r\n                        sprite.height = TILE_SIZE;\r\n                        overlayContainer.addChild(sprite);\r\n                    }\r\n\r\n                    sprite.x = lx * TILE_SIZE;\r\n                    sprite.y = ly * TILE_SIZE;\r\n                    sprite.tint = def.color;\r\n                    sprite.alpha = 0.3;\r\n                    sprite.visible = true;\r\n\r\n                    spriteIndex++;\r\n                }\r\n            });\r\n        }\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\ZoneSystemSplatRegen.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\ZoneSystemUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\commands\\AddManualStationCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\commands\\AddManualTownCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\commands\\AddWaypointCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\commands\\BatchObjectCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\commands\\CommandManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\commands\\EditorCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\commands\\MoveObjectCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\commands\\PlaceObjectCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\commands\\RemoveManualStationCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\commands\\RemoveManualTownCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\commands\\RemoveObjectCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\commands\\RemoveWaypointCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\commands\\SetHeroSpawnCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\commands\\SetManualStationRegionCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\commands\\SetManualTownAtCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\commands\\UpdateWaypointRegionCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\data\\ProceduralRules.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\mapgen4\\Prng.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\mapgen4\\buildMesh.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\mapgen4\\delaunator.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\mapgen4\\dual-mesh\\create.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\mapgen4\\dual-mesh\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\mapgen4\\generate-points.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\mapgen4\\geometry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\mapgen4\\map.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'elevation_t' is assigned a value but never used.","line":139,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":139,"endColumn":34}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/*\r\n * From https://www.redblobgames.com/maps/mapgen4/\r\n * Copyright 2018 Red Blob Games\r\n * License: Apache v2.0\r\n */\r\n\r\nimport { createNoise2D } from 'simplex-noise';\r\nimport FlatQueue from 'flatqueue';\r\nimport { makeRandFloat } from './Prng';\r\nimport { clamp } from './geometry';\r\nimport type { Mesh } from './types';\r\n\r\ninterface PrecalculatedNoise {\r\n    noise0_t: Float32Array;\r\n    noise1_t: Float32Array;\r\n    noise2_t: Float32Array;\r\n    noise4_t: Float32Array;\r\n    noise5_t: Float32Array;\r\n    noise6_t: Float32Array;\r\n}\r\n\r\nconst mountain = { slope: 16 };\r\n\r\nfunction calculateMountainDistance(\r\n    mesh: Mesh,\r\n    t_peaks: number[],\r\n    spacing: number,\r\n    jaggedness: number,\r\n    randFloat: () => number,\r\n    distance_t: Float32Array\r\n): void {\r\n    distance_t.fill(-1);\r\n    const t_queue = t_peaks.slice();\r\n    for (let i = 0; i < t_queue.length; i++) {\r\n        const t_current = t_queue[i];\r\n        for (let j = 0; j < 3; j++) {\r\n            const s = 3 * t_current + j;\r\n            const t_neighbor = mesh.t_outer_s(s);\r\n            if (distance_t[t_neighbor] === -1) {\r\n                const increment = spacing * (1 + jaggedness * (randFloat() - randFloat()));\r\n                distance_t[t_neighbor] = distance_t[t_current] + increment;\r\n                t_queue.push(t_neighbor);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction precalculateNoise(randFloat: () => number, mesh: Mesh): PrecalculatedNoise {\r\n    const noise2D = createNoise2D(randFloat);\r\n    const { numTriangles } = mesh;\r\n    const noise0_t = new Float32Array(numTriangles);\r\n    const noise1_t = new Float32Array(numTriangles);\r\n    const noise2_t = new Float32Array(numTriangles);\r\n    const noise4_t = new Float32Array(numTriangles);\r\n    const noise5_t = new Float32Array(numTriangles);\r\n    const noise6_t = new Float32Array(numTriangles);\r\n    for (let t = 0; t < numTriangles; t++) {\r\n        const nx = (mesh.x_of_t(t) - 500) / 500;\r\n        const ny = (mesh.y_of_t(t) - 500) / 500;\r\n        noise0_t[t] = noise2D(nx, ny);\r\n        noise1_t[t] = noise2D(2 * nx + 5, 2 * ny + 5);\r\n        noise2_t[t] = noise2D(4 * nx + 7, 4 * ny + 7);\r\n        noise4_t[t] = noise2D(16 * nx + 15, 16 * ny + 15);\r\n        noise5_t[t] = noise2D(32 * nx + 31, 32 * ny + 31);\r\n        noise6_t[t] = noise2D(64 * nx + 67, 64 * ny + 67);\r\n    }\r\n    return { noise0_t, noise1_t, noise2_t, noise4_t, noise5_t, noise6_t };\r\n}\r\n\r\nexport interface ElevationParam {\r\n    seed: number;\r\n    island: number;\r\n    noisy_coastlines: number;\r\n    hill_height: number;\r\n    mountain_jagged: number;\r\n    mountain_sharpness: number;\r\n    mountain_folds: number;\r\n    ocean_depth: number;\r\n}\r\n\r\nexport interface BiomesParam {\r\n    wind_angle_deg: number;\r\n    raininess: number;\r\n    rain_shadow: number;\r\n    evaporation: number;\r\n}\r\n\r\nexport interface RiversParam {\r\n    lg_min_flow: number;\r\n    lg_river_width: number;\r\n    flow: number;\r\n}\r\n\r\nexport interface MapConstraints {\r\n    size: number;\r\n    constraints: Float32Array;\r\n}\r\n\r\nexport default class Mapgen4Map {\r\n    seed = -1;\r\n    spacing!: number;\r\n    precomputed!: PrecalculatedNoise;\r\n    mountainJaggedness = -Infinity;\r\n    windAngleDeg = Infinity;\r\n    elevation_t!: Float32Array;\r\n    elevation_r!: Float32Array;\r\n    humidity_r!: Float32Array;\r\n    moisture_t!: Float32Array;\r\n    rainfall_r!: Float32Array;\r\n    s_downslope_t!: Int32Array;\r\n    t_order!: Int32Array;\r\n    flow_t!: Float32Array;\r\n    flow_s!: Float32Array;\r\n    r_wind_order!: Int32Array;\r\n    wind_sort_r!: Float32Array;\r\n    mountain_distance_t!: Float32Array;\r\n\r\n    constructor(\r\n        public mesh: Mesh,\r\n        public t_peaks: number[],\r\n        param: { spacing: number }\r\n    ) {\r\n        this.spacing = param.spacing;\r\n        this.elevation_t = new Float32Array(mesh.numTriangles);\r\n        this.elevation_r = new Float32Array(mesh.numRegions);\r\n        this.humidity_r = new Float32Array(mesh.numRegions);\r\n        this.moisture_t = new Float32Array(mesh.numTriangles);\r\n        this.rainfall_r = new Float32Array(mesh.numRegions);\r\n        this.s_downslope_t = new Int32Array(mesh.numTriangles);\r\n        this.t_order = new Int32Array(mesh.numTriangles);\r\n        this.flow_t = new Float32Array(mesh.numTriangles);\r\n        this.flow_s = new Float32Array(mesh.numSides);\r\n        this.r_wind_order = new Int32Array(mesh.numRegions);\r\n        this.wind_sort_r = new Float32Array(mesh.numRegions);\r\n        this.mountain_distance_t = new Float32Array(mesh.numTriangles);\r\n    }\r\n\r\n    assignTriangleElevation(elevationParam: ElevationParam, constraints: MapConstraints): void {\r\n        const { mesh, elevation_t, mountain_distance_t, precomputed } = this;\r\n        const { numTriangles, numSolidTriangles } = mesh;\r\n        const C = constraints.constraints;\r\n        const size = constraints.size;\r\n\r\n        function constraintAt(x: number, y: number): number {\r\n            x = clamp(x * (size - 1), 0, size - 2);\r\n            y = clamp(y * (size - 1), 0, size - 2);\r\n            const xInt = Math.floor(x);\r\n            const yInt = Math.floor(y);\r\n            const xFrac = x - xInt;\r\n            const yFrac = y - yInt;\r\n            const p = size * yInt + xInt;\r\n            const e00 = C[p];\r\n            const e01 = C[p + 1];\r\n            const e10 = C[p + size];\r\n            const e11 = C[p + size + 1];\r\n            return (\r\n                (e00 * (1 - xFrac) + e01 * xFrac) * (1 - yFrac) +\r\n                (e10 * (1 - xFrac) + e11 * xFrac) * yFrac\r\n            );\r\n        }\r\n\r\n        for (let t = 0; t < numSolidTriangles; t++) {\r\n            let e = constraintAt(mesh.x_of_t(t) / 1000, mesh.y_of_t(t) / 1000);\r\n            e +=\r\n                elevationParam.noisy_coastlines *\r\n                (1 - e * e * e * e) *\r\n                (precomputed.noise4_t[t] +\r\n                    precomputed.noise5_t[t] / 2 +\r\n                    precomputed.noise6_t[t] / 4);\r\n            this.elevation_t[t] = e;\r\n        }\r\n\r\n        const mountain_slope = mountain.slope;\r\n        const mountain_sharpness = Math.pow(2, elevationParam.mountain_sharpness);\r\n        const { noise0_t, noise1_t, noise2_t, noise4_t } = precomputed;\r\n        for (let t = 0; t < numTriangles; t++) {\r\n            let e = this.elevation_t[t];\r\n            if (e > 0) {\r\n                const noisiness = 1.0 - 0.5 * (1 + noise0_t[t]);\r\n                let eh =\r\n                    (1 + noisiness * noise4_t[t] + (1 - noisiness) * noise2_t[t]) *\r\n                    elevationParam.hill_height;\r\n                if (eh < 0.01) eh = 0.01;\r\n                let em = 1 - (mountain_slope / mountain_sharpness) * mountain_distance_t[t];\r\n                if (em < 0.01) em = 0.01;\r\n                const weight = e * e;\r\n                e = (1 - weight) * eh + weight * em;\r\n            } else {\r\n                e *= elevationParam.ocean_depth + noise1_t[t];\r\n            }\r\n            if (e < -1.0) e = -1.0;\r\n            if (e > 1.0) e = 1.0;\r\n            this.elevation_t[t] = e;\r\n        }\r\n    }\r\n\r\n    assignRegionElevation(): void {\r\n        const { mesh, elevation_t, elevation_r } = this;\r\n        const { _s_of_r, _halfedges } = mesh;\r\n        for (let r = 0; r < mesh.numRegions; r++) {\r\n            let count = 0;\r\n            let e = 0;\r\n            let water = false;\r\n            let s_incoming = _s_of_r[r];\r\n            const s0 = s_incoming;\r\n            do {\r\n                const t = (s_incoming / 3) | 0;\r\n                e += elevation_t[t];\r\n                water = water || elevation_t[t] < 0.0;\r\n                const s_outgoing = mesh.s_next_s(s_incoming);\r\n                s_incoming = _halfedges[s_outgoing];\r\n                count++;\r\n            } while (s_incoming !== s0);\r\n            e /= count;\r\n            if (water && e >= 0) e = -0.001;\r\n            elevation_r[r] = e;\r\n        }\r\n    }\r\n\r\n    assignElevation(elevationParam: ElevationParam, constraints: MapConstraints): void {\r\n        if (\r\n            this.seed !== elevationParam.seed ||\r\n            this.mountainJaggedness !== elevationParam.mountain_jagged\r\n        ) {\r\n            this.mountainJaggedness = elevationParam.mountain_jagged;\r\n            calculateMountainDistance(\r\n                this.mesh,\r\n                this.t_peaks,\r\n                this.spacing,\r\n                this.mountainJaggedness,\r\n                makeRandFloat(elevationParam.seed),\r\n                this.mountain_distance_t\r\n            );\r\n        }\r\n        if (this.seed !== elevationParam.seed) {\r\n            this.seed = elevationParam.seed;\r\n            this.precomputed = precalculateNoise(makeRandFloat(elevationParam.seed), this.mesh);\r\n        }\r\n        this.assignTriangleElevation(elevationParam, constraints);\r\n        this.assignRegionElevation();\r\n    }\r\n\r\n    assignRainfall(biomesParam: BiomesParam): void {\r\n        const { mesh, r_wind_order, wind_sort_r, humidity_r, rainfall_r, elevation_r } = this;\r\n        const { _s_of_r, _halfedges } = mesh;\r\n\r\n        if (biomesParam.wind_angle_deg !== this.windAngleDeg) {\r\n            this.windAngleDeg = biomesParam.wind_angle_deg;\r\n            const windAngleRad = (Math.PI / 180) * this.windAngleDeg;\r\n            const windAngleVec = [Math.cos(windAngleRad), Math.sin(windAngleRad)];\r\n            for (let r = 0; r < mesh.numRegions; r++) {\r\n                r_wind_order[r] = r;\r\n                wind_sort_r[r] =\r\n                    mesh.x_of_r(r) * windAngleVec[0] + mesh.y_of_r(r) * windAngleVec[1];\r\n            }\r\n            r_wind_order.sort((r1, r2) => wind_sort_r[r1] - wind_sort_r[r2]);\r\n        }\r\n\r\n        for (let i = 0; i < r_wind_order.length; i++) {\r\n            const r = r_wind_order[i];\r\n            let count = 0;\r\n            let sum = 0.0;\r\n            let s_incoming = _s_of_r[r];\r\n            const s0 = s_incoming;\r\n            do {\r\n                const r_neighbor = mesh.r_begin_s(s_incoming);\r\n                if (wind_sort_r[r_neighbor] < wind_sort_r[r]) {\r\n                    count++;\r\n                    sum += humidity_r[r_neighbor];\r\n                }\r\n                const s_outgoing = mesh.s_next_s(s_incoming);\r\n                s_incoming = _halfedges[s_outgoing];\r\n            } while (s_incoming !== s0);\r\n\r\n            let humidity = 0.0;\r\n            let rainfall = 0.0;\r\n            if (count > 0) {\r\n                humidity = sum / count;\r\n                rainfall += biomesParam.raininess * humidity;\r\n            }\r\n            if (mesh.is_boundary_r(r)) humidity = 1.0;\r\n            if (elevation_r[r] < 0.0) {\r\n                const evaporation = biomesParam.evaporation * -elevation_r[r];\r\n                humidity += evaporation;\r\n            }\r\n            if (humidity > 1.0 - elevation_r[r]) {\r\n                const orographicRainfall =\r\n                    biomesParam.rain_shadow * (humidity - (1.0 - elevation_r[r]));\r\n                rainfall += biomesParam.raininess * orographicRainfall;\r\n                humidity -= orographicRainfall;\r\n            }\r\n            rainfall_r[r] = rainfall;\r\n            humidity_r[r] = humidity;\r\n        }\r\n    }\r\n\r\n    assignRivers(riversParam: RiversParam): void {\r\n        const {\r\n            mesh,\r\n            moisture_t,\r\n            rainfall_r,\r\n            elevation_t,\r\n            s_downslope_t,\r\n            t_order,\r\n            flow_t,\r\n            flow_s\r\n        } = this;\r\n        assignDownslope(mesh, elevation_t, s_downslope_t, t_order);\r\n        assignMoisture(mesh, rainfall_r, moisture_t);\r\n        assignFlow(\r\n            mesh,\r\n            riversParam,\r\n            t_order,\r\n            elevation_t,\r\n            moisture_t,\r\n            s_downslope_t,\r\n            flow_t,\r\n            flow_s\r\n        );\r\n    }\r\n}\r\n\r\nconst queue = new FlatQueue<number>();\r\n\r\nfunction assignDownslope(\r\n    mesh: Mesh,\r\n    elevation_t: Float32Array,\r\n    s_downslope_t: Int32Array,\r\n    t_order: Int32Array\r\n): void {\r\n    const { numTriangles } = mesh;\r\n    let queue_in = 0;\r\n    s_downslope_t.fill(-999);\r\n    for (let t = 0; t < numTriangles; t++) {\r\n        if (elevation_t[t] < -0.1) {\r\n            let s_best = -1;\r\n            let e_best = elevation_t[t];\r\n            for (let j = 0; j < 3; j++) {\r\n                const s = 3 * t + j;\r\n                const e = elevation_t[mesh.t_outer_s(s)];\r\n                if (e < e_best) {\r\n                    e_best = e;\r\n                    s_best = s;\r\n                }\r\n            }\r\n            t_order[queue_in++] = t;\r\n            s_downslope_t[t] = s_best;\r\n            queue.push(t, elevation_t[t]);\r\n        }\r\n    }\r\n    for (let queue_out = 0; queue_out < numTriangles; queue_out++) {\r\n        const t_current = queue.pop()!;\r\n        for (let j = 0; j < 3; j++) {\r\n            const s = 3 * t_current + j;\r\n            const t_neighbor = mesh.t_outer_s(s);\r\n            if (s_downslope_t[t_neighbor] === -999) {\r\n                s_downslope_t[t_neighbor] = mesh.s_opposite_s(s);\r\n                t_order[queue_in++] = t_neighbor;\r\n                queue.push(t_neighbor, elevation_t[t_neighbor]);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction assignMoisture(mesh: Mesh, rainfall_r: Float32Array, moisture_t: Float32Array): void {\r\n    const { numTriangles } = mesh;\r\n    for (let t = 0; t < numTriangles; t++) {\r\n        let moisture = 0.0;\r\n        for (let i = 0; i < 3; i++) {\r\n            const s = 3 * t + i;\r\n            const r = mesh.r_begin_s(s);\r\n            moisture += rainfall_r[r] / 3;\r\n        }\r\n        moisture_t[t] = moisture;\r\n    }\r\n}\r\n\r\nfunction assignFlow(\r\n    mesh: Mesh,\r\n    riversParam: RiversParam,\r\n    t_order: Int32Array,\r\n    elevation_t: Float32Array,\r\n    moisture_t: Float32Array,\r\n    s_downslope_t: Int32Array,\r\n    flow_t: Float32Array,\r\n    flow_s: Float32Array\r\n): void {\r\n    const { numTriangles, _halfedges } = mesh;\r\n    flow_s.fill(0);\r\n    for (let t = 0; t < numTriangles; t++) {\r\n        if (elevation_t[t] >= 0.0) {\r\n            flow_t[t] = riversParam.flow * moisture_t[t] * moisture_t[t];\r\n        } else {\r\n            flow_t[t] = 0;\r\n        }\r\n    }\r\n    for (let i = t_order.length - 1; i >= 0; i--) {\r\n        const t_tributary = t_order[i];\r\n        const s_flow = s_downslope_t[t_tributary];\r\n        if (s_flow >= 0) {\r\n            const t_trunk = (_halfedges[s_flow] / 3) | 0;\r\n            flow_t[t_trunk] += flow_t[t_tributary];\r\n            flow_s[s_flow] += flow_t[t_tributary];\r\n            if (\r\n                elevation_t[t_trunk] > elevation_t[t_tributary] &&\r\n                elevation_t[t_tributary] >= 0.0\r\n            ) {\r\n                elevation_t[t_trunk] = elevation_t[t_tributary];\r\n            }\r\n        }\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\mapgen4\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\utils\\CoordinateTransform.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\tools\\map-editor\\utils\\SeededRandom.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\types\\core.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\types\\entities.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\types\\global.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\types\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\types\\rendering.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\types\\ui.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\types\\vfx.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\types\\world.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\ui\\Components.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\ui\\ContextActionUI.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getConfig' is defined but never used.","line":10,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":34,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"getConfig"},"fix":{"range":[316,327],"text":""},"desc":"Remove unused variable \"getConfig\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'data' is defined but never used. Allowed unused args must match /^_/u.","line":130,"column":38,"nodeType":"Identifier","messageId":"unusedVar","endLine":130,"endColumn":42}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * ContextActionUI - Context-Sensitive Action Button Manager\r\n *\r\n * Separated from UIManager for single responsibility.\r\n * Handles the floating context action button (REST, FORGE, UNLOCK, SHOP).\r\n */\r\n\r\nimport { Logger } from '@core/Logger';\r\nimport { EventBus } from '@core/EventBus';\r\nimport { GameConstants, getConfig } from '@data/GameConstants';\r\nimport { AssetLoader } from '@core/AssetLoader';\r\nimport { AudioManager } from '../audio/AudioManager';\r\n\r\ntype ContextData = {\r\n    gridX?: number;\r\n    gridY?: number;\r\n    unlockCost?: number;\r\n    visible?: boolean;\r\n    type?: string;\r\n} | null;\r\n\r\nclass ContextActionService {\r\n    // Property declarations\r\n    btn: HTMLElement | null = null;\r\n    icon: HTMLElement | null = null;\r\n    label: HTMLElement | null = null;\r\n    activeContext: string | null = null;\r\n    contextData: ContextData = null;\r\n    isSuspended: boolean = false;\r\n\r\n    constructor() {\r\n        // Properties initialized as class fields above\r\n    }\r\n\r\n    init() {\r\n        this.btn = document.getElementById('btn-context-action');\r\n        this.icon = document.getElementById('context-icon');\r\n        this.label = document.getElementById('context-label');\r\n\r\n        if (this.btn) {\r\n            this.btn.addEventListener('click', () => this.execute());\r\n        }\r\n\r\n        // EventBus Listeners\r\n        if (EventBus && GameConstants) {\r\n            const E = GameConstants.Events;\r\n\r\n\r\n            // Rest/Home\r\n            EventBus.on(E.HOME_BASE_ENTERED, () => this.show('rest'));\r\n            EventBus.on(E.HOME_BASE_EXITED, () => this.hide('rest'));\r\n\r\n            // Forge\r\n            EventBus.on(E.FORGE_ENTERED, () => this.show('forge'));\r\n            EventBus.on(E.FORGE_EXITED, () => this.hide('forge'));\r\n\r\n            // Merchant\r\n            EventBus.on(E.INTERACTION_OPPORTUNITY, (data: ContextData) => {\r\n                if (data?.type === 'merchant') {\r\n                    if (data.visible) this.show('merchant', data);\r\n                    else this.hide('merchant');\r\n                }\r\n            });\r\n        }\r\n\r\n        Logger.debug('[ContextActionUI]', 'Initialized');\r\n    }\r\n\r\n    suspend() {\r\n        this.isSuspended = true;\r\n        // Don't clear DOM here, let the overriding UI overwrite it.\r\n        // We just stop responding to game events.\r\n    }\r\n\r\n    resume() {\r\n        this.isSuspended = false;\r\n        // Restore our state\r\n        if (this.activeContext) {\r\n            this.show(this.activeContext, this.contextData);\r\n        } else {\r\n            this._clearDOM();\r\n        }\r\n    }\r\n\r\n    private _clearDOM() {\r\n        if (this.btn) this.btn.classList.remove('active');\r\n        if (this.icon) this.icon.style.backgroundImage = 'none';\r\n        if (this.label) this.label.textContent = '';\r\n    }\r\n\r\n    show(type: string, data: ContextData = null) {\r\n        this.activeContext = type;\r\n        this.contextData = data;\r\n        if (!this.isSuspended) {\r\n            this._updateDOM(type, data);\r\n        }\r\n    }\r\n\r\n    hide(type: string) {\r\n        if (this.activeContext !== type) return;\r\n        this.activeContext = null;\r\n        this.contextData = null;\r\n        if (!this.isSuspended) {\r\n            this._clearDOM();\r\n        }\r\n    }\r\n\r\n    execute() {\r\n        if (this.isSuspended || !this.activeContext) return;\r\n\r\n        Logger.debug('[ContextActionUI]', `Executing: ${this.activeContext}`);\r\n        if (AudioManager) AudioManager.playSFX('sfx_ui_click');\r\n\r\n        const E = GameConstants ? GameConstants.Events : null;\r\n\r\n        switch (this.activeContext) {\r\n            case 'rest':\r\n                if (E && EventBus) EventBus.emit(E.REQUEST_REST);\r\n                break;\r\n            case 'forge':\r\n                if (E && EventBus) EventBus.emit(E.OPEN_FORGE, { view: 'dashboard' });\r\n                break;\r\n\r\n            case 'merchant':\r\n                if (E && EventBus) EventBus.emit(E.OPEN_MERCHANT);\r\n                break;\r\n        }\r\n    }\r\n\r\n    private _updateDOM(type: string, data: ContextData) {\r\n        if (!this.btn) return;\r\n\r\n        const configMap: Record<string, { iconId: string; label: string }> = {\r\n            rest: { iconId: 'ui_icon_rest', label: 'REST' },\r\n            forge: { iconId: 'ui_icon_forge', label: 'FORGE' },\r\n            merchant: { iconId: 'ui_icon_shop', label: 'SHOP' }\r\n        };\r\n        const config = configMap[type] || { iconId: '', label: '' };\r\n\r\n        // Update Icon\r\n        if (this.icon && AssetLoader) {\r\n            const path = AssetLoader.getImagePath(config.iconId);\r\n            if (path) {\r\n                this.icon.style.backgroundImage = `url('${path}')`;\r\n                this.icon.style.backgroundSize = 'contain';\r\n            }\r\n        }\r\n\r\n        // Update Label\r\n        if (this.label) this.label.textContent = config.label;\r\n\r\n        this.btn.classList.add('active');\r\n        Logger.debug('[ContextActionUI]', `Shown: ${type}`);\r\n    }\r\n}\r\n\r\n// Create singleton and export\r\nconst ContextActionUI = new ContextActionService();\r\n\r\nexport { ContextActionService, ContextActionUI };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\ui\\DebugUI.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\ui\\DebugUIOverrides.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\ui\\EquipmentSlotManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\ui\\EquipmentUI.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'HeroSkinSelector' is defined but never used.","line":19,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":26,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"HeroSkinSelector"},"fix":{"range":[735,789],"text":""},"desc":"Remove unused import declaration."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * EquipmentUI - Fullscreen equipment management screen (Core)\n *\n * Delegates to:\n * - EquipmentUIRenderer: All HTML/template rendering\n * - EquipmentSlotManager: Equip/unequip/slot logic\n * - EquipmentUIFilterConfig: Filter hierarchy\n * - EquipmentUIFooter: Footer swap/restore\n * - EquipmentUIClickHandler: Event delegation\n */\nimport { GameConstants } from '@data/GameConstants';\nimport { Logger } from '@core/Logger';\nimport { EquipmentSlotManager } from './EquipmentSlotManager';\nimport { EntityLoader } from '@entities/EntityLoader';\nimport { EquipmentUIRenderer } from './EquipmentUIRenderer';\nimport { Registry } from '@core/Registry';\nimport { DOMUtils } from '@core/DOMUtils';\nimport { GameInstance } from '@core/Game';\nimport { HeroSkinSelector } from './HeroSkinSelector';\nimport { MODE_CATEGORIES } from './EquipmentUIFilterConfig';\nimport { getFilterHierarchy } from './EquipmentUIFilterConfig';\nimport { WeaponWheelInstance } from './WeaponWheel';\nimport { swapFooterToEquipmentMode, restoreFooterButtons } from './EquipmentUIFooter';\nimport { handleEquipmentUIClick } from './EquipmentUIClickHandler';\nimport type { EquipmentItem, IFooterConfig } from '../types/ui';\n\nexport interface FilterCategory {\n    id: string;\n    label: string;\n    iconId?: string;\n    children?: FilterCategory[];\n}\n\nclass EquipmentUI {\n    isOpen: boolean;\n    selectedMode: string;\n    selectedCategory: string;\n    selectedItem: EquipmentItem | null;\n    container: HTMLElement | null;\n    cachedEquipment: EquipmentItem[];\n    lastClickedItemId: string | null;\n    lastClickTime: number;\n    slotSelectionMode: boolean;\n    pendingEquipItem: EquipmentItem | null;\n    targetEquipSet: number;\n    originalFooterConfigs: IFooterConfig | null = null;\n    slots: string[];\n    toolSlots: string[];\n    modeCategories: Record<string, FilterCategory[]>;\n\n    constructor() {\n        this.isOpen = false;\n        this.selectedMode = 'armor';\n        this.selectedCategory = 'all';\n        this.selectedItem = null;\n        this.container = null;\n        this.cachedEquipment = [];\n        this.lastClickedItemId = null;\n        this.lastClickTime = 0;\n        this.slotSelectionMode = false;\n        this.pendingEquipItem = null;\n        this.targetEquipSet = 1;\n        this.originalFooterConfigs = null;\n\n        const equipCfg = GameConstants?.Equipment || {\n            ALL_SLOTS: undefined,\n            TOOL_SLOTS: undefined\n        };\n        this.slots = equipCfg.ALL_SLOTS || [\n            'head',\n            'body',\n            'hands',\n            'legs',\n            'accessory',\n            'hand1',\n            'hand2',\n            'accessory2'\n        ];\n        this.toolSlots = equipCfg.TOOL_SLOTS || [\n            'tool_mining',\n            'tool_woodcutting',\n            'tool_harvesting',\n            'tool_fishing'\n        ];\n        this.modeCategories = MODE_CATEGORIES;\n\n        if (document.readyState === 'loading') {\n            document.addEventListener('DOMContentLoaded', () => this._init());\n        } else {\n            this._init();\n        }\n    }\n\n    _init() {\n        const btnEquip = document.getElementById('btn-equip');\n        if (btnEquip) {\n            btnEquip.addEventListener('click', () => {\n                if (btnEquip.dataset.footerOverride) return;\n                this.toggle();\n            });\n        }\n\n        this._createContainer();\n\n        const uiMgr = Registry.get('UIManager');\n        if (uiMgr && uiMgr.registerFullscreenUI) {\n            uiMgr.registerFullscreenUI(this);\n            Logger.info('[EquipmentUI] Registered with UIManager');\n        } else {\n            Logger.error('[EquipmentUI] Failed to register with UIManager');\n        }\n\n        Logger.info('[EquipmentUI] Initialized');\n    }\n\n    _createContainer() {\n        this.container = DOMUtils.create('div', {\n            id: 'equipment-screen',\n            className: 'equipment-screen',\n            styles: { display: 'none' }\n        });\n\n        this.container.addEventListener('click', (e) => handleEquipmentUIClick(this, e));\n        this.container.addEventListener('dblclick', (e) => {\n            const invItem = (e.target as HTMLElement).closest('.inventory-item');\n            if ((invItem as HTMLElement)?.dataset.id) {\n                EquipmentSlotManager.equipItem(this, (invItem as HTMLElement).dataset.id!);\n            }\n        });\n\n        const uiOverlay = document.getElementById('ui-overlay');\n        (uiOverlay || document.body).appendChild(this.container);\n    }\n\n    toggle() {\n        if (this.isOpen) {\n            this.close();\n        } else {\n            this.open();\n        }\n    }\n\n    open() {\n        WeaponWheelInstance.close();\n\n        const uiMgr = Registry.get('UIManager');\n        if (uiMgr && uiMgr.closeOtherFullscreenUIs) {\n            uiMgr.closeOtherFullscreenUIs(this);\n        }\n\n        const hero = GameInstance?.hero;\n        if (hero?.equipment?.activeWeaponSet) {\n            this.targetEquipSet = hero.equipment.activeWeaponSet;\n        }\n\n        swapFooterToEquipmentMode(this);\n        this.isOpen = true;\n        this._loadEquipment();\n        this._render();\n        this.container!.style.display = 'flex';\n        Logger.info('[EquipmentUI] Opened');\n    }\n\n    close() {\n        this.isOpen = false;\n        this.container!.style.display = 'none';\n        restoreFooterButtons(this);\n        Logger.info('[EquipmentUI] Closed');\n    }\n\n    _getFilterHierarchy(): FilterCategory[] {\n        return getFilterHierarchy(this.selectedMode);\n    }\n\n    _updateFooterActiveStates() {\n        const btnInventory = document.getElementById('btn-inventory');\n        const btnEquip = document.getElementById('btn-equip');\n        const btnMap = document.getElementById('btn-map');\n        btnInventory?.classList.toggle('active', this.selectedMode === 'armor');\n        btnEquip?.classList.toggle('active', this.selectedMode === 'weapon');\n        btnMap?.classList.toggle('active', this.selectedMode === 'tool');\n    }\n\n    _loadEquipment() {\n        const allEquipment = EntityLoader?.getAllEquipment?.() || [];\n        const filterParts = this.selectedCategory?.split(':') || ['all'];\n        const grip = filterParts[0];\n        const weaponType = filterParts[1];\n        const subtype = filterParts[2];\n\n        if (this.selectedMode === 'armor') {\n            this.cachedEquipment = allEquipment.filter(\n                (e) =>\n                    grip === 'all' ||\n                    e.sourceFile === grip ||\n                    e.slot === grip ||\n                    e.equipSlot === grip\n            );\n        } else if (this.selectedMode === 'weapon') {\n            this.cachedEquipment = allEquipment.filter((e) => {\n                const isWeapon =\n                    e.weaponType !== undefined || e.sourceFile === 'weapon' || e.slot === 'weapon';\n                if (!isWeapon) return false;\n                if (grip !== 'all' && e.gripType !== grip) return false;\n                if (weaponType) {\n                    const isShieldAsMelee = weaponType === 'melee' && e.weaponType === 'shield';\n                    if (!isShieldAsMelee && e.weaponType !== weaponType) return false;\n                }\n                if (subtype && e.weaponSubtype !== subtype && !e.id.includes(subtype)) return false;\n                return true;\n            });\n        } else if (this.selectedMode === 'tool') {\n            this.cachedEquipment = allEquipment.filter((e) => {\n                const isTool = e.sourceFile === 'tool' || e.slot === 'tool';\n                if (!isTool) return false;\n                return grip === 'all' || e.id.includes(grip);\n            });\n        } else {\n            this.cachedEquipment = allEquipment;\n        }\n    }\n\n    _render() {\n        this.container!.innerHTML = EquipmentUIRenderer.renderPanel(this);\n        EquipmentUIRenderer.loadIcons(this.container!);\n    }\n\n    _selectItemNoRender(itemId: string) {\n        const item = this.cachedEquipment.find((e) => e.id === itemId);\n        this.selectedItem = item || null;\n\n        this.container!.querySelectorAll('.inventory-item').forEach((el) => {\n            el.classList.toggle('selected', (el as HTMLElement).dataset.id === itemId);\n        });\n\n        const nameEl = this.container!.querySelector('.item-preview-name');\n        const statsRow = this.container!.querySelector('.item-stats-row');\n        if (item && nameEl) {\n            nameEl.textContent = item.name;\n            if (statsRow) statsRow.innerHTML = EquipmentUIRenderer.renderItemStats(item);\n            this.container!.querySelector('.equip-summary-bar')?.classList.add('has-item');\n            this.container!.querySelector('.equip-summary-bar')?.classList.remove('empty');\n        }\n    }\n\n    _selectItem(itemId: string) {\n        const item = this.cachedEquipment.find((e) => e.id === itemId);\n        this.selectedItem = item || null;\n        this._render();\n    }\n\n    _selectEquippedSlot(slotId: string) {\n        const hero = GameInstance?.hero;\n        const equippedItem = hero?.equipment?.getSlot(slotId);\n\n        if (equippedItem) {\n            this.selectedItem = equippedItem;\n\n            this.container!.querySelectorAll('.equip-slot').forEach((el) => {\n                el.classList.toggle('selected', (el as HTMLElement).dataset.slot === slotId);\n            });\n\n            this.container!.querySelectorAll('.inventory-item').forEach((el) => {\n                el.classList.remove('selected');\n            });\n\n            const nameEl = this.container!.querySelector('.item-preview-name');\n            const statsRow = this.container!.querySelector('.item-stats-row');\n            if (nameEl) {\n                nameEl.textContent = equippedItem.name;\n                if (statsRow)\n                    statsRow.innerHTML = EquipmentUIRenderer.renderItemStats(equippedItem);\n                this.container!.querySelector('.equip-summary-bar')?.classList.add('has-item');\n                this.container!.querySelector('.equip-summary-bar')?.classList.remove('empty');\n            }\n        }\n    }\n}\n\nconst equipmentUIInstance = new EquipmentUI();\nif (Registry) Registry.register('EquipmentUI', equipmentUIInstance);\n\nexport { EquipmentUI, equipmentUIInstance };\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\ui\\EquipmentUIClickHandler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\ui\\EquipmentUIFilterConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\ui\\EquipmentUIFooter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\ui\\EquipmentUIRenderer.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'EntityRegistry' is defined but never used.","line":10,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":24,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"EntityRegistry"},"fix":{"range":[247,303],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Registry' is defined but never used.","line":11,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":18,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"Registry"},"fix":{"range":[305,347],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'itemStats' is assigned a value but never used.","line":43,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":43,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * EquipmentUIRenderer - Rendering logic for EquipmentUI\r\n * Handles all HTML generation and template rendering.\r\n *\r\n * Owner: UI Engineer\r\n */\r\n\r\nimport { AssetLoader } from '@core/AssetLoader';\r\nimport { GameInstance } from '@core/Game';\r\nimport { EntityRegistry } from '@entities/EntityLoader';\r\nimport { Registry } from '@core/Registry';\r\nimport { RenderConfig } from '@config/RenderConfig';\r\n\r\nimport type { EquipmentItem } from '../types/ui';\r\nimport type { EquipmentUI } from './EquipmentUI';\r\nimport { EquipmentManager } from '../systems/EquipmentManager';\r\nimport { renderItemStats } from './EquipmentUIRendererStats';\r\n\r\nclass EquipmentUIRenderer {\r\n    /**\r\n     * Render the main equipment panel\r\n     * @param {EquipmentUI} ui - The EquipmentUI instance\r\n     * @returns {string} HTML string\r\n     */\r\n    static renderPanel(ui: EquipmentUI) {\r\n        const hero = GameInstance?.hero;\r\n        const stats = hero?.components?.stats;\r\n        const equipment = hero?.equipment;\r\n\r\n        // No hero = no stats. Don't fake numbers; the panel simply doesn't have data to show.\r\n        const hasHero = !!hero;\r\n        const health = hasHero ? (hero!.health ?? '') : '';\r\n        const maxHealth = hasHero ? (hero!.maxHealth ?? '') : '';\r\n        const defense = hasHero && stats ? (stats.getDefense?.() ?? '') : '';\r\n        const attack = hasHero && stats ? (stats.getAttack?.() ?? '') : '';\r\n        const critChance = hasHero && stats ? (stats.getCritChance?.() ?? '') : '';\r\n        const hand1Range = hasHero && stats ? (stats.getWeaponRange?.('hand1') ?? '') : '';\r\n        const hand2Range = hasHero && stats ? (stats.getWeaponRange?.('hand2') ?? '') : '';\r\n        const speedBonus = hasHero && equipment ? (equipment.getStatBonus?.('speed') ?? '') : '';\r\n\r\n        // Selected item stats\r\n        const item = ui.selectedItem as EquipmentItem | null;\r\n        const itemStats = item?.stats || {};\r\n        const itemName = item?.name || 'Select Equipment';\r\n\r\n        return `\r\n            <div class=\"equip-panel\">\r\n                <!-- Top Section: Character + Hero Stats -->\r\n                <div class=\"equip-header\">\r\n                    <div class=\"equip-character\">\r\n                        <div class=\"character-sprite\" data-skin-id=\"${EquipmentUIRenderer.getCurrentSkinId()}\"></div>\r\n                    </div>\r\n                    <div class=\"equip-stats-panel\">\r\n                        <div class=\"equip-item-name\">Knight</div>\r\n                        ${hasHero ? `\r\n                        <div class=\"stat-row\"><span class=\"stat-icon\"></span> HP <span class=\"stat-bar health\"></span><span class=\"stat-value\">${health}/${maxHealth}</span></div>\r\n                        <div class=\"stat-row\"><span class=\"stat-icon\"></span> Armor <span class=\"stat-bar armor\"></span><span class=\"stat-value\">${defense}</span></div>\r\n                        <div class=\"stat-row\"><span class=\"stat-icon\"></span> Attack <span class=\"stat-bar attack\"></span><span class=\"stat-value\">${attack}</span></div>\r\n                        <div class=\"stat-grid\">\r\n                            <div class=\"mini-stat\"><span class=\"stat-icon\"></span> SPD <span>${speedBonus}</span></div>\r\n                            <div class=\"mini-stat\"><span class=\"stat-icon\"></span> DEF <span>${defense}</span></div>\r\n                            <div class=\"mini-stat\"><span class=\"stat-icon\"></span> CRIT <span>${critChance}%</span></div>\r\n                            <div class=\"mini-stat\"><span class=\"stat-icon\"></span> RNG <span>${hand1Range}/${hand2Range}</span></div>\r\n                        </div>\r\n                        ` : '<div class=\"stat-row\" style=\"color:#666;\">No knight</div>'}\r\n                    </div>\r\n                </div>\r\n\r\n                <!-- Selected Item Stats Bar -->\r\n                <div class=\"equip-summary-bar ${item ? 'has-item' : 'empty'}\" style=\"width:100%; padding:0; background:rgba(0,0,0,0.5); display:flex; flex-direction:row; align-items:stretch; min-height:${RenderConfig.UI.Equipment.SLOT_SIZE}px;\">\r\n                    <div class=\"item-preview-name text-pixel-outline\" style=\"\r\n                        font-size: ${RenderConfig.UI.Equipment.FONTS.ITEM_NAME_SIZE}; \r\n                        display: flex;\r\n                        align-items: center;\r\n                        justify-content: center;\r\n                        padding: 0 12px; \r\n                        width: 30%; \r\n                        background: ${RenderConfig.UI.Equipment.COLORS.SELECTED_BG};\r\n                        border-right: 1px solid ${RenderConfig.UI.Equipment.COLORS.SELECTED_BORDER};\r\n                        box-sizing: border-box;\r\n                        text-align: center;\r\n                    \">${itemName}</div>\r\n                    <div class=\"item-stats-row\" style=\"flex:1; padding:4px 8px; box-sizing: border-box; display:flex; align-items:center;\">\r\n                        ${item ? renderItemStats(item) : '<div class=\"summary-stat empty\" style=\"width:100%; text-align:center; color:#666;\">Double-tap to equip</div>'}\r\n                    </div>\r\n                </div>\r\n\r\n                <!-- Equipped Slots Grid -->\r\n                <div class=\"equipped-slots\">\r\n                    ${EquipmentUIRenderer.renderEquippedSlots(ui, equipment)}\r\n                </div>\r\n\r\n                <!-- Inventory Grid -->\r\n                <div class=\"equip-inventory\">\r\n                    ${EquipmentUIRenderer.renderInventoryGrid(ui)}\r\n                </div>\r\n\r\n                <!-- Category Tabs (filter buttons at bottom) -->\r\n                <!-- Moved to Action Button -->\r\n                <div class=\"equip-tabs\"></div>\r\n            </div>\r\n        `;\r\n    }\r\n\r\n    /**\r\n     * Render equipped slots grid\r\n     * @param {EquipmentUI} ui - The EquipmentUI instance\r\n     * @param {EquipmentManager} equipment - Hero equipment manager\r\n     * @returns {string} HTML string\r\n     */\r\n    static renderEquippedSlots(ui: EquipmentUI, equipment: EquipmentManager) {\r\n        // Tool mode: show 4 dedicated tool slots in a single row\r\n        if (ui.selectedMode === 'tool') {\r\n            const toolSlotLabels: Record<string, string> = {\r\n                tool_mining: ' Mining',\r\n                tool_woodcutting: ' Woodcut',\r\n                tool_harvesting: ' Harvest',\r\n                tool_fishing: ' Fishing'\r\n            };\r\n\r\n            return `\r\n                <div class=\"slot-row tool-slots\">\r\n                    ${['tool_mining', 'tool_woodcutting', 'tool_harvesting', 'tool_fishing'].map((slot) => EquipmentUIRenderer.renderSlot(ui, slot, toolSlotLabels[slot], equipment)).join('')}\r\n                </div>\r\n            `;\r\n        }\r\n\r\n        // Weapon mode: show Set 1 and Set 2 weapon slots with labels and toggle\r\n        if (ui.selectedMode === 'weapon') {\r\n            const targetSet = ui.targetEquipSet || 1;\r\n            const weaponSlotLabels: Record<string, string> = {\r\n                hand1: 'Main',\r\n                hand2: 'Off',\r\n                hand1_alt: 'Main',\r\n                hand2_alt: 'Off'\r\n            };\r\n\r\n            return `\r\n                <div class=\"weapon-set-toggle\">\r\n                    <button class=\"set-toggle-btn ${targetSet === 1 ? 'active' : ''}\" data-target-set=\"1\">SET 1</button>\r\n                    <button class=\"set-toggle-btn ${targetSet === 2 ? 'active' : ''}\" data-target-set=\"2\">SET 2</button>\r\n                </div>\r\n                <div class=\"weapon-sets-container\">\r\n                    <div class=\"weapon-set\">\r\n                        <div class=\"slot-row weapon-slots-pair\">\r\n                            ${['hand1', 'hand2'].map((slot) => EquipmentUIRenderer.renderSlot(ui, slot, weaponSlotLabels[slot], equipment)).join('')}\r\n                        </div>\r\n                    </div>\r\n                    <div class=\"weapon-set\">\r\n                        <div class=\"slot-row weapon-slots-pair\">\r\n                            ${['hand1_alt', 'hand2_alt'].map((slot) => EquipmentUIRenderer.renderSlot(ui, slot, weaponSlotLabels[slot], equipment)).join('')}\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n            `;\r\n        }\r\n\r\n        // Armor mode: show armor and accessory slots only\r\n        const armorSlotLabels: Record<string, string> = {\r\n            head: 'Helmet',\r\n            body: 'Armor',\r\n            hands: 'Gloves',\r\n            legs: 'Legs',\r\n            accessory: 'Acc 1',\r\n            accessory2: 'Acc 2'\r\n        };\r\n\r\n        return `\r\n            <div class=\"slot-row\">\r\n                ${['head', 'body', 'hands', 'legs'].map((slot) => EquipmentUIRenderer.renderSlot(ui, slot, armorSlotLabels[slot], equipment)).join('')}\r\n            </div>\r\n            <div class=\"slot-row\">\r\n                ${['accessory', 'accessory2'].map((slot) => EquipmentUIRenderer.renderSlot(ui, slot, armorSlotLabels[slot], equipment)).join('')}\r\n            </div>\r\n        `;\r\n    }\r\n\r\n    /**\r\n     * Render a single equipment slot\r\n     * @param {EquipmentUI} ui - The EquipmentUI instance\r\n     * @param {string} slotId - Slot identifier\r\n     * @param {string} label - Display label\r\n     * @param {EquipmentManager} equipment - Hero equipment manager\r\n     * @returns {string} HTML string\r\n     */\r\n    static renderSlot(ui: EquipmentUI, slotId: string, label: string, equipment: EquipmentManager) {\r\n        const item = equipment?.getSlot?.(slotId);\r\n        const imgPath = item ? EquipmentUIRenderer.getItemIcon(item.id) : '';\r\n\r\n        // Check if this is hand2 and hand1 has a 2-hand weapon (disable hand2)\r\n        const hand1Item = equipment?.getSlot?.('hand1');\r\n        const isDisabledByTwoHand = slotId === 'hand2' && hand1Item?.gripType === '2-hand';\r\n\r\n        // Add slot-selectable class for weapon slots during selection mode\r\n        const isSelectable =\r\n            ui.slotSelectionMode &&\r\n            (slotId === 'hand1' || slotId === 'hand2') &&\r\n            !isDisabledByTwoHand;\r\n        const selectableClass = isSelectable ? 'slot-selectable' : '';\r\n        const disabledClass = isDisabledByTwoHand ? 'slot-disabled' : '';\r\n\r\n        // SVG marching ants animation for selectable slots\r\n        const marchingAntsSvg = isSelectable\r\n            ? `\r\n            <svg class=\"marching-ants-border\" viewBox=\"0 0 60 60\" preserveAspectRatio=\"none\">\r\n                <rect x=\"2\" y=\"2\" width=\"56\" height=\"56\" rx=\"6\" ry=\"6\" />\r\n            </svg>\r\n        `\r\n            : '';\r\n\r\n        // Slash overlay for disabled slots\r\n        const slashOverlay = isDisabledByTwoHand\r\n            ? `\r\n            <div class=\"slot-disabled-slash\"></div>\r\n        `\r\n            : '';\r\n\r\n        return `\r\n            <div class=\"equip-slot ${selectableClass} ${disabledClass}\" data-slot=\"${slotId}\">\r\n                <div class=\"slot-label text-pixel-outline\">${label}</div>\r\n                <div class=\"slot-icon ${item ? 'filled' : 'empty'}\" style=\"${imgPath ? `background-image: url('${imgPath}')` : ''}\">\r\n                    ${marchingAntsSvg}\r\n                    ${slashOverlay}\r\n                </div>\r\n            </div>\r\n        `;\r\n    }\r\n\r\n    /**\r\n     * Render inventory grid with filtering\r\n     * @param {EquipmentUI} ui - The EquipmentUI instance\r\n     * @returns {string} HTML string\r\n     */\r\n    static renderInventoryGrid(ui: EquipmentUI) {\r\n        // cachedEquipment is already filtered by _loadEquipment based on mode + category + modifier\r\n        const filtered = ui.cachedEquipment as EquipmentItem[];\r\n\r\n        if (filtered.length === 0) {\r\n            return '<div class=\"empty-inventory\">No equipment available</div>';\r\n        }\r\n\r\n        return `\r\n            <div class=\"inventory-grid\">\r\n                ${filtered\r\n                .map(\r\n                    (item: EquipmentItem) => `\r\n                    <div class=\"inventory-item ${ui.selectedItem?.id === item.id ? 'selected' : ''}\" data-id=\"${item.id}\">\r\n                        <div class=\"item-icon\" style=\"background-image: url('${EquipmentUIRenderer.getItemIcon(item.id)}')\"></div>\r\n                    </div>\r\n                `\r\n                )\r\n                .join('')}\r\n            </div>\r\n        `;\r\n    }\r\n\r\n    /**\r\n     * Get item icon path\r\n     * @param {string} itemId - Item identifier\r\n     * @returns {string} Image path\r\n     */\r\n    static getItemIcon(itemId: string) {\r\n        if (AssetLoader && AssetLoader.getImagePath) {\r\n            return AssetLoader.getImagePath(itemId);\r\n        }\r\n        return '';\r\n    }\r\n\r\n    /**\r\n     * Get the currently selected hero skin ID\r\n     * @returns {string} Skin ID (defaults to hero_t1_01)\r\n     */\r\n    static getCurrentSkinId() {\r\n        return localStorage.getItem('heroSelectedSkin') || 'hero_t1_01';\r\n    }\r\n\r\n    /**\r\n     * Get the image path for a hero skin\r\n     * @param {string} skinId - Skin ID\r\n     * @returns {string} Image path\r\n     */\r\n    static getSkinImagePath(skinId: string) {\r\n        if (AssetLoader && AssetLoader.getImagePath) {\r\n            return AssetLoader.getImagePath(skinId);\r\n        }\r\n        // Fallback (should normally be handled by AssetLoader)\r\n        return '';\r\n    }\r\n\r\n    /**\r\n     * Load icons using AssetLoader\r\n     * @param {HTMLElement} container - Container element\r\n     */\r\n    static loadIcons(container: HTMLElement) {\r\n        // const loader = AssetLoader as any;\r\n        // if (loader?.loadIcons) {\r\n        //     loader.loadIcons(container);\r\n        // }\r\n\r\n        // Also load hero skin portrait\r\n        const skinEl = container.querySelector('.character-sprite[data-skin-id]') as HTMLElement;\r\n        if (skinEl) {\r\n            const skinId = skinEl.dataset.skinId;\r\n            const path = EquipmentUIRenderer.getSkinImagePath(skinId);\r\n            if (path) {\r\n                skinEl.style.backgroundImage = `url('${path}')`;\r\n                skinEl.style.backgroundSize = 'cover';\r\n                skinEl.style.backgroundPosition = 'center';\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\n// Export\r\nif (typeof window !== 'undefined') {\r\n    (window as Window).EquipmentUIRenderer = EquipmentUIRenderer;\r\n}\r\n\r\n// ES6 Module Export\r\nexport { EquipmentUIRenderer };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\ui\\EquipmentUIRendererStats.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\ui\\HeroSkinSelector.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\ui\\InventoryUI.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\ui\\InventoryUIFooter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\ui\\MerchantUI.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'customDisplay' is assigned a value but never used. Allowed unused args must match /^_/u.","line":144,"column":80,"nodeType":"Identifier","messageId":"unusedVar","endLine":144,"endColumn":93},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'type' is defined but never used. Allowed unused args must match /^_/u.","line":148,"column":21,"nodeType":"Identifier","messageId":"unusedVar","endLine":148,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * MerchantPanel - Controller for merchant purchase modal\r\n */\r\n\r\nimport { Logger } from '@core/Logger';\r\nimport { EventBus } from '@core/EventBus';\r\nimport { GameConstants } from '@data/GameConstants';\r\nimport { Registry } from '@core/Registry';\r\nimport { UIPanel } from './core/UIPanel';\r\ninterface IslandInteraction {\r\n    islandId: string;\r\n    islandName: string;\r\n    [key: string]: unknown;\r\n}\r\n\r\nclass MerchantPanel extends UIPanel {\r\n    // Property declarations\r\n    currentMerchant: IslandInteraction | null = null;\r\n\r\n    constructor() {\r\n        super('modal-merchant', {\r\n            dockable: true,\r\n            defaultDock: 'ui-hud-right'\r\n        });\r\n        this.init();\r\n    }\r\n\r\n    init() {\r\n        Logger.info('[MerchantPanel] Initializing...');\r\n        if (document.readyState === 'loading') {\r\n            document.addEventListener('DOMContentLoaded', () => this.bindEvents());\r\n        } else {\r\n            this.bindEvents();\r\n        }\r\n    }\r\n\r\n    bindEvents() {\r\n        // Setup purchase button click\r\n        const btnPurchase = document.getElementById('btn-purchase');\r\n        if (btnPurchase) {\r\n            btnPurchase.onclick = () => {\r\n                this.toggle(); // Use toggle for consistency\r\n            };\r\n        }\r\n\r\n        const btnClose = document.getElementById('btn-close-merchant');\r\n        if (btnClose) {\r\n            btnClose.addEventListener('click', () => {\r\n                this.close();\r\n            });\r\n        }\r\n\r\n        const upgradeTypes = ['resourceSlots', 'autoChance', 'respawnTime'];\r\n        for (const type of upgradeTypes) {\r\n            const btn = document.getElementById(`btn-upgrade-${type}`);\r\n            if (btn) {\r\n                // Clone to remove old listeners (prevent double binding)\r\n                const newBtn = btn.cloneNode(true);\r\n                btn.parentNode.replaceChild(newBtn, btn);\r\n                newBtn.addEventListener('click', () => {\r\n                    this.purchaseUpgrade(type);\r\n                });\r\n            }\r\n        }\r\n\r\n        this.bindBusEvents();\r\n    }\r\n\r\n    bindBusEvents() {\r\n        if (EventBus) {\r\n            EventBus.on('UPGRADE_PURCHASED', () => {\r\n                if (this.isOpen) this.render();\r\n            });\r\n            if (GameConstants?.Events) {\r\n                EventBus.on(GameConstants.Events.OPEN_MERCHANT, () => this.open());\r\n            }\r\n\r\n            // Interaction Event\r\n            EventBus.on(\r\n                'INTERACTION_OPPORTUNITY',\r\n                (data: { type: string; target?: IslandInteraction; visible?: boolean }) => {\r\n                    const { type, target, visible } = data;\r\n                    if (type === 'merchant') {\r\n                        if (visible && target) {\r\n                            this.updateButtonVisibility(target);\r\n                        } else {\r\n                            this.updateButtonVisibility(null);\r\n                        }\r\n                    }\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Override Open logic\r\n     */\r\n    onOpen() {\r\n        Logger.info(\r\n            '[MerchantPanel] Opening for:',\r\n            this.currentMerchant ? this.currentMerchant.islandName : 'None'\r\n        );\r\n        if (!this.currentMerchant) {\r\n            // If opened manually or without target, maybe close?\r\n            // Or just render empty?\r\n            this.close();\r\n            return;\r\n        }\r\n        this.render();\r\n    }\r\n\r\n    updateButtonVisibility(merchant: IslandInteraction | null) {\r\n        // Always track the merchant opportunity\r\n        if (merchant) {\r\n            this.currentMerchant = merchant;\r\n        }\r\n\r\n        // Handle Legacy Button (if exists)\r\n        const btn = document.getElementById('btn-purchase');\r\n        if (!btn) return;\r\n\r\n        if (this.isOpen) {\r\n            btn.style.display = 'none';\r\n            return;\r\n        }\r\n\r\n        if (merchant) {\r\n            btn.style.display = 'flex';\r\n        } else {\r\n            btn.style.display = 'none';\r\n        }\r\n    }\r\n\r\n    render() {\r\n        if (!this.currentMerchant) return;\r\n\r\n        const title = document.getElementById('merchant-title');\r\n        if (title) {\r\n            title.textContent = this.currentMerchant.islandName?.toUpperCase() || 'MERCHANT';\r\n        }\r\n        // Island logic removed\r\n    }\r\n\r\n    renderUpgradeRow(type: string, data: unknown, label: string, unit: string, customDisplay: string | null = null) {\r\n        // Obsolete\r\n    }\r\n\r\n    purchaseUpgrade(type: string) {\r\n        // Obsolete\r\n    }\r\n}\r\n\r\n// Create singleton and export\r\nconst MerchantUI = new MerchantPanel();\r\nif (Registry) Registry.register('MerchantUI', MerchantUI);\r\n\r\nexport { MerchantPanel, MerchantUI };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\ui\\MinimapRenderer.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'generateMapgen4' is defined but never used.","line":7,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":25,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"generateMapgen4"},"fix":{"range":[240,311],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Mapgen4Param' is defined but never used.","line":9,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":27,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"Mapgen4Param"},"fix":{"range":[399,468],"text":""},"desc":"Remove unused import declaration."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * MinimapRenderer  Draw minimap content (mapgen4 terrain, entities, hero).\r\n */\r\nimport { Registry } from '@core/Registry';\r\nimport { entityManager } from '@core/EntityManager';\r\nimport { GameConstants } from '@data/GameConstants';\r\nimport { generateMapgen4 } from '../tools/map-editor/Mapgen4Generator';\r\nimport { drawCachedMeshToCanvas } from '../tools/map-editor/Mapgen4PreviewRenderer';\r\nimport type { Mapgen4Param } from '../tools/map-editor/Mapgen4Param';\r\n\r\nconst WORLD_SIZE = 160000;\r\nconst MESH_SIZE = 1000;\r\n\r\nexport function renderMinimap(\r\n    ctx: CanvasRenderingContext2D,\r\n    canvasSize: number,\r\n    scale: number,\r\n    viewLeft: number,\r\n    viewTop: number,\r\n    viewWidth: number,\r\n    viewHeight: number,\r\n    hero: { x: number; y: number } | null,\r\n    zoomLevel: number\r\n): void {\r\n    const toCanvas = (worldX: number, worldY: number) => ({\r\n        x: (worldX - viewLeft) * scale,\r\n        y: (worldY - viewTop) * scale\r\n    });\r\n\r\n    // Draw mapgen4 polygon map as base terrain\r\n    const worldManager = Registry?.get<{\r\n        getMesh: () => { mesh: unknown; map: unknown } | null;\r\n        getMapgen4Param: () => unknown;\r\n        getCachedTownsAndRoads?: () => {\r\n            towns: unknown[];\r\n            roadSegments: unknown[];\r\n            railroadPath: number[];\r\n            railroadCrossings: unknown[];\r\n        };\r\n    }>('WorldManager');\r\n    const meshAndMap = worldManager?.getMesh?.();\r\n    if (meshAndMap) {\r\n        const param = worldManager.getMapgen4Param();\r\n        const { mesh, map } = meshAndMap;\r\n        const { towns = [], roadSegments = [], railroadPath = [], railroadCrossings = [], railroadStationIds = [] } =\r\n            worldManager.getCachedTownsAndRoads?.() ?? {};\r\n        const vpX = (viewLeft / WORLD_SIZE) * MESH_SIZE;\r\n        const vpY = (viewTop / WORLD_SIZE) * MESH_SIZE;\r\n        const vpW = (viewWidth / WORLD_SIZE) * MESH_SIZE;\r\n        const vpH = (viewHeight / WORLD_SIZE) * MESH_SIZE;\r\n        const canvas = ctx.canvas;\r\n        if (canvas) {\r\n            drawCachedMeshToCanvas(\r\n                canvas,\r\n                mesh,\r\n                map,\r\n                param,\r\n                vpX,\r\n                vpY,\r\n                vpW,\r\n                vpH,\r\n                towns,\r\n                roadSegments,\r\n                railroadPath,\r\n                railroadCrossings,\r\n                railroadStationIds\r\n            );\r\n        }\r\n    } else {\r\n        ctx.fillStyle = '#0d1117';\r\n        ctx.fillRect(0, 0, canvasSize, canvasSize);\r\n    }\r\n\r\n    if (entityManager) {\r\n        ctx.fillStyle = '#F44336';\r\n        for (const enemy of entityManager.getByType('Enemy')) {\r\n            if (!enemy.active || enemy.isDead) continue;\r\n            const pos = toCanvas(enemy.x, enemy.y);\r\n            if (pos.x < 0 || pos.x > canvasSize || pos.y < 0 || pos.y > canvasSize) continue;\r\n            ctx.beginPath();\r\n            ctx.arc(pos.x, pos.y, 4, 0, Math.PI * 2);\r\n            ctx.fill();\r\n        }\r\n        for (const boss of entityManager.getByType('Boss')) {\r\n            if (!boss.active || boss.isDead) continue;\r\n            const pos = toCanvas(boss.x, boss.y);\r\n            if (pos.x < 0 || pos.x > canvasSize || pos.y < 0 || pos.y > canvasSize) continue;\r\n            const pulse = Math.sin(Date.now() / 150) * 0.3 + 1;\r\n            ctx.fillStyle = 'rgba(255, 69, 0, 0.5)';\r\n            ctx.beginPath();\r\n            ctx.arc(pos.x, pos.y, 10 * pulse, 0, Math.PI * 2);\r\n            ctx.fill();\r\n            ctx.fillStyle = '#FF4500';\r\n            ctx.beginPath();\r\n            ctx.arc(pos.x, pos.y, 6, 0, Math.PI * 2);\r\n            ctx.fill();\r\n            ctx.fillStyle = '#FFF';\r\n            ctx.font = 'bold 10px sans-serif';\r\n            ctx.textAlign = 'center';\r\n            ctx.textBaseline = 'middle';\r\n            ctx.fillText('', pos.x, pos.y);\r\n        }\r\n    }\r\n\r\n    // Hero: always at center (view scrolls with hero)\r\n    if (hero) {\r\n        const centerX = canvasSize / 2;\r\n        const centerY = canvasSize / 2;\r\n        const pulse = Math.sin(Date.now() / GameConstants.UI.MINIMAP_PULSE_MS) * 0.3 + 1;\r\n        ctx.fillStyle = 'rgba(255, 87, 34, 0.4)';\r\n        ctx.beginPath();\r\n        ctx.arc(centerX, centerY, 12 * pulse, 0, Math.PI * 2);\r\n        ctx.fill();\r\n        ctx.save();\r\n        ctx.translate(centerX, centerY);\r\n        ctx.fillStyle = '#FF5722';\r\n        ctx.beginPath();\r\n        ctx.moveTo(0, -8);\r\n        ctx.lineTo(6, 8);\r\n        ctx.lineTo(-6, 8);\r\n        ctx.closePath();\r\n        ctx.fill();\r\n        ctx.restore();\r\n    }\r\n\r\n    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';\r\n    ctx.font = '10px sans-serif';\r\n    ctx.textAlign = 'right';\r\n    ctx.textBaseline = 'bottom';\r\n    ctx.fillText(`Zoom: ${zoomLevel.toFixed(1)}x`, canvasSize - 10, canvasSize - 10);\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\ui\\MinimapSystem.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'dt' is defined but never used. Allowed unused args must match /^_/u.","line":256,"column":12,"nodeType":"Identifier","messageId":"unusedVar","endLine":256,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * MinimapSystem\r\n * Renders a miniature world map centered on the player with zoom controls.\r\n *\r\n * Features:\r\n * - Player-centered view for 160k160k mapgen4 world\r\n * - Zoom in/out with +/- buttons\r\n * - Shows mapgen4 terrain, enemies, hero\r\n *\r\n * Owner: UI Engineer\r\n */\r\n\r\nimport { Logger } from '@core/Logger';\r\nimport { EventBus } from '@core/EventBus';\r\nimport { GameConstants } from '@data/GameConstants';\r\nimport { Registry } from '@core/Registry';\r\nimport { DOMUtils } from '@core/DOMUtils';\r\nimport { GameInstance } from '@core/Game';\r\nimport type { IGame } from '../types/core.d';\r\nimport { renderMinimap } from './MinimapRenderer';\r\nimport { UIManager } from './UIManager';\r\n\r\nclass MinimapSystem {\r\n    // Property declarations\r\n    canvas: HTMLCanvasElement | null;\r\n    ctx: CanvasRenderingContext2D | null;\r\n    modal: HTMLElement | null;\r\n    isOpen: boolean;\r\n    zoomLevel: number;\r\n    minZoom: number;\r\n    maxZoom: number;\r\n    zoomStep: number;\r\n    baseViewRadius: number;\r\n    game: IGame | null;\r\n    scale: number = 1;\r\n    private _rafId: number | null = null;\r\n\r\n    constructor() {\r\n        this.canvas = null;\r\n        this.ctx = null;\r\n        this.modal = null;\r\n        this.isOpen = false;\r\n\r\n        // Zoom settings\r\n        this.zoomLevel = 1;\r\n        this.minZoom = 0.25; // Show 4x area\r\n        this.maxZoom = 4; // Show 1/4 area\r\n        this.zoomStep = GameConstants.UI.MINIMAP_ZOOM_STEP;\r\n\r\n        // View radius at zoom 1 (how much world to show)\r\n        this.baseViewRadius = 20000; // 160k world: show 40k40k at zoom 1\r\n        this.game = null;\r\n\r\n        Logger.info('[MinimapSystem] Constructed');\r\n    }\r\n\r\n    init(game: IGame) {\r\n        this.game = game;\r\n\r\n        // Cache DOM elements\r\n        this.modal = document.getElementById('modal-map');\r\n        this.canvas = document.getElementById('minimap-canvas') as HTMLCanvasElement;\r\n        this.ctx = this.canvas?.getContext('2d') || null;\r\n\r\n        // Setup button handlers\r\n        const btnMap = document.getElementById('btn-map');\r\n        const btnClose = document.getElementById('btn-close-map');\r\n\r\n        if (btnMap) {\r\n            btnMap.addEventListener('click', () => {\r\n                // Skip if footer is in override mode (equipment/inventory screen has taken over)\r\n                if (btnMap.dataset.footerOverride) return;\r\n                this.toggle();\r\n            });\r\n        }\r\n        if (btnClose) {\r\n            btnClose.addEventListener('click', () => this.close());\r\n        }\r\n\r\n        // Close on click outside\r\n        if (this.modal) {\r\n            this.modal.addEventListener('click', (e) => {\r\n                if (e.target === this.modal) this.close();\r\n            });\r\n        }\r\n\r\n        // Create zoom controls\r\n        this.createZoomControls();\r\n\r\n        // Register with UIManager for fullscreen exclusivity\r\n        if (UIManager && UIManager.registerFullscreenUI) {\r\n            UIManager.registerFullscreenUI(this);\r\n        }\r\n\r\n        Logger.info('[MinimapSystem] Initialized');\r\n    }\r\n\r\n    createZoomControls() {\r\n        if (!this.modal) return;\r\n\r\n        // Find or create container\r\n        const mapContent = this.modal.querySelector('.modal-content') || this.modal;\r\n\r\n        // Check if controls already exist\r\n        if (mapContent.querySelector('.minimap-zoom-controls')) return;\r\n\r\n        const controls = DOMUtils.create('div', {\r\n            className: 'minimap-zoom-controls',\r\n            cssText: `\r\n            position: absolute;\r\n            bottom: 20px;\r\n            right: 20px;\r\n            display: flex;\r\n            flex-direction: column;\r\n            gap: 8px;\r\n            z-index: 10;\r\n        `\r\n        });\r\n\r\n        const btnStyle = `\r\n            width: 40px;\r\n            height: 40px;\r\n            border: none;\r\n            border-radius: 8px;\r\n            background: rgba(255, 255, 255, 0.2);\r\n            color: white;\r\n            font-size: 24px;\r\n            font-weight: bold;\r\n            cursor: pointer;\r\n            display: flex;\r\n            align-items: center;\r\n            justify-content: center;\r\n            transition: background 0.2s;\r\n        `;\r\n\r\n        const btnZoomIn = DOMUtils.create('button', {\r\n            text: '+',\r\n            cssText: btnStyle\r\n        });\r\n        btnZoomIn.addEventListener('click', () => this.zoomIn());\r\n        btnZoomIn.addEventListener(\r\n            'mouseenter',\r\n            () => (btnZoomIn.style.background = 'rgba(255, 255, 255, 0.4)')\r\n        );\r\n        btnZoomIn.addEventListener(\r\n            'mouseleave',\r\n            () => (btnZoomIn.style.background = 'rgba(255, 255, 255, 0.2)')\r\n        );\r\n\r\n        const btnZoomOut = DOMUtils.create('button', {\r\n            text: '',\r\n            cssText: btnStyle\r\n        });\r\n        btnZoomOut.addEventListener('click', () => this.zoomOut());\r\n        btnZoomOut.addEventListener(\r\n            'mouseenter',\r\n            () => (btnZoomOut.style.background = 'rgba(255, 255, 255, 0.4)')\r\n        );\r\n        btnZoomOut.addEventListener(\r\n            'mouseleave',\r\n            () => (btnZoomOut.style.background = 'rgba(255, 255, 255, 0.2)')\r\n        );\r\n\r\n        controls.appendChild(btnZoomIn);\r\n        controls.appendChild(btnZoomOut);\r\n\r\n        // Make modal content relative for absolute positioning\r\n        if ((mapContent as HTMLElement).style.position !== 'relative') {\r\n            (mapContent as HTMLElement).style.position = 'relative';\r\n        }\r\n        mapContent.appendChild(controls);\r\n    }\r\n\r\n    zoomIn() {\r\n        this.zoomLevel = Math.min(this.maxZoom, this.zoomLevel + this.zoomStep);\r\n        this.render();\r\n    }\r\n\r\n    zoomOut() {\r\n        this.zoomLevel = Math.max(this.minZoom, this.zoomLevel - this.zoomStep);\r\n        this.render();\r\n    }\r\n\r\n    toggle() {\r\n        if (this.isOpen) {\r\n            this.close();\r\n        } else {\r\n            this.open();\r\n        }\r\n    }\r\n\r\n    open() {\r\n        if (!this.modal) return;\r\n\r\n        if (EventBus && GameConstants?.Events) {\r\n            EventBus.emit(GameConstants.Events.UI_FULLSCREEN_OPENED, { source: this });\r\n        }\r\n\r\n        // Hide weapon swap button\r\n        const btnSwap = document.getElementById('btn-weapon-swap');\r\n        if (btnSwap) btnSwap.style.display = 'none';\r\n\r\n        this.modal.style.display = 'flex';\r\n        this.isOpen = true;\r\n        this.render();\r\n        this._startRenderLoop();\r\n    }\r\n\r\n    close() {\r\n        if (!this.modal) return;\r\n        this.modal.style.display = 'none';\r\n        this.isOpen = false;\r\n        this._stopRenderLoop();\r\n\r\n        // Show weapon swap button again\r\n        const btnSwap = document.getElementById('btn-weapon-swap');\r\n        if (btnSwap) btnSwap.style.display = '';\r\n    }\r\n\r\n    private _startRenderLoop() {\r\n        this._stopRenderLoop();\r\n        const loop = () => {\r\n            if (!this.isOpen) return;\r\n            this.render();\r\n            this._rafId = requestAnimationFrame(loop);\r\n        };\r\n        this._rafId = requestAnimationFrame(loop);\r\n    }\r\n\r\n    private _stopRenderLoop() {\r\n        if (this._rafId !== null) {\r\n            cancelAnimationFrame(this._rafId);\r\n            this._rafId = null;\r\n        }\r\n    }\r\n\r\n    render() {\r\n        if (!this.ctx || !this.canvas) return;\r\n        // Use GameInstance for hero to ensure we get the latest position each frame\r\n        const hero = GameInstance?.hero ?? this.game?.hero ?? null;\r\n        const canvasSize = this.canvas.width;\r\n        const viewRadius = this.baseViewRadius / this.zoomLevel;\r\n        const heroX = hero?.x ?? 80000;\r\n        const heroY = hero?.y ?? 80000;\r\n        const viewWidth = viewRadius * 2;\r\n        const viewHeight = viewRadius * 2;\r\n        this.scale = canvasSize / viewWidth;\r\n        const viewLeft = heroX - viewRadius;\r\n        const viewTop = heroY - viewRadius;\r\n        renderMinimap(this.ctx, canvasSize, this.scale, viewLeft, viewTop, viewWidth, viewHeight, hero, this.zoomLevel);\r\n    }\r\n\r\n    /**\r\n     * Update called each frame (for live minimap)\r\n     */\r\n    update(dt: number) {\r\n        // Re-render if open to show hero movement\r\n        if (this.isOpen) {\r\n            this.render();\r\n        }\r\n    }\r\n}\r\n\r\n// Create singleton instance\r\nconst minimapSystemInstance = new MinimapSystem();\r\nif (Registry) Registry.register('MinimapSystem', minimapSystemInstance);\r\n\r\n// ES6 Module Export\r\nexport { MinimapSystem, minimapSystemInstance };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\ui\\TextureAligner.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\ui\\TextureAlignerTargets.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\ui\\TextureAlignerUI.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\ui\\ThemeManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\ui\\UICapture.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\ui\\UIManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'DOMUtils' is defined but never used.","line":22,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":22,"endColumn":18,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"DOMUtils"},"fix":{"range":[764,806],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'dt' is defined but never used. Allowed unused args must match /^_/u.","line":316,"column":12,"nodeType":"Identifier","messageId":"unusedVar","endLine":316,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * UI Manager\r\n * Orchestrates UI rendering and updates\r\n *\r\n * REFACTOR NOTICE: Split into focused files:\r\n * - ContextActionUI.js: Context-sensitive action button\r\n * - UICapture.js: Debug screenshot utilities\r\n *\r\n * Owner: UI Artist\r\n */\r\n\r\nimport { Logger } from '@core/Logger';\r\nimport { PlatformManager } from '@core/PlatformManager';\r\nimport { ResponsiveManager } from '@core/ResponsiveManager';\r\nimport { AudioManager } from '../audio/AudioManager';\r\nimport { ContextActionUI } from './ContextActionUI';\r\nimport { GameConstants } from '@data/GameConstants';\r\nimport { EventBus } from '@core/EventBus';\r\nimport { VFXController } from '@vfx/VFXController';\r\nimport { AssetLoader } from '@core/AssetLoader';\r\nimport { Registry } from '@core/Registry';\r\nimport { DOMUtils } from '@core/DOMUtils';\r\nimport { UICapture } from './UICapture';\r\nimport { GameInstance } from '@core/Game';\r\nimport { LayoutStrategies } from './responsive/LayoutStrategies';\r\nimport { HUDController } from './controllers/HUDController';\r\nimport type { IUIPanel, IQuest } from '../types/ui';\r\n\r\ninterface IFullscreenUI {\r\n    isOpen: boolean;\r\n    close(): void;\r\n}\r\n\r\nclass UIManagerService {\r\n    initialized: boolean = false;\r\n    panels: Map<string, IUIPanel> = new Map();\r\n    fullscreenUIs: Set<IFullscreenUI> = new Set();\r\n    currentStrategy: {\r\n        apply?(container: HTMLElement): void;\r\n        enter?(): void;\r\n        exit?(): void;\r\n    } | null = null;\r\n    isFooterOverridden: boolean = false;\r\n\r\n    constructor() {\r\n        Logger.debug('[UIManager]', 'Constructed');\r\n    }\r\n\r\n    init() {\r\n        Logger.info('[UIManager]', 'Initializing...');\r\n        // Ensure HUDController is loaded\r\n        if (HUDController) Logger.debug('[UIManager] HUDController loaded');\r\n\r\n        // Listen for platform changes\r\n        if (PlatformManager) {\r\n            PlatformManager.on('modechange', (config: unknown) =>\r\n                this.onPlatformChange(config)\r\n            );\r\n            this.onPlatformChange(PlatformManager.getConfig());\r\n        } else if (ResponsiveManager) {\r\n            ResponsiveManager.on('change', (data: unknown) =>\r\n                this.onResponsiveChange(data as { format: string; orientation?: string; breakpoint?: string })\r\n            );\r\n        }\r\n\r\n        this.loadIcons();\r\n\r\n        // Global click sound\r\n        document.addEventListener('click', (e) => {\r\n            const target = e.target as HTMLElement;\r\n            if (\r\n                target.matches('button, .clickable, .icon-btn, .shop-item, .upgrade-card') ||\r\n                target.closest('button, .clickable, .icon-btn, .shop-item, .upgrade-card')\r\n            ) {\r\n                if (AudioManager) AudioManager.playSFX('sfx_ui_click');\r\n            }\r\n\r\n            // Action button click animation - add class so animation plays fully\r\n            const actionBtn = target.closest('.action-btn') as HTMLElement | null;\r\n            if (actionBtn && !actionBtn.classList.contains('clicked')) {\r\n                actionBtn.classList.add('clicked');\r\n                setTimeout(() => actionBtn.classList.remove('clicked'), 350);\r\n            }\r\n        });\r\n\r\n        // Escape to exit Capture Mode\r\n        document.addEventListener('keydown', (e) => {\r\n            if (e.key === 'Escape' && document.body.classList.contains('ui-capture-mode')) {\r\n                if (UICapture) UICapture.toggleMode();\r\n            }\r\n        });\r\n\r\n        // Init ContextActionUI\r\n        if (ContextActionUI) ContextActionUI.init();\r\n\r\n        // Magnet Button\r\n        const btnMagnet = document.getElementById('btn-magnet');\r\n        if (btnMagnet) {\r\n            btnMagnet.addEventListener('click', () => {\r\n                // Skip if footer is in override mode (equipment/inventory screen has taken over)\r\n                if (this.isFooterOverridden) return;\r\n                const eventName =\r\n                    GameConstants && GameConstants.Events\r\n                        ? GameConstants.Events.REQUEST_MAGNET\r\n                        : 'REQUEST_MAGNET';\r\n                if (EventBus) EventBus.emit(eventName);\r\n            });\r\n        }\r\n\r\n        // Weapon Set Swap Button\r\n        const btnSwap = document.getElementById('btn-weapon-swap');\r\n        if (btnSwap) {\r\n            btnSwap.addEventListener('click', () => {\r\n                const hero = GameInstance?.hero;\r\n                if (hero?.equipment?.swapWeaponSet) {\r\n                    const activeSet = hero.equipment.swapWeaponSet();\r\n                    Logger.info(`[UIManager] Weapon set swapped to Set ${activeSet}`);\r\n                    if (AudioManager) AudioManager.playSFX('sfx_ui_click');\r\n                }\r\n            });\r\n        }\r\n\r\n        // EventBus Listeners\r\n        if (EventBus && GameConstants) {\r\n            const E = GameConstants.Events;\r\n            EventBus.on(E.UI_FADE_SCREEN, (data: { onMidpoint?: () => void } | null) =>\r\n                this.fadeInOut(data ? data.onMidpoint : null)\r\n            );\r\n            EventBus.on(\r\n                E.QUEST_UPDATED,\r\n                (data: { quest: IQuest | null; animate?: boolean }) =>\r\n                    this.updateQuest(data.quest ?? null, data.animate ?? false)\r\n            );\r\n            EventBus.on(\r\n                E.UI_FULLSCREEN_OPENED,\r\n                (data: { source: IFullscreenUI } | null) => {\r\n                    if (data?.source) this.closeOtherFullscreenUIs(data.source);\r\n                }\r\n            );\r\n\r\n            // Track when main UI panels override the footer\r\n            EventBus.on('UI_PANEL_OPENED', (data: { panelId: string }) => {\r\n                // Determine if this panel should override the footer (e.g., inventory/equipment)\r\n                if (data && ['inventory', 'equipment', 'crafting'].includes(data.panelId)) {\r\n                    this.isFooterOverridden = true;\r\n                }\r\n            });\r\n            EventBus.on('UI_PANEL_CLOSED', (data: { panelId: string }) => {\r\n                if (data && ['inventory', 'equipment', 'crafting'].includes(data.panelId)) {\r\n                    this.isFooterOverridden = false;\r\n                }\r\n            });\r\n        }\r\n\r\n        this.initialized = true;\r\n        Logger.info('[UIManager]', 'Initialized');\r\n    }\r\n\r\n    // === Icon Loading ===\r\n    loadIcons() {\r\n        if (!AssetLoader) return;\r\n\r\n        const elements = document.querySelectorAll('[data-icon-id]');\r\n        Logger.debug('[UIManager]', `Loading icons for ${elements.length} elements`);\r\n\r\n        elements.forEach((element) => {\r\n            const el = element as HTMLElement;\r\n            const id = el.dataset.iconId;\r\n            const path = AssetLoader.getImagePath(id);\r\n            if (path) {\r\n                el.style.backgroundImage = `url('${path}')`;\r\n                el.style.backgroundSize = 'cover';\r\n                el.style.backgroundPosition = 'center';\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n    // === Platform/Layout ===\r\n    onPlatformChange(_config: unknown) {\r\n        this.applyLayout(PlatformManager.currentMode === 'pc' ? 'desktop' : 'mobile');\r\n    }\r\n\r\n    onResponsiveChange(data: { format: string; orientation?: string; breakpoint?: string }) {\r\n        if (PlatformManager?.isManualOverride) return;\r\n        this.applyLayout(data.format);\r\n    }\r\n\r\n    applyLayout(format: string) {\r\n        if (!LayoutStrategies) return;\r\n\r\n        const StrategyClass =\r\n            format === 'desktop' ? LayoutStrategies.Desktop : LayoutStrategies.Mobile;\r\n\r\n        if (!this.currentStrategy || !(this.currentStrategy instanceof StrategyClass)) {\r\n            this.currentStrategy?.exit();\r\n            this.currentStrategy = new StrategyClass(this);\r\n            this.currentStrategy.enter();\r\n        }\r\n    }\r\n\r\n    // === Quest Panel ===\r\n    updateQuest(quest: IQuest | null, animate = false) {\r\n        if (!quest) {\r\n            this.hideQuestPanel();\r\n            return;\r\n        }\r\n\r\n        const panel = document.getElementById('ui-quest-panel');\r\n        if (panel) panel.style.display = 'block';\r\n\r\n        const desc = document.getElementById('quest-description');\r\n        const progress = document.getElementById('quest-progress');\r\n        const bar = document.getElementById('quest-progress-bar');\r\n\r\n        if (desc) desc.textContent = quest.description;\r\n        if (progress) progress.textContent = `(${quest.current}/${quest.target})`;\r\n\r\n        if (bar) {\r\n            const pct = Math.min(100, (quest.current / quest.target) * 100);\r\n            bar.style.width = `${pct}%`;\r\n\r\n            if (animate && VFXController?.triggerUIProgressSparks) {\r\n                // Get position from bar element for VFX\r\n                const rect = bar.getBoundingClientRect();\r\n                VFXController.triggerUIProgressSparks(rect.right, rect.top + rect.height / 2, {\r\n                    color: '#3498DB'\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    hideQuestPanel() {\r\n        const panel = document.getElementById('ui-quest-panel');\r\n        if (panel) panel.style.display = 'none';\r\n    }\r\n\r\n    // === Screen Fade ===\r\n    fadeInOut(onMidpoint: (() => void) | null) {\r\n        const overlay = document.getElementById('fade-overlay');\r\n        if (!overlay) {\r\n            if (onMidpoint) onMidpoint();\r\n            return;\r\n        }\r\n\r\n        if (overlay.classList.contains('fade-active')) return;\r\n\r\n        overlay.classList.add('fade-active');\r\n        setTimeout(() => {\r\n            if (onMidpoint) onMidpoint();\r\n            overlay.classList.remove('fade-active');\r\n        }, 1000);\r\n    }\r\n\r\n    // === Panel Registry ===\r\n    registerPanel(panel: IUIPanel) {\r\n        if (!this.panels.has(panel.id)) {\r\n            this.panels.set(panel.id, panel);\r\n            Logger.debug('[UIManager]', `Registered panel: ${panel.id}`);\r\n\r\n            if (this.currentStrategy) {\r\n                const mode =\r\n                    this.currentStrategy.constructor.name === 'DesktopLayout'\r\n                        ? 'desktop'\r\n                        : 'mobile';\r\n                panel.applyLayout(mode);\r\n            }\r\n        }\r\n    }\r\n\r\n    getPanel(id: string): IUIPanel | undefined {\r\n        return this.panels.get(id);\r\n    }\r\n\r\n    handleAccordion(openingPanel: IUIPanel) {\r\n        this.panels.forEach((panel) => {\r\n            if (\r\n                panel !== openingPanel &&\r\n                panel.isDocked &&\r\n                panel.isOpen &&\r\n                panel.config.defaultDock === openingPanel.config.defaultDock\r\n            ) {\r\n                panel.close();\r\n            }\r\n        });\r\n    }\r\n\r\n    // === Fullscreen UI Management ===\r\n    /**\r\n     * Register a fullscreen UI (call in the UI's constructor)\r\n     * @param {Object} ui - UI object with isOpen and close() method\r\n     */\r\n    registerFullscreenUI(ui: IFullscreenUI) {\r\n        this.fullscreenUIs.add(ui);\r\n    }\r\n\r\n    /**\r\n     * Close all other fullscreen UIs except the one being opened\r\n     * @param {Object} exceptUI - The UI that should remain open\r\n     */\r\n    closeOtherFullscreenUIs(exceptUI: IFullscreenUI) {\r\n        this.fullscreenUIs.forEach((ui) => {\r\n            if (ui !== exceptUI && ui.isOpen && typeof ui.close === 'function') {\r\n                ui.close();\r\n            }\r\n        });\r\n        // Also close registered panels\r\n        this.panels.forEach((panel) => {\r\n            if (panel.isOpen) {\r\n                panel.close();\r\n            }\r\n        });\r\n    }\r\n\r\n    // === Update Loop ===\r\n    update(dt: number) {\r\n        // UI mostly event-driven\r\n    }\r\n\r\n    toggleDebugCapture() {\r\n        return UICapture?.toggleMode();\r\n    }\r\n    async autoCapture() {\r\n        return UICapture?.autoCapture();\r\n    }\r\n    async captureElement(s: string, f: string) {\r\n        return UICapture?.captureElement(s, f);\r\n    }\r\n    async captureAllZones() {\r\n        return UICapture?.captureAllZones();\r\n    }\r\n\r\n    showContextAction(type: string, data: Record<string, unknown>) {\r\n        ContextActionUI?.show(type, data);\r\n    }\r\n    hideContextAction(type: string) {\r\n        ContextActionUI?.hide(type);\r\n    }\r\n    executeContextAction() {\r\n        ContextActionUI?.execute();\r\n    }\r\n}\r\n\r\n// Create singleton and export\r\nconst UIManager = new UIManagerService();\r\nconst debugUICapture = () => UICapture?.captureAllZones();\r\nif (Registry) Registry.register('UIManager', UIManager);\r\n\r\nexport { UIManagerService, UIManager, debugUICapture };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\ui\\WeaponWheel.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\ui\\WeaponWheelStyles.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\ui\\controllers\\ForgeController.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'dt' is defined but never used. Allowed unused args must match /^_/u.","line":67,"column":12,"nodeType":"Identifier","messageId":"unusedVar","endLine":67,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * ForgePanel - Manages the Forge (Crafting) UI\n */\nimport { UIPanel } from '@ui/core/UIPanel';\nimport { CraftingManager, CraftingSlot, CraftingRecipe } from '../../gameplay/CraftingManager';\nimport { AudioManager } from '../../audio/AudioManager';\nimport { AssetLoader } from '@core/AssetLoader';\nimport { Registry } from '@core/Registry';\nimport { DOMUtils } from '@core/DOMUtils';\nimport { EventBus } from '@core/EventBus';\nimport { GameConstants } from '@data/GameConstants';\n\ninterface ForgeContext {\n    slotId?: number;\n    recipeId?: string;\n}\n\nclass ForgePanel extends UIPanel {\n    // Property declarations\n    currentView: { view: string; context: ForgeContext } | null = null;\n\n    constructor() {\n        super('modal-forge', {\n            dockable: true,\n            defaultDock: 'ui-hud-right'\n        });\n        this.init();\n    }\n\n    init() {\n        // Wait for DOM\n        if (document.readyState === 'loading') {\n            document.addEventListener('DOMContentLoaded', () => this.bindEvents());\n        } else {\n            this.bindEvents();\n        }\n    }\n\n    bindEvents() {\n        const btnForge = document.getElementById('btn-open-craft');\n        if (btnForge) {\n            btnForge.addEventListener('click', () => {\n                this.render('dashboard');\n                this.toggle(); // Toggle instead of force open\n            });\n        }\n        const btnCloseForge = document.getElementById('btn-close-forge');\n        if (btnCloseForge) {\n            btnCloseForge.addEventListener('click', () => {\n                this.close();\n            });\n        }\n        if (EventBus && GameConstants?.Events) {\n            EventBus.on(\n                GameConstants.Events.OPEN_FORGE,\n                (data: { view?: string } | null) => {\n                    this.render((data?.view as string) || 'dashboard');\n                    this.open();\n                }\n            );\n        }\n    }\n\n    /**\n     * Override Update Loop\n     */\n    update(dt: number) {\n        if (this.isOpen && this.currentView && this.currentView.view === 'dashboard') {\n            this.updateActiveSlots();\n        }\n    }\n\n    updateActiveSlots() {\n        if (!CraftingManager) return;\n        const grid = document.querySelector('.forge-grid');\n        if (!grid) return;\n\n        CraftingManager.slots.forEach((slot) => {\n            if (slot.status === 'crafting') {\n                const el = grid.children[slot.id];\n                if (el) {\n                    const recipe = CraftingManager.getRecipe(slot.recipeId);\n                    const percent = Math.floor(\n                        ((Date.now() - slot.startTime) / slot.duration) * 100\n                    );\n                    const timeLeft = Math.ceil(\n                        (slot.duration - (Date.now() - slot.startTime)) / 1000\n                    );\n                    const iconPath = AssetLoader ? AssetLoader.getImagePath(recipe.outputIcon) : '';\n\n                    el.innerHTML = `\n                        <div style=\"display: flex; flex-direction: column; width: 100%; height: 100%; justify-content: space-between; padding: 4px;\">\n                            <div style=\"display: flex; align-items: center; width: 100%;\">\n                                <div class=\"slot-icon\" style=\"flex-shrink: 0; width: 64px; height: 64px; display: block; background-image: url('${iconPath}'); background-size: contain; background-repeat: no-repeat; background-position: center; border: none; background-color: transparent;\"></div>\n                                <div style=\"margin-left: 4px; font-size: 14px; font-weight: bold; color: #fff; text-shadow: 1px 1px 0 #000;\">x${slot.quantity}</div>\n                            </div>\n                            <div style=\"width: 100%; display: flex; flex-direction: column; gap: 4px;\">\n                                    <div class=\"slot-name\" style=\"font-size: 8px; color: #ccc; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 100%; text-align: center;\">${recipe.name}</div>\n                                    <div class=\"slot-progress\" style=\"width: 100%; height: 20px; background: #111; border: 1px solid #444; border-radius: 4px; position: relative; overflow: hidden; margin-bottom: 2px;\">\n                                        <div class=\"fill\" style=\"width: ${percent}%; background: var(--gradient-brass); height: 100%; transition: width 0.2s linear;\"></div>\n                                        <span style=\"position: absolute; top: 0; left: 0; width: 100%; text-align: center; font-size: 9px; line-height: 20px; color: #fff; text-shadow: 0 1px 2px #000;\">${timeLeft}s</span>\n                                    </div>\n                            </div>\n                        </div>\n                    `;\n                }\n            }\n        });\n    }\n\n    render(view = 'dashboard', context: ForgeContext = {}) {\n        if (!CraftingManager) return;\n        const grid = document.querySelector('.forge-grid');\n        if (!grid) return;\n\n        grid.innerHTML = '';\n        grid.className = 'forge-grid';\n        this.currentView = { view, context };\n\n        if (view === 'dashboard') {\n            grid.classList.add('forge-dashboard-compact');\n            CraftingManager.slots.forEach((slot: CraftingSlot) => {\n                const slotEl = DOMUtils.create('div', {\n                    className: `forge-slot ${slot.unlocked ? '' : 'locked'} ${slot.status === 'crafting' ? 'active' : ''}`\n                });\n\n                if (!slot.unlocked) {\n                    slotEl.innerHTML = `\n                         <div style=\"display: flex; flex-direction: column; width: 100%; height: 100%; justify-content: space-between; padding: 2px;\">\n                            <div style=\"display: flex; align-items: center; width: 100%;\">\n                                <div style=\"width: 64px; height: 64px; display: flex; align-items: center; justify-content: center; font-size: 32px;\">??</div>\n                            </div>\n                            <div style=\"width: 100%; display: flex; flex-direction: column; gap: 2px;\">\n                                 <div class=\"slot-name\" style=\"font-size: 9px; color: #888;\">Locked</div>\n                                 <div class=\"locked-cost\" style=\"width: 100%; text-align: right; color: #F39C12; font-size: 10px; font-weight: bold;\">${GameConstants.Crafting.FORGE_SLOT_UNLOCK_COST}g</div>\n                            </div>\n                        </div>\n                    `;\n                    slotEl.onclick = () => {\n                        if (CraftingManager.unlockSlot(slot.id)) {\n                            if (AudioManager) AudioManager.playSFX('sfx_ui_unlock');\n                            this.render('dashboard');\n                        } else {\n                            if (AudioManager) AudioManager.playSFX('sfx_ui_error');\n                            slotEl.style.borderColor = 'red';\n                            setTimeout(() => (slotEl.style.borderColor = ''), GameConstants.Timing.BORDER_FLASH_DURATION);\n                        }\n                    };\n                } else if (slot.status === 'crafting') {\n                    // Active Slot (Initial paint)\n                    // If recipeId is null here it's an error state or race condition, handle gracefully\n                    if (!slot.recipeId) {\n                        slotEl.innerHTML = '<div>Error</div>';\n                        return;\n                    }\n                    const recipe = CraftingManager.getRecipe(slot.recipeId);\n                    // Handle potential undefined recipe\n                    const iconPath = AssetLoader && recipe ? AssetLoader.getImagePath(recipe.outputIcon) : '';\n                    const recipeName = recipe ? recipe.name : 'Unknown';\n\n                    slotEl.innerHTML = `\n                        <div style=\"display: flex; flex-direction: column; width: 100%; height: 100%; justify-content: space-between; padding: 4px;\">\n                            <div style=\"display: flex; align-items: center; width: 100%;\">\n                                <div class=\"slot-icon\" style=\"flex-shrink: 0; width: 64px; height: 64px; display: block; background-image: url('${iconPath}'); background-size: contain; background-repeat: no-repeat; background-position: center; border: none; background-color: transparent;\"></div>\n                                <div style=\"margin-left: 4px; font-size: 14px; font-weight: bold; color: #fff; text-shadow: 1px 1px 0 #000;\">x${slot.quantity}</div>\n                            </div>\n                             <div style=\"width: 100%; display: flex; flex-direction: column; gap: 4px;\">\n                                  <div class=\"slot-name\" style=\"font-size: 8px; color: #ccc; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 100%; text-align: center;\">${recipeName}</div>\n                                  <div class=\"slot-progress\" style=\"width: 100%; height: 20px; background: #111; border: 1px solid #444; border-radius: 4px; position: relative; overflow: hidden; margin-bottom: 2px;\">\n                                       <div class=\"fill\" style=\"width: 0%; background: var(--gradient-brass); height: 100%;\"></div>\n                                       <span style=\"position: absolute; top: 0; left: 0; width: 100%; text-align: center; font-size: 9px; line-height: 20px; color: #fff; text-shadow: 0 1px 2px #000;\">...</span>\n                                  </div>\n                             </div>\n                        </div>\n                     `;\n                } else {\n                    slotEl.innerHTML = `\n                        <div style=\"display: flex; flex-direction: column; width: 100%; height: 100%; justify-content: space-between; padding: 2px;\">\n                            <div style=\"display: flex; align-items: center; width: 100%;\">\n                                <div style=\"width: 64px; height: 64px; display: flex; align-items: center; justify-content: center; font-size: 32px; opacity: 0.5;\">??</div>\n                            </div>\n                            <div style=\"width: 100%; display: flex; flex-direction: column; gap: 2px;\">\n                                 <div class=\"slot-name\" style=\"font-size: 9px; color: #666;\">Empty Slot</div>\n                                 <div class=\"slot-status\" style=\"width: 100%; text-align: right; color: #888; font-size: 10px;\">Idle</div>\n                            </div>\n                        </div>\n                    `;\n                    slotEl.onclick = () => this.render('recipes', { slotId: slot.id });\n                }\n                grid.appendChild(slotEl);\n            });\n        } else if (view === 'recipes') {\n            // Check context\n            if (context.slotId === undefined) return;\n\n            const header = DOMUtils.create('div', {\n                className: 'nav-header',\n                html: `<button class=\"back-btn\">< Back</button> <span>Select Blueprint (Slot ${context.slotId + 1})</span>`\n            });\n            const backBtn = header.querySelector('.back-btn');\n            if (backBtn) {\n                backBtn.addEventListener('click', () => {\n                    this.render('dashboard');\n                });\n            }\n            grid.appendChild(header);\n\n            CraftingManager.recipes.forEach((recipe: CraftingRecipe) => {\n                const iconPath = AssetLoader.getImagePath(recipe.outputIcon);\n                const item = DOMUtils.create('div', {\n                    className: 'forge-item',\n                    html: `\n                    <div class=\"forge-icon\" style=\"background-image: url('${iconPath || ''}')\"></div>\n                    <div class=\"forge-details\">\n                        <div class=\"forge-name\">${recipe.name}</div>\n                        <div class=\"forge-cost\">\n                            <span class=\"cost-item\">Wood: ${recipe.fuelCost}</span>\n                           ${Object.entries(recipe.ingredients)\n                            .map(\n                                ([k, v]) =>\n                                    `<span class=\"cost-item\">${k.replace('_', ' ')}: ${v}</span>`\n                            )\n                            .join('')}\n                        </div>\n                    </div>\n                `\n                });\n\n                const btn = DOMUtils.create('button', {\n                    className: 'forge-btn',\n                    text: 'SELECT',\n                    onClick: () =>\n                        this.render('batch', {\n                            slotId: context.slotId,\n                            recipeId: recipe.id\n                        })\n                }) as HTMLButtonElement;\n\n                if (!CraftingManager.canAfford(recipe, 1)) {\n                    btn.disabled = true;\n                    btn.textContent = 'LOCKED';\n                }\n\n                item.appendChild(btn);\n                grid.appendChild(item);\n            });\n        } else if (view === 'batch') {\n            if (context.slotId === undefined || !context.recipeId) return;\n\n            const recipe = CraftingManager.getRecipe(context.recipeId);\n            if (!recipe) return;\n\n            const max = CraftingManager.getMaxCraftable(recipe);\n\n            const header = DOMUtils.create('div', {\n                className: 'nav-header',\n                html: `<button class=\"back-btn\">< Back</button> <span>Configuring ${recipe.name} (Slot ${context.slotId + 1})</span>`\n            });\n            const backBtn = header.querySelector('.back-btn');\n            if (backBtn) {\n                (backBtn as HTMLElement).onclick = () =>\n                    this.render('recipes', { slotId: context.slotId });\n            }\n            grid.appendChild(header);\n\n            const container = DOMUtils.create('div', {\n                className: 'batch-control',\n                html: `\n                <div class=\"batch-amount\" id=\"batch-display\">1</div>\n                <div class=\"batch-slider-container\">\n                    <span>1</span>\n                    <input type=\"range\" min=\"1\" max=\"${Math.max(1, max)}\" value=\"1\" class=\"batch-slider\" id=\"batch-slider\">\n                    <span>${max}</span>\n                </div>\n                <div class=\"forge-cost\">Total Fuel: <span id=\"total-fuel\">${recipe.fuelCost}</span> Wood</div>\n                <button class=\"forge-btn\" id=\"confirm-craft\">START FORGING</button>\n            `\n            });\n            grid.appendChild(container);\n\n            const slider = document.getElementById('batch-slider');\n            const display = document.getElementById('batch-display');\n            const fuelDisplay = document.getElementById('total-fuel');\n            const confirmBtn = document.getElementById('confirm-craft');\n\n            if (max === 0) {\n                (slider as HTMLInputElement).disabled = true;\n                (confirmBtn as HTMLButtonElement).disabled = true;\n                (confirmBtn as HTMLElement).textContent = 'INSUFFICIENT RESOURCES';\n            }\n\n            (slider as HTMLInputElement).oninput = (e) => {\n                const val = (e.target as HTMLInputElement).value;\n                (display as HTMLElement).textContent = val;\n                (fuelDisplay as HTMLElement).textContent = String(parseInt(val) * recipe.fuelCost);\n            };\n\n            (confirmBtn as HTMLElement).onclick = () => {\n                const qty = parseInt((slider as HTMLInputElement).value);\n                const result = CraftingManager.startCrafting(\n                    context.slotId!,\n                    recipe.id,\n                    qty\n                );\n                if (result) {\n                    if (AudioManager) AudioManager.playSFX('sfx_ui_click');\n                    this.render('dashboard');\n                } else {\n                    (confirmBtn as HTMLElement).textContent = 'FAILED';\n                    setTimeout(\n                        () => ((confirmBtn as HTMLElement).textContent = 'START FORGING'),\n                        GameConstants.Timing.BUTTON_RESET_DELAY\n                    );\n                }\n            };\n        }\n    }\n}\n\n// Global hook\nconst ForgeController = new ForgePanel();\nif (Registry) Registry.register('ForgeController', ForgeController);\n\nexport { ForgeController, ForgePanel };\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\ui\\controllers\\HUDController.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getConfig' is defined but never used.","line":10,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":34,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"getConfig"},"fix":{"range":[256,267],"text":""},"desc":"Remove unused variable \"getConfig\"."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * HUDController - Manages the Heads-Up Display\r\n *\r\n * Handles Stamina, Health, and Resource counters.\r\n * Listens to EventBus updates.\r\n */\r\n\r\nimport { Logger } from '@core/Logger';\r\nimport { EventBus } from '@core/EventBus';\r\nimport { GameConstants, getConfig } from '@data/GameConstants';\r\nimport { Registry } from '@core/Registry';\r\nimport { UIBinder } from '@core/UIBinder';\r\nimport { SFX } from '@audio/SFX_Core';\r\n\r\n\r\n\r\nclass HUDControllerClass {\r\n    private lastPipCount: number = -1;\r\n    // private readonly RESOLVE_PER_PIP = 5; // Deprecated, use GameConstants\r\n\r\n    constructor() {\r\n        this.initListeners();\r\n        Logger.info('[HUDController] Initialized');\r\n    }\r\n\r\n    initListeners() {\r\n        if (!EventBus) return;\r\n\r\n        EventBus.on(\r\n            GameConstants.Events.HERO_STAMINA_CHANGE,\r\n            (data: { current: number; max: number }) => this.updateStamina(data)\r\n        );\r\n        EventBus.on(\r\n            GameConstants.Events.HERO_HEALTH_CHANGE,\r\n            (data: { current: number; max: number }) => this.updateHealth(data)\r\n        );\r\n        EventBus.on(\r\n            GameConstants.Events.INVENTORY_UPDATED,\r\n            (data: Record<string, number>) =>\r\n                this.updateResources(data)\r\n        );\r\n        EventBus.on(GameConstants.Events.HERO_HOME_STATE_CHANGE, (data: { isHome: boolean }) =>\r\n            this.updateRestButton(data)\r\n        );\r\n    }\r\n\r\n    updateStamina(data: { current: number; max: number }) {\r\n        const barContainer = UIBinder.get('ui-resolve-bar');\r\n        if (!barContainer) return;\r\n\r\n        // Ensure container exists\r\n        const pipsContainer = UIBinder.ensureContainer(\r\n            'resolve-pips-container',\r\n            'ui-resolve-bar'\r\n        );\r\n        if (!pipsContainer) return;\r\n\r\n        // 1. Calculate Target Pip Count (Dynamic Scaling)\r\n        const totalPips = Math.ceil(data.max / GameConstants.UI.RESOLVE_PER_PIP);\r\n        const currentActivePips = Math.ceil(data.current / GameConstants.UI.RESOLVE_PER_PIP);\r\n\r\n        // 2. Rebuild DOM if max resolve changed (or init)\r\n        if (pipsContainer.children.length !== totalPips) {\r\n            // Clean up old artifacts if we are rebuilding\r\n            pipsContainer.innerHTML = '';\r\n            for (let i = 0; i < totalPips; i++) {\r\n                UIBinder.create('div', { className: 'resolve-pip', parent: pipsContainer });\r\n            }\r\n            // Reset last count on rebuild to avoid animation spam\r\n            this.lastPipCount = currentActivePips;\r\n        }\r\n\r\n        // 3. Update States\r\n        const pips = Array.from(pipsContainer.children) as HTMLElement[];\r\n\r\n        pips.forEach((pip, index) => {\r\n            const isActive = index < currentActivePips;\r\n\r\n            if (isActive) {\r\n                // Determine if this pip needs to be filled\r\n                if (!pip.classList.contains('active')) {\r\n                    pip.classList.add('active');\r\n                    pip.classList.remove('lost');\r\n                }\r\n            } else {\r\n                // It is empty. Did it JUST lose its active state?\r\n                if (pip.classList.contains('active')) {\r\n                    pip.classList.remove('active');\r\n                    // Only trigger shatter if we aren't initializing (lastPipCount check)\r\n                    // But logic dictates if it WAS active in DOM, it's a valid loss frame.\r\n                    pip.classList.add('lost');\r\n\r\n                    // Play Sound\r\n                    SFX?.play('sfx_ui_resolve_shatter');\r\n\r\n                    // Clean up animation class after it finishes to reset state strictly\r\n                    setTimeout(() => {\r\n                        pip.classList.remove('lost');\r\n                    }, GameConstants.UI.ANIMATION_SHATTER_MS);\r\n                }\r\n            }\r\n        });\r\n\r\n        this.lastPipCount = currentActivePips;\r\n    }\r\n\r\n    updateHealth(data: { current: number; max: number }) {\r\n        const bar = UIBinder.get('health-bar');\r\n        const text = UIBinder.get('health-text');\r\n        if (bar) bar.style.width = `${(data.current / data.max) * 100}%`;\r\n        if (text) text.textContent = String(Math.floor(data.current));\r\n    }\r\n\r\n    updateRestButton(data: { isHome: boolean }) {\r\n        const btn = document.getElementById('btn-rest');\r\n        if (btn) btn.style.display = data.isHome ? 'flex' : 'none';\r\n    }\r\n\r\n    updateResources(inventory: Record<string, number>) {\r\n        if (!inventory) return;\r\n\r\n        const map: Record<string, string> = {\r\n            scraps_t1_01: 'res-scrap',\r\n            minerals_t1_01: 'res-iron',\r\n            minerals_t2_01: 'res-fuel',\r\n            gold: 'res-gold'\r\n        };\r\n\r\n        for (const [key, elementId] of Object.entries(map)) {\r\n            const el = UIBinder.get(elementId);\r\n            if (el) {\r\n                // Gold might be separate or in items, assuming flat structure from Hero.inventory\r\n                const amount = inventory[key] || 0;\r\n                el.textContent = String(amount);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// Register\r\nconst HUDController = new HUDControllerClass();\r\nif (Registry) Registry.register('HUDController', HUDController);\r\n\r\n// ES6 Module Export\r\nexport { HUDControllerClass, HUDController };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\ui\\core\\UIPanel.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Registry' is defined but never used.","line":12,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":18,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"Registry"},"fix":{"range":[287,329],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'UIPanelConfig' is defined but never used.","line":15,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":23,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"UIPanelConfig"},"fix":{"range":[435,449],"text":""},"desc":"Remove unused variable \"UIPanelConfig\"."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * UIPanel - Base Class for all UI Modules\n *\n * Provides standard functionality for:\n * - Visibility (Open/Close)\n * - Docking (Mobile Modal vs Desktop Sidebar)\n * - Layout State Management\n */\n\nimport { UIManager } from '../../ui/UIManager';\nimport { Logger } from '@core/Logger';\nimport { Registry } from '@core/Registry';\nimport { EventBus } from '@core/EventBus';\nimport { GameConstants } from '@data/GameConstants';\nimport { UIPanelConfig, UIPanelOptions } from '../../types/ui';\n\nclass UIPanel {\n    // Property declarations\n    id: string;\n    config: UIPanelOptions;\n    el: HTMLElement | null;\n    isOpen: boolean;\n    isDocked: boolean;\n\n    /**\n     * @param {string} id - DOM Element ID\n     * @param {UIPanelOptions} config - Configuration options\n     */\n    constructor(id: string, config: Partial<UIPanelOptions> = {}) {\n        this.id = id;\n        this.config = Object.assign(\n            {\n                id: id,\n                visible: false,\n                dockable: true,\n                defaultDock: 'ui-hud-right',\n                modalClass: 'modal-panel',\n                dockedClass: 'docked-panel',\n                isOpen: false\n            } as UIPanelOptions,\n            config\n        );\n\n        this.el = document.getElementById(this.id);\n        this.isOpen = false;\n        this.isDocked = false;\n\n        // Register with Manager if it exists\n        if (UIManager && UIManager.registerPanel) {\n            UIManager.registerPanel(this);\n        } else {\n            // Fallback retry if UIManager loads later\n            setTimeout(() => {\n                if (UIManager && UIManager.registerPanel) UIManager.registerPanel(this);\n            }, GameConstants.Timing.UI_PANEL_DEBOUNCE_MS);\n        }\n    }\n\n    /**\n     * Initialize logic (override in subclass)\n     */\n    init() {\n        Logger.info(`[UIPanel] Init ${this.id}`);\n    }\n\n    /**\n     * Toggle visibility\n     */\n    toggle() {\n        if (this.isOpen) this.close();\n        else this.open();\n    }\n\n    /**\n     * Open the panel\n     */\n    open() {\n        if (!this.el) this.el = document.getElementById(this.id);\n        if (!this.el) return;\n\n        if (EventBus && GameConstants?.Events) {\n            EventBus.emit(GameConstants.Events.UI_FULLSCREEN_OPENED, { source: this });\n        }\n\n        // If docked, we might need to close other docked panels (Accordion)\n        if (this.isDocked && UIManager) {\n            UIManager.handleAccordion(this);\n        }\n\n        this.el.style.display = 'flex';\n        this.isOpen = true;\n        this.onOpen();\n    }\n\n    /**\n     * Close the panel\n     */\n    close() {\n        if (!this.el) this.el = document.getElementById(this.id);\n        if (!this.el) return;\n\n        this.el.style.display = 'none';\n        this.isOpen = false;\n        this.onClose();\n    }\n\n    /**\n     * Lifecycle hooks\n     */\n    onOpen() { }\n    onClose() { }\n\n    /**\n     * Apply a layout mode (called by LayoutStrategies)\n     * @param {string} mode 'mobile' | 'desktop'\n     */\n    applyLayout(mode: string) {\n        if (!this.config.dockable) return;\n\n        if (mode === 'desktop') {\n            this.dock();\n        } else {\n            this.undock();\n        }\n    }\n\n    /**\n     * Dock to sidebar (PC Mode)\n     */\n    dock() {\n        if (this.isDocked) return;\n\n        const target = document.getElementById(this.config.defaultDock);\n        if (!target) return;\n\n        if (!this.el) this.el = document.getElementById(this.id);\n        if (this.el && this.el.parentElement !== target) {\n            target.appendChild(this.el);\n            this.el.classList.remove(this.config.modalClass);\n            this.el.classList.add(this.config.dockedClass);\n\n            // Hide by default when switching to dock to prevent visual clutter\n            // unless it was already maintaining state? Better to close to be safe.\n            this.close();\n\n            this.isDocked = true;\n        }\n    }\n\n    /**\n     * Undock to modal layer (Mobile Mode)\n     */\n    undock() {\n        if (!this.isDocked) return;\n\n        const target = document.getElementById('modal-layer');\n        if (!target) {\n            Logger.error('[UIPanel] Undock Failed: modal-layer not found!');\n            return;\n        }\n\n        if (!this.el) this.el = document.getElementById(this.id);\n\n        Logger.info(`[UIPanel] Undocking ${this.id} to modal-layer...`);\n\n        if (this.el && this.el.parentElement !== target) {\n            target.appendChild(this.el);\n            this.el.classList.remove(this.config.dockedClass);\n            this.el.classList.add(this.config.modalClass);\n\n            this.close(); // Reset state\n            this.isDocked = false;\n            Logger.info(`[UIPanel] ${this.id} Undocked Successfully.`);\n        }\n    }\n}\n\n// ES6 Module Export\nexport { UIPanel };\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\ui\\responsive\\LayoutStrategies.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\utils\\EntityScaling.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Logger' is defined but never used.","line":7,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":16,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"Logger"},"fix":{"range":[233,271],"text":""},"desc":"Remove unused import declaration."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * EntityScaling - Standardized logic for entity dimension calculations\r\n *\r\n * Ensures consistent application of width, height, and scale from config/registry.\r\n * Used by Entity constructors and refreshConfig() methods.\r\n */\r\nimport { Logger } from '@core/Logger';\r\nimport { Entity } from '../core/Entity';\r\nimport type { EntityConfig } from '../types/core';\r\n\r\nexport const EntityScaling = {\r\n    /**\r\n     * Calculate final dimensions for an entity based on config and defaults.\r\n     *\r\n     * Priority:\r\n     * 1. Instance Config (passed to constructor)\r\n     * 2. Registry Config (from EntityLoader)\r\n     * 3. Defaults\r\n     *\r\n     * Logic:\r\n     * - Base Width/Height = instance.width || registry.width || default\r\n     * - Scale = instance.sizeScale || instance.scale || registry.sizeScale || registry.scale || 1.0\r\n     * - Final = Base * Scale\r\n     *\r\n     * @param {object} instanceConfig - The specific config for this entity instance\r\n     * @param {object} registryConfig - The registry entry for this entity type\r\n     * @param {object} defaults - Fallback values { width, height }\r\n     * @returns {{ width: number, height: number, scale: number }}\r\n     */\r\n    calculateSize(instanceConfig: EntityConfig = {}, registryConfig: EntityConfig = {}, defaults: { width: number, height: number } = { width: 80, height: 80 }) {\r\n        // Priority: Registry (Dashboard) > Instance (Save Data/Map) > Defaults\r\n        // The User explicitly requested that Asset Dashboard settings must be the source of truth,\r\n        // ignoring potential \"baked\" values in save files or map data.\r\n\r\n        // 1. Determine Base Dimensions\r\n        // Registry Config wins to ensure updates propagate to all instances\r\n        const baseWidth = registryConfig.width || instanceConfig.width || defaults.width;\r\n        const baseHeight = registryConfig.height || instanceConfig.height || defaults.height;\r\n\r\n        // 2. Determine Scale\r\n        // Registry Config wins.\r\n        // We look for 'sizeScale' first, then 'scale'.\r\n        // We look for 'sizeScale' first, then 'scale'\r\n        // Type assertion needed because these might come from [key: string]: unknown\r\n        const registryScale = (registryConfig.sizeScale ?? registryConfig.scale) as number | undefined;\r\n        const instanceScale = (instanceConfig.sizeScale ?? instanceConfig.scale) as number | undefined;\r\n\r\n        // Strict Priority: Registry > Instance > Default (1.0)\r\n        // If Registry has a value, USE IT. Only fallback to instance if Registry is undefined.\r\n        // This ensures \"scale 4\" in dashboard applies even if map data says \"scale 1\".\r\n        // Strict Priority: Registry > Instance > Default (1.0)\r\n        // If Registry has a value, USE IT. Only fallback to instance if Registry is undefined.\r\n        // This ensures \"scale 4\" in dashboard applies even if map data says \"scale 1\".\r\n        const scale = (registryScale !== undefined) ? registryScale : (instanceScale || 1.0);\r\n\r\n        // 3. Calculate Final Dimensions\r\n        // We round to avoid sub-pixel blurring which looks bad in pixel art\r\n        const finalWidth = Math.round(baseWidth * scale);\r\n        const finalHeight = Math.round(baseHeight * scale);\r\n\r\n        let source = 'default';\r\n        if (registryScale !== undefined) source = 'registry';\r\n        else if (instanceScale !== undefined) source = 'instance';\r\n\r\n        return {\r\n            width: finalWidth,\r\n            height: finalHeight,\r\n            scale: scale,\r\n            baseWidth,\r\n            baseHeight,\r\n            source\r\n        };\r\n    },\r\n\r\n    /**\r\n     * Apply calculated dimensions to an entity instance\r\n     * @param {Entity} entity - The entity to update\r\n     * @param {object} config - Configuration used for logging context\r\n     */\r\n    applyToEntity(entity: Entity, instanceConfig: EntityConfig = {}, registryConfig: EntityConfig = {}, defaults: { width: number, height: number }) {\r\n        const size = this.calculateSize(instanceConfig, registryConfig, defaults);\r\n\r\n        entity.width = size.width;\r\n        entity.height = size.height;\r\n        entity.scale = size.scale; // Store scale for reference\r\n\r\n        // Update collision bounds if they exist\r\n        if (entity.collision && entity.collision.bounds) {\r\n            // Check if bounds were manually overridden in config (don't overwrite custom bounds)\r\n            // If bounds match previous dimensions (or are proportional), update them?\r\n            // Safer strategy: Update bounds to match new width/height unless explicitly set to something else?\r\n            // For now, simpler: Update bounds width/height to match entity width/height\r\n            // (most entities have bounds matching their size)\r\n\r\n            // OPTIONAL: Apply bounds scaling factor if defined (some entities have 0.8 collision box)\r\n            // But usually collision.bounds.width IS the final width.\r\n            entity.collision.bounds.width = size.width;\r\n            entity.collision.bounds.height = size.height;\r\n        }\r\n\r\n        // Logger.info(`[EntityScaling] Applied size to ${entity.id || 'entity'}: ${size.width}x${size.height} (Scale: ${size.scale})`);\r\n        return size;\r\n    }\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\utils\\typeGuards.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\vfx\\Animations.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\vfx\\FloatingText.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\vfx\\FogOfWarSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\vfx\\HealthBarRenderer.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ProgressBarOptions' is defined but never used.","line":10,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":49,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"ProgressBarOptions"},"fix":{"range":[303,323],"text":""},"desc":"Remove unused variable \"ProgressBarOptions\"."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * HealthBarRenderer - Utility for rendering health and respawn bars\r\n *\r\n * Consolidates duplicated health bar rendering code from Resource.js and Dinosaur.js.\r\n * Falls back to simple bars when ProgressBarRenderer is unavailable.\r\n *\r\n * Owner: VFX Specialist\r\n */\r\n\r\nimport { ProgressBarRenderer, ProgressBarOptions } from './ProgressBarRenderer';\r\n\r\n// Ambient declaration for global dependency\r\n\r\nexport interface HealthBarOptions {\r\n    x: number;\r\n    y: number;\r\n    percent: number;\r\n    mode?: 'health' | 'respawn';\r\n    width?: number;\r\n    height?: number;\r\n    entityId?: string;\r\n    animated?: boolean;\r\n}\r\n\r\ninterface EntityWithPosition {\r\n    x: number;\r\n    y: number;\r\n    height: number;\r\n    id?: string;\r\n}\r\n\r\nexport interface EntityWithHealth extends EntityWithPosition {\r\n    health: number;\r\n    maxHealth: number;\r\n    components?: {\r\n        health?: {\r\n            health: number;\r\n            maxHealth: number;\r\n        };\r\n    };\r\n}\r\n\r\nexport interface EntityWithRespawn extends EntityWithPosition {\r\n    respawnTimer: number;\r\n    maxRespawnTime: number;\r\n    currentRespawnDuration?: number;\r\n}\r\n\r\nconst HealthBarRenderer = {\r\n    /**\r\n     * Draw a health or respawn bar above an entity\r\n     * @param {CanvasRenderingContext2D} ctx\r\n     * @param {HealthBarOptions} options\r\n     * @param {number} options.x - Center X position of entity\r\n     * @param {number} options.y - Top Y position (above entity)\r\n     * @param {number} options.percent - Fill percentage (0-1)\r\n     * @param {string} options.mode - 'health' or 'respawn'\r\n     * @param {number} [options.width=100] - Bar width\r\n     * @param {number} [options.height=14] - Bar height\r\n     * @param {string} [options.entityId] - Optional entity ID for tracking\r\n     * @param {boolean} [options.animated=true] - Whether to animate\r\n     */\r\n    draw(ctx: CanvasRenderingContext2D, options: HealthBarOptions) {\r\n        const {\r\n            x,\r\n            y,\r\n            percent,\r\n            mode = 'health',\r\n            width = 100,\r\n            height = 14,\r\n            entityId,\r\n            animated = true\r\n        } = options;\r\n\r\n        const barX = x - width / 2;\r\n        const barY = y;\r\n\r\n        // Use ProgressBarRenderer if available\r\n        if (ProgressBarRenderer) {\r\n            ProgressBarRenderer.draw(ctx, {\r\n                x: barX,\r\n                y: barY,\r\n                width,\r\n                height,\r\n                percent,\r\n                mode,\r\n                entityId,\r\n                animated\r\n            });\r\n            return;\r\n        }\r\n\r\n        // Fallback: simple colored bar\r\n        ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';\r\n        ctx.fillRect(barX, barY, width, height);\r\n\r\n        if (mode === 'health') {\r\n            // Color based on health level\r\n            if (percent > 0.5) {\r\n                ctx.fillStyle = '#4CAF50'; // Green\r\n            } else if (percent > 0.25) {\r\n                ctx.fillStyle = '#F39C12'; // Orange\r\n            } else {\r\n                ctx.fillStyle = '#E74C3C'; // Red\r\n            }\r\n        } else if (mode === 'respawn') {\r\n            ctx.fillStyle = '#3498DB'; // Blue\r\n        } else {\r\n            ctx.fillStyle = '#4CAF50'; // Default green\r\n        }\r\n\r\n        ctx.fillRect(barX, barY, width * Math.max(0, Math.min(1, percent)), height);\r\n    },\r\n\r\n    /**\r\n     * Draw a health bar for an entity with standard positioning\r\n     * @param {CanvasRenderingContext2D} ctx\r\n     * @param {EntityWithHealth} entity - Entity with x, y: number, width: number, height: number, health, maxHealth\r\n     * @param {Partial<HealthBarOptions>} [options] - Override options\r\n     */\r\n    drawForEntity(ctx: CanvasRenderingContext2D, entity: EntityWithHealth, options: Partial<HealthBarOptions> = {}) {\r\n        const barY = entity.y - entity.height / 2 - 18;\r\n\r\n        // Check for HealthComponent first\r\n        const healthComp = entity.components?.health;\r\n        const current = healthComp ? healthComp.health : entity.health;\r\n        const max = healthComp ? healthComp.maxHealth || entity.maxHealth : entity.maxHealth;\r\n\r\n        this.draw(ctx, {\r\n            x: entity.x,\r\n            y: barY,\r\n            percent: current / max,\r\n            mode: 'health',\r\n            entityId: entity.id,\r\n            ...options\r\n        });\r\n    },\r\n\r\n    /**\r\n     * Draw a respawn bar for an entity with standard positioning\r\n     * @param {CanvasRenderingContext2D} ctx\r\n     * @param {EntityWithRespawn} entity - Entity with x, y: number, respawnTimer, maxRespawnTime\r\n     * @param {Partial<HealthBarOptions>} [options] - Override options\r\n     */\r\n    drawRespawnForEntity(ctx: CanvasRenderingContext2D, entity: EntityWithRespawn, options: Partial<HealthBarOptions> = {}) {\r\n        const barY = entity.y - entity.height / 2 - 18;\r\n        const totalDuration = entity.currentRespawnDuration || entity.maxRespawnTime;\r\n        const percent = Math.max(0, 1 - entity.respawnTimer / totalDuration);\r\n\r\n        this.draw(ctx, {\r\n            x: entity.x,\r\n            y: barY,\r\n            percent,\r\n            mode: 'respawn',\r\n            ...options\r\n        });\r\n    }\r\n};\r\n\r\n// ES6 Module Export\r\nexport { HealthBarRenderer };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\vfx\\LightingSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\vfx\\MaterialLibrary.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\vfx\\MeleeTrailConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\vfx\\MeleeTrailRenderers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\vfx\\MeleeTrailVFX.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'viewport' is defined but never used. Allowed unused args must match /^_/u.","line":77,"column":43,"nodeType":"Identifier","messageId":"unusedVar","endLine":77,"endColumn":51}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * MeleeTrailVFX - Unique trailing effects for each melee weapon type\r\n *\r\n * Tracks weapon tip positions and renders type-specific effects.\r\n * Configs: MeleeTrailConfig. Renderers: MeleeTrailRenderers.\r\n */\r\n\r\nimport { VFXController } from './VFXController';\r\nimport { Registry } from '@core/Registry';\r\nimport { MELEE_TRAIL_CONFIGS } from './MeleeTrailConfig';\r\nimport * as TrailRenderers from './MeleeTrailRenderers';\r\nimport type { MeleeTrailPoint } from '../types/vfx';\r\n\r\nconst MeleeTrailVFX = {\r\n    trails: { hand1: [] as MeleeTrailPoint[], hand2: [] as MeleeTrailPoint[] },\r\n\r\n    /**\r\n     * Add a trail point at weapon tip position\r\n     */\r\n    addPoint(x: number, y: number, weaponSubtype = 'sword', slot = 'hand1') {\r\n        if (!isFinite(x) || !isFinite(y)) return;\r\n\r\n        const config = MELEE_TRAIL_CONFIGS[weaponSubtype] || MELEE_TRAIL_CONFIGS.default;\r\n        const trail = this.trails[slot as 'hand1' | 'hand2'] || [];\r\n\r\n        trail.unshift({\r\n            x: x,\r\n            y: y,\r\n            age: 0,\r\n            config: config,\r\n            subtype: weaponSubtype\r\n        });\r\n\r\n        while (trail.length > config.maxPoints) {\r\n            trail.pop();\r\n        }\r\n\r\n        this.trails[slot as 'hand1' | 'hand2'] = trail;\r\n\r\n        // Spawn particles for particle-emitting weapons\r\n        if (config.particles && trail.length === 1 && VFXController) {\r\n            VFXController.playForeground(x, y, {\r\n                type: 'spark',\r\n                color: config.color,\r\n                count: 2,\r\n                speed: 20,\r\n                lifetime: 150,\r\n                size: 3,\r\n                spread: 1.0,\r\n                drag: 0.9\r\n            });\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Update all trail point ages\r\n     */\r\n    update(dt: number) {\r\n        const dtSec = dt / 1000;\r\n\r\n        for (const slot of ['hand1', 'hand2'] as const) {\r\n            const trail = this.trails[slot];\r\n            if (!trail) continue;\r\n\r\n            for (let i = trail.length - 1; i >= 0; i--) {\r\n                trail[i].age += dtSec;\r\n                if (trail[i].age >= trail[i].config.lifetime) {\r\n                    trail.splice(i, 1);\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Render all trails\r\n     */\r\n    render(ctx: CanvasRenderingContext2D, viewport: { x: number; y: number }) {\r\n        for (const slot of ['hand1', 'hand2'] as const) {\r\n            const trail = this.trails[slot];\r\n            if (!trail || trail.length < 2) continue;\r\n\r\n            const config = trail[0]?.config;\r\n            if (!config) continue;\r\n\r\n            switch (config.style) {\r\n                case 'afterimage': TrailRenderers.renderAfterimage(ctx, trail); break;\r\n                case 'heavy': TrailRenderers.renderHeavy(ctx, trail); break;\r\n                case 'debris': TrailRenderers.renderDebris(ctx, trail); break;\r\n                case 'crescent': TrailRenderers.renderCrescent(ctx, trail); break;\r\n                case 'burst':\r\n                case 'impact': TrailRenderers.renderImpact(ctx, trail); break;\r\n                case 'thrust': TrailRenderers.renderThrust(ctx, trail); break;\r\n                case 'sweep': TrailRenderers.renderSweep(ctx, trail); break;\r\n                case 'chain': TrailRenderers.renderChain(ctx, trail); break;\r\n                default: TrailRenderers.renderArc(ctx, trail);\r\n            }\r\n        }\r\n    },\r\n\r\n    clear() {\r\n        this.trails = { hand1: [], hand2: [] };\r\n    },\r\n\r\n    spawn(x: number, y: number, angle: number, progress: number, weaponSubtype: string) {\r\n        this.addPoint(x, y, weaponSubtype, 'hand1');\r\n    }\r\n};\r\n\r\nif (Registry) Registry.register('MeleeTrailVFX', MeleeTrailVFX);\r\n\r\n// ES6 Module Export\r\nexport { MeleeTrailVFX };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\vfx\\ParticleRenderer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\vfx\\ParticleSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\vfx\\ProgressBarRenderer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\vfx\\ProjectileMuzzleFlash.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\vfx\\ProjectileVFX.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":165,"column":26,"nodeType":"Identifier","messageId":"unusedVar","endLine":165,"endColumn":27}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * ProjectileVFX - Spawns traveling projectile visual effects\r\n *\r\n * Creates projectiles that travel from gun tip to target.\r\n * Configs: ProjectileVFXConfig. Muzzle: ProjectileMuzzleFlash. Weapon type: ProjectileWeaponType.\r\n */\r\n\r\nimport { RenderConfig } from '@config/RenderConfig';\r\nimport { LightingSystem } from './LightingSystem';\r\nimport { Registry } from '@core/Registry';\r\nimport { MathUtils } from '@core/MathUtils';\r\nimport { PROJECTILE_CONFIGS, type ProjectileConfig } from './ProjectileVFXConfig';\r\nimport { spawnMuzzleFlash } from './ProjectileMuzzleFlash';\r\nimport { getWeaponType } from './ProjectileWeaponType';\r\n\r\ninterface Projectile {\r\n    x: number;\r\n    y: number;\r\n    targetX: number;\r\n    targetY: number;\r\n    angle: number;\r\n    speed: number;\r\n    color: string;\r\n    coreColor: string;\r\n    size: number;\r\n    length: number;\r\n    glow: boolean;\r\n    glowSize: number;\r\n    trail: boolean;\r\n    fade: boolean;\r\n    distance: number;\r\n    traveled: number;\r\n    active: boolean;\r\n    alpha: number;\r\n}\r\n\r\nconst ProjectileVFX = {\r\n    projectiles: [] as Projectile[],\r\n\r\n    /**\r\n     * Spawn projectile(s) from origin to target\r\n     * @param {Object} origin - {x, y} world coordinates of origin (hero)\r\n     * @param {Object} target - {x, y} world coordinates of target\r\n     * @param {string} weaponType - Weapon subtype (pistol, rifle, etc)\r\n     */\r\n    spawn(origin: { x: number; y: number }, target: { x: number; y: number }, weaponType = 'pistol') {\r\n        const config = PROJECTILE_CONFIGS[weaponType] || PROJECTILE_CONFIGS.default;\r\n\r\n        // Calculate trajectory\r\n        const dx = target.x - origin.x;\r\n        const dy = target.y - origin.y;\r\n        const angle = Math.atan2(dy, dx);\r\n\r\n        // Muzzle offset - distance from hero center to gun muzzle (top-right of weapon image)\r\n        // After sprite rotation, the muzzle is aligned with the aim direction (baseAngle)\r\n        let muzzleOffset = 80; // Default fallback\r\n\r\n        if (RenderConfig?.Hero?.WEAPON?.RIFLE) {\r\n            const cfg = RenderConfig.Hero.WEAPON.RIFLE;\r\n            // Weapon image has grip at bottom-left, muzzle at top-right (diagonal)\r\n            // After SPRITE_ROTATION, muzzle points along the aim direction\r\n            // So muzzle position is simply along the aim angle\r\n            muzzleOffset = cfg.TARGET_WIDTH * 0.85; // Muzzle at 85% of weapon length\r\n        }\r\n\r\n        // Muzzle is along the aim direction (after rotation aligns it)\r\n        const muzzleX = origin.x + Math.cos(angle) * muzzleOffset;\r\n        const muzzleY = origin.y + Math.sin(angle) * muzzleOffset;\r\n\r\n        // Calculate actual travel distance from muzzle to target\r\n        const distance = MathUtils.distance(muzzleX, muzzleY, target.x, target.y);\r\n\r\n        spawnMuzzleFlash(muzzleX, muzzleY, angle, config);\r\n\r\n        // Spawn projectile(s)\r\n        if (config.pellets) {\r\n            // Shotgun: multiple pellets with spread\r\n            for (let i = 0; i < config.pellets; i++) {\r\n                const spreadAngle = angle + (Math.random() - 0.5) * (config.spread || 0.35);\r\n                this.createProjectile(\r\n                    muzzleX,\r\n                    muzzleY,\r\n                    spreadAngle,\r\n                    distance,\r\n                    config,\r\n                    target\r\n                );\r\n            }\r\n        } else {\r\n            // Single projectile\r\n            this.createProjectile(muzzleX, muzzleY, angle, distance, config, target);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Create a single projectile\r\n     */\r\n    createProjectile(x: number, y: number, angle: number, distance: number, config: ProjectileConfig, target: { x: number; y: number }) {\r\n        const projectile: Projectile = {\r\n            x: x,\r\n            y: y,\r\n            targetX: target.x,\r\n            targetY: target.y,\r\n            angle: angle,\r\n            speed: config.speed,\r\n            color: config.color,\r\n            coreColor: config.coreColor || '#FFFFFF',\r\n            size: config.size,\r\n            length: config.length,\r\n            glow: config.glow || false,\r\n            glowSize: config.glowSize || config.size * 2,\r\n            trail: config.trail || false,\r\n            fade: config.fade || false,\r\n            distance: distance,\r\n            traveled: 0,\r\n            active: true,\r\n            alpha: 1.0\r\n        };\r\n\r\n        this.projectiles.push(projectile);\r\n    },\r\n\r\n    /**\r\n     * Update all active projectiles\r\n     * @param {number} dt - Delta time in milliseconds\r\n     */\r\n    update(dt: number) {\r\n        // Convert dt from milliseconds to seconds\r\n        const dtSeconds = dt / 1000;\r\n\r\n        for (let i = this.projectiles.length - 1; i >= 0; i--) {\r\n            const p = this.projectiles[i];\r\n\r\n            // Move projectile\r\n            const moveDistance = p.speed * dtSeconds;\r\n            p.x += Math.cos(p.angle) * moveDistance;\r\n            p.y += Math.sin(p.angle) * moveDistance;\r\n            p.traveled += moveDistance;\r\n\r\n            // Check if reached target\r\n            if (p.traveled >= p.distance) {\r\n                p.active = false;\r\n            }\r\n\r\n            // Submit light to LightingSystem (if active and glowing)\r\n            if (\r\n                p.active &&\r\n                p.glow &&\r\n                LightingSystem &&\r\n                typeof LightingSystem.addLight === 'function'\r\n            ) {\r\n                try {\r\n                    const radius = 50 + (p.glowSize || p.size * 2) * 2;\r\n                    // Elongation based on projectile length/size ratio\r\n                    const elongation = 1.5; // Stretch 1.5x along direction\r\n                    LightingSystem.addLight(\r\n                        p.x,\r\n                        p.y,\r\n                        radius,\r\n                        p.color,\r\n                        p.alpha,\r\n                        p.angle,\r\n                        elongation\r\n                    );\r\n                } catch (e) {\r\n                    // Silently ignore lighting errors\r\n                }\r\n            }\r\n\r\n            // Fade effect\r\n            if (p.fade) {\r\n                p.alpha = 1.0 - p.traveled / p.distance;\r\n            }\r\n\r\n            // Remove inactive projectiles\r\n            if (!p.active) {\r\n                this.projectiles.splice(i, 1);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Render all active projectiles\r\n     * @param {CanvasRenderingContext2D} ctx - Canvas context (already translated by viewport)\r\n     */\r\n    render(ctx: CanvasRenderingContext2D) {\r\n        if (!ctx) return;\r\n\r\n        for (const p of this.projectiles) {\r\n            if (!p.active) continue;\r\n\r\n            const screenX = p.x;\r\n            const screenY = p.y;\r\n\r\n            // Calculate tail position\r\n            const tailX = screenX - Math.cos(p.angle) * p.length;\r\n            const tailY = screenY - Math.sin(p.angle) * p.length;\r\n\r\n            ctx.save();\r\n            ctx.globalAlpha = p.alpha;\r\n\r\n            // Layer 1: Outer glow (if enabled)\r\n            if (p.glow) {\r\n                ctx.shadowColor = p.color;\r\n                ctx.shadowBlur = p.glowSize;\r\n                ctx.strokeStyle = p.color;\r\n                ctx.lineWidth = p.size * 1.5;\r\n                ctx.lineCap = 'round';\r\n                ctx.globalAlpha = p.alpha * 0.5;\r\n                ctx.beginPath();\r\n                ctx.moveTo(tailX, tailY);\r\n                ctx.lineTo(screenX, screenY);\r\n                ctx.stroke();\r\n                ctx.shadowBlur = 0;\r\n            }\r\n\r\n            // Layer 2: Main tracer body\r\n            ctx.globalAlpha = p.alpha;\r\n            ctx.strokeStyle = p.color;\r\n            ctx.lineWidth = p.size;\r\n            ctx.lineCap = 'round';\r\n            ctx.beginPath();\r\n            ctx.moveTo(tailX, tailY);\r\n            ctx.lineTo(screenX, screenY);\r\n            ctx.stroke();\r\n\r\n            // Layer 3: Bright white-hot core (head of projectile)\r\n            const coreLength = p.length * 0.4;\r\n            const coreTailX = screenX - Math.cos(p.angle) * coreLength;\r\n            const coreTailY = screenY - Math.sin(p.angle) * coreLength;\r\n            ctx.strokeStyle = p.coreColor;\r\n            ctx.lineWidth = p.size * 0.6;\r\n            ctx.beginPath();\r\n            ctx.moveTo(coreTailX, coreTailY);\r\n            ctx.lineTo(screenX, screenY);\r\n            ctx.stroke();\r\n\r\n            if (p.trail) {\r\n                ctx.globalAlpha = p.alpha * 0.2;\r\n                ctx.strokeStyle = p.color;\r\n                ctx.lineWidth = p.size * 0.4;\r\n                const trailLength = p.length * 2.5;\r\n                const trailTailX = screenX - Math.cos(p.angle) * trailLength;\r\n                const trailTailY = screenY - Math.sin(p.angle) * trailLength;\r\n                ctx.beginPath();\r\n                ctx.moveTo(trailTailX, trailTailY);\r\n                ctx.lineTo(tailX, tailY);\r\n                ctx.stroke();\r\n            }\r\n\r\n            ctx.restore();\r\n        }\r\n    },\r\n\r\n    getWeaponType: getWeaponType\r\n};\r\n\r\n// Export\r\nif (Registry) Registry.register('ProjectileVFX', ProjectileVFX);\r\n\r\nexport { ProjectileVFX };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\vfx\\ProjectileVFXConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\vfx\\ProjectileWeaponType.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\vfx\\VFXController.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'VFXSequence' is defined but never used.","line":19,"column":32,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":43,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"VFXSequence"},"fix":{"range":[718,731],"text":""},"desc":"Remove unused variable \"VFXSequence\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'contextOptions' is assigned a value but never used. Allowed unused args must match /^_/u.","line":129,"column":51,"nodeType":"Identifier","messageId":"unusedVar","endLine":129,"endColumn":65}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * VFX Controller (System 2.0)\r\n * Orchestrates all visual effects using a Data-Driven Sequencer.\r\n *\r\n * Owner: VFX Specialist\r\n */\r\n\r\nimport { Logger } from '@core/Logger';\r\nimport { EventBus } from '@core/EventBus';\r\nimport { GameConstants } from '@data/GameConstants';\r\nimport { ParticleSystem } from './ParticleSystem';\r\nimport { Registry } from '@core/Registry';\r\nimport { ProjectileVFX } from './ProjectileVFX';\r\nimport { MeleeTrailVFX } from './MeleeTrailVFX';\r\nimport { FloatingTextManager, FloatingText } from './FloatingText';\r\nimport { VFXConfig } from '@data/VFXConfig';\r\nimport { GameRenderer } from '@core/GameRenderer';\r\nimport type { IGame } from '../types/core.d';\r\nimport type { ParticleOptions, VFXSequence, VFXCue } from '../types/vfx';\r\n\r\nclass VFXSystem {\r\n    // Property declarations\r\n    game: IGame | null = null;\r\n    bgParticles: typeof ParticleSystem | null = null;\r\n    fgParticles: typeof ParticleSystem | null = null;\r\n    texts: FloatingText[] = [];\r\n    activeSequences: Array<{\r\n        name?: string;\r\n        x: number;\r\n        y: number;\r\n        elapsed: number;\r\n        cues: Array<{ time: number; type: string; options?: ParticleOptions }>;\r\n        options?: ParticleOptions;\r\n    }> = [];\r\n    initialized: boolean = false;\r\n\r\n    constructor() {\r\n        Logger.info('[VFXSystem] Constructed');\r\n    }\r\n\r\n    init(game: IGame) {\r\n        this.game = game;\r\n        // Initialize dual-layer canvas system\r\n        // Note: ParticleSystem is expected to be a global or imported class\r\n        if (ParticleSystem) {\r\n            this.bgParticles = Object.create(ParticleSystem);\r\n            this.fgParticles = Object.create(ParticleSystem);\r\n\r\n            this.bgParticles.init('vfx-canvas');\r\n            this.fgParticles.init('vfx-canvas-fg');\r\n            Logger.info('[VFXSystem] Particles initialized');\r\n        } else {\r\n            Logger.error('[VFXSystem] ParticleSystem not found! Check load order.');\r\n        }\r\n\r\n        if (EventBus && GameConstants) {\r\n            EventBus.on(GameConstants.Events.VFX_PLAY_FOREGROUND, (data: { x: number; y: number; options?: ParticleOptions }) => {\r\n                if (data && typeof data.x === 'number' && typeof data.y === 'number') {\r\n                    this.playForeground(data.x, data.y, data.options);\r\n                }\r\n            });\r\n            EventBus.on(GameConstants.Events.HERO_LEVEL_UP, (data: { hero?: { x: number; y: number } }) => {\r\n                const hero = data?.hero;\r\n                if (hero && typeof hero.x === 'number' && typeof hero.y === 'number') {\r\n                    const opts = VFXConfig.TEMPLATES?.LEVEL_UP_FX || { type: 'burst', color: '#FFD700', count: 30, lifetime: 1000 };\r\n                    this.playForeground(hero.x, hero.y, opts);\r\n                }\r\n            });\r\n        }\r\n\r\n        this.initialized = true;\r\n        Logger.info('[VFXSystem] Initialized');\r\n    }\r\n\r\n    /**\r\n     * Update all VFX systems\r\n     */\r\n    update(dt: number) {\r\n        if (!this.initialized) return;\r\n\r\n        if (this.bgParticles) this.bgParticles.update(dt);\r\n        if (this.fgParticles) this.fgParticles.update(dt);\r\n\r\n        // Update Texts\r\n        for (let i = this.texts.length - 1; i >= 0; i--) {\r\n            const text = this.texts[i];\r\n            text.update(dt);\r\n            if (!text.active) {\r\n                this.texts.splice(i, 1);\r\n            }\r\n        }\r\n\r\n        // Update Active Sequences\r\n        for (let i = this.activeSequences.length - 1; i >= 0; i--) {\r\n            const seq = this.activeSequences[i];\r\n            seq.elapsed += dt;\r\n\r\n            // Check for cues to fire\r\n            while (seq.cues.length > 0 && seq.cues[0].time <= seq.elapsed) {\r\n                const cue = seq.cues.shift(); // Remove and fire\r\n                this.executeCue(cue, seq.x, seq.y, seq.options);\r\n            }\r\n\r\n            // Remove finished sequences\r\n            if (seq.cues.length === 0) {\r\n                this.activeSequences.splice(i, 1);\r\n            }\r\n        }\r\n\r\n        // Update traveling projectiles\r\n        if (ProjectileVFX) {\r\n            ProjectileVFX.update(dt);\r\n        }\r\n\r\n        // Update melee trails\r\n        if (MeleeTrailVFX) {\r\n            MeleeTrailVFX.update(dt);\r\n        }\r\n\r\n        // Update floating text (damage numbers, etc.)\r\n        if (FloatingTextManager) {\r\n            FloatingTextManager.update(dt);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Execute a single cue from a sequence\r\n     */\r\n    executeCue(cue: VFXCue, x: number, y: number, contextOptions: ParticleOptions = {}) {\r\n        // Resolve Template if present\r\n        let config: ParticleOptions = {};\r\n\r\n        if (cue.template && VFXConfig && VFXConfig.TEMPLATES[cue.template]) {\r\n            // Merge Template with Cue Params (Cue wins)\r\n            config = { ...VFXConfig.TEMPLATES[cue.template], ...(cue.params || {}) };\r\n        } else if (cue.type) {\r\n            // Direct definition\r\n            // Cast strictly to ensure 'type' matches allowed string literals\r\n            config = { type: cue.type as ParticleOptions['type'], ...(cue.params || {}) };\r\n        } else {\r\n            // cue.template might refer to a template that doesn't exist?\r\n            Logger.warn('[VFXSystem] Invalid cue config:', cue);\r\n            return;\r\n        }\r\n\r\n        // Determine Layer\r\n        const layer = cue.layer || 'fg';\r\n        const system = layer === 'bg' ? this.bgParticles : this.fgParticles;\r\n\r\n        if (!system) return;\r\n\r\n        // Emit Particle\r\n        system.emit(x, y, config);\r\n    }\r\n\r\n    /**\r\n     * Play a named sequence from VFXConfig\r\n     * @param {string} sequenceName - Key in VFXConfig.SEQUENCES\r\n     * @param {number} x - World X\r\n     * @param {number} y - World Y\r\n     * @param {object} options - Optional overrides\r\n     */\r\n    playSequence(sequenceName: string, x: number, y: number, options: ParticleOptions = {}) {\r\n        if (!VFXConfig || !VFXConfig.SEQUENCES[sequenceName]) {\r\n            Logger.warn(`[VFXSystem] Sequence not found: ${sequenceName}`);\r\n            return;\r\n        }\r\n\r\n        const rawSequence = VFXConfig.SEQUENCES[sequenceName];\r\n\r\n        // GC Optimization: Build cues array more efficiently\r\n        const cues = [];\r\n        for (let i = 0; i < rawSequence.length; i++) {\r\n            const src = rawSequence[i];\r\n            cues.push({\r\n                time: src.time,\r\n                template: src.template,\r\n                type: src.type,\r\n                layer: src.layer,\r\n                params: src.params\r\n            });\r\n        }\r\n        // Sort by time just in case config is out of order\r\n        cues.sort((a, b) => a.time - b.time);\r\n\r\n        this.activeSequences.push({\r\n            name: sequenceName,\r\n            cues: cues,\r\n            elapsed: 0,\r\n            x: x,\r\n            y: y,\r\n            options: options\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Helper: Play a generic effect immediately (using Template or raw config)\r\n     */\r\n    playEffect(configOrTemplateName: string | ParticleOptions, x: number, y: number, layer = 'fg') {\r\n        let config = configOrTemplateName;\r\n\r\n        // Check if string -> Template\r\n        if (typeof configOrTemplateName === 'string') {\r\n            if (VFXConfig && VFXConfig.TEMPLATES[configOrTemplateName]) {\r\n                config = VFXConfig.TEMPLATES[configOrTemplateName];\r\n            } else {\r\n                Logger.warn(`[VFXSystem] Template not found: ${configOrTemplateName}`);\r\n                return;\r\n            }\r\n        }\r\n\r\n        const system = layer === 'bg' ? this.bgParticles : this.fgParticles;\r\n        if (system) system.emit(x, y, config);\r\n    }\r\n\r\n    /**\r\n     * Render (Called by GameRenderer with main context)\r\n     */\r\n    render(ctx: CanvasRenderingContext2D) {\r\n        if (!this.initialized) return;\r\n\r\n        // Render all floating texts to the game canvas\r\n        for (const text of this.texts) {\r\n            text.render(ctx);\r\n        }\r\n\r\n        // Render traveling projectiles (no camera offset needed - ctx is already translated)\r\n        if (ProjectileVFX) {\r\n            ProjectileVFX.render(ctx);\r\n        }\r\n\r\n        // Render melee trails (needs viewport for world-to-screen conversion)\r\n        if (MeleeTrailVFX && GameRenderer) {\r\n            const viewport = {\r\n                x: GameRenderer.viewport.x,\r\n                y: GameRenderer.viewport.y,\r\n                scale: 1, // GameRenderer doesn't use scale, always 1:1\r\n                screenX: 0,\r\n                screenY: 0\r\n            };\r\n            MeleeTrailVFX.render(ctx, viewport);\r\n        }\r\n\r\n        // Render floating text (damage numbers, etc.)\r\n        if (FloatingTextManager) {\r\n            FloatingTextManager.render(ctx);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Render Foreground Particles to their own overlay canvas\r\n     * Called by Game.js main loop, NOT GameRenderer\r\n     */\r\n    renderForeground() {\r\n        if (!this.initialized || !this.fgParticles) return;\r\n        this.fgParticles.render();\r\n    }\r\n\r\n    /**\r\n     * Legacy Compat: Play a foreground effect (above UI)\r\n     */\r\n    playForeground(x: number, y: number, options: ParticleOptions = {}) {\r\n        if (this.fgParticles) this.fgParticles.emit(x, y, options);\r\n    }\r\n\r\n    /**\r\n     * Legacy Compat: Play a background effect (behind UI)\r\n     */\r\n    playBackground(x: number, y: number, options: ParticleOptions = {}) {\r\n        if (this.bgParticles) this.bgParticles.emit(x, y, options);\r\n    }\r\n\r\n    /**\r\n     * Map UI DOM coordinates to Canvas coordinates\r\n     */\r\n    uiToCanvas(clientX: number, clientY: number, canvasId: string = 'vfx-canvas-fg') {\r\n        const canvas = document.getElementById(canvasId) as HTMLCanvasElement;\r\n        if (!canvas) return { x: 0, y: 0 };\r\n\r\n        const rect = canvas.getBoundingClientRect();\r\n        const scaleX = canvas.width / rect.width;\r\n        const scaleY = canvas.height / rect.height;\r\n\r\n        return {\r\n            x: (clientX - rect.left) * scaleX,\r\n            y: (clientY - rect.top) * scaleY\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Spawn floating text at world coordinates\r\n     */\r\n    spawnFloatingText(text: string, worldX: number, worldY: number, color = '#FFD700', duration = 2000) {\r\n        if (FloatingText) {\r\n            // FloatingText expects a config object, not separate color/duration params\r\n            const config = {\r\n                color: color,\r\n                floatDuration: duration / 2000, // Convert ms to seconds\r\n                holdDuration: 0.2\r\n            };\r\n            const ft = new FloatingText(text, worldX, worldY, config, 0);\r\n            this.texts.push(ft);\r\n        }\r\n    }\r\n\r\n    createExplosion(x: number, y: number) {\r\n        // Redirect to sequence system\r\n        this.playSequence('EXPLOSION_GENERIC', x, y);\r\n    }\r\n\r\n    getActiveCount(): number {\r\n        let count = 0;\r\n        if (this.fgParticles?.particles) count += this.fgParticles.particles.length;\r\n        if (this.bgParticles?.particles) count += this.bgParticles.particles.length;\r\n        count += this.texts.length;\r\n        count += this.activeSequences.length;\r\n        return count;\r\n    }\r\n\r\n    triggerUIProgressSparks(x: number, y: number, _config: ParticleOptions = {}) {\r\n        this.playForeground(x, y, {\r\n            type: 'spark',\r\n            color: '#FFD700',\r\n            count: 8,\r\n            speed: 5,\r\n            lifetime: 500,\r\n            size: 3\r\n        });\r\n    }\r\n\r\n    get presets() {\r\n        return VFXConfig?.TEMPLATES || {};\r\n    }\r\n}\r\n\r\n// Export Singleton\r\nconst VFXController = new VFXSystem();\r\n\r\n// Register at module load time\r\nRegistry.register('VFXController', VFXController);\r\n\r\nexport { VFXSystem, VFXController };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\vfx\\weather\\RainVFX.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'vx_frame' is assigned a value but never used.","line":87,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":87,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'vy_frame' is assigned a value but never used.","line":88,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":88,"endColumn":27}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * RainVFX - Modular Weather Effect\r\n * Handles high-velocity falling lines with screen wrapping.\r\n * Simulates world-space persistence by shifting particles opposite to camera movement.\r\n */\r\nimport { MathUtils } from '@core/MathUtils';\r\n\r\ninterface RainParticle {\r\n    x: number;\r\n    y: number;\r\n    len: number;\r\n    speed: number;\r\n    alpha: number;\r\n    renderDx?: number;\r\n    renderDy?: number;\r\n}\r\n\r\nclass RainVFX {\r\n    active: boolean;\r\n    particles: RainParticle[];\r\n    count: number;\r\n    speedBase: number;\r\n    angle: number;\r\n    isStorm: boolean = false;\r\n\r\n    constructor() {\r\n        this.active = false;\r\n        this.particles = [];\r\n        this.count = 150; // Max raindrops\r\n        this.speedBase = 15;\r\n        this.angle = 0.2; // Radians lean (right)\r\n    }\r\n\r\n    init() {\r\n        // Pool instantiation\r\n        for (let i = 0; i < this.count; i++) {\r\n            this.particles.push({\r\n                x: Math.random() * innerWidth,\r\n                y: Math.random() * innerHeight,\r\n                len: 10 + Math.random() * 15,\r\n                speed: this.speedBase + Math.random() * 5,\r\n                alpha: 0.3 + Math.random() * 0.3\r\n            });\r\n        }\r\n    }\r\n\r\n    update(dt: number, delta: { x: number; y: number } | null, viewport: { width: number; height: number } | null, wind: { currentX: number } | null, isStorm: boolean) {\r\n        if (!this.active) return;\r\n\r\n        this.isStorm = isStorm;\r\n\r\n        // Visual Scale\r\n        const lenScale = isStorm ? 2.5 : 1.0; // Increased to 2.5x for impact\r\n\r\n        // Assume 60fps baseline for simple physics\r\n        const timeScale = dt / 16.666;\r\n\r\n        // Use viewport dimensions if available, else fallback\r\n        const width = viewport ? viewport.width : innerWidth;\r\n        const height = viewport ? viewport.height : innerHeight;\r\n\r\n        // If viewport is missing, we can't do world space shift, default to 0\r\n        const dx = delta ? delta.x : 0;\r\n        const dy = delta ? delta.y : 0;\r\n\r\n        // Wind Velocity (pixels/sec)\r\n        const windSpeed = wind ? wind.currentX : 0;\r\n\r\n        // Update Angle based on wind?\r\n        // Base angle 0.2 rad (~11 deg).\r\n        // 100 wind -> +0.5 rad?\r\n        if (wind) {\r\n            this.angle = 0.2 + wind.currentX / 300; // 300 force = +1 rad (~57 deg)\r\n        }\r\n\r\n        for (const p of this.particles) {\r\n            // 1. Apply Camera Move (Shift opposite to camera to stay in world)\r\n            p.x -= dx;\r\n            p.y -= dy;\r\n\r\n            // 2. Move (Falling)\r\n            // Calculate Velocity Components (per second approx for direction)\r\n            const vX_sec = p.speed * 0.2 + windSpeed;\r\n            const vY_sec = p.speed;\r\n\r\n            // Frame Delta\r\n            const vx_frame = vX_sec * (dt / 1000); // or use timeScale logic: p.speed * timeScale is pixels/frame\r\n            const vy_frame = vY_sec * (dt / 1000); //\r\n\r\n            // Consistent Physics Update (using timeScale logic for consistency with original tuning)\r\n            // Original: p.y += p.speed * timeScale;\r\n            // timeScale = dt / 16.666\r\n            // So p.speed is pixels per ~16ms? No, p.speed is pixels/frame at 60fps.\r\n            // Let's stick to modifying p.x/p.y as before, but calculating angle from that.\r\n\r\n            const moveY = p.speed * timeScale;\r\n            const moveX = p.speed * 0.2 * timeScale + windSpeed * (dt / 1000);\r\n\r\n            p.x += moveX;\r\n            p.y += moveY;\r\n\r\n            // 3. Update Visual Vector (Align streak with velocity)\r\n            // Normalize velocity vector\r\n            const mag = MathUtils.distance(0, 0, moveX, moveY);\r\n            // Effective visual length based on storm state\r\n            const effectiveLen = p.len * lenScale;\r\n\r\n            if (mag > 0.001) {\r\n                // Point tail backwards\r\n                p.renderDx = (moveX / mag) * effectiveLen;\r\n                p.renderDy = (moveY / mag) * effectiveLen;\r\n            } else {\r\n                p.renderDx = 0;\r\n                p.renderDy = effectiveLen;\r\n            }\r\n\r\n            // 4. Wrapping\r\n            // If particle goes off-screen, wrap it to the other side\r\n            // Ideally we want to wrap around the *viewport bounds*\r\n            // Since we are rendering in \"Screen Space\" relative to camera (0,0 is top-left of screen),\r\n            // The particles are effectively in screen coords.\r\n            // Wait, if p.x -= dx, p.x is effectively WorldX - CameraX.\r\n            // So p.x IS screen coordinate.\r\n            // So we just wrap 0..width.\r\n\r\n            if (p.y > height) {\r\n                p.y = -p.len;\r\n                p.x = Math.random() * width;\r\n            }\r\n            if (p.y < -p.len - 100) {\r\n                // If camera moves UP fast (dy negative -> p.y increases. If dy positive (cam down) -> p.y decreases)\r\n                // If p.y becomes too negative (cam moved down past it)\r\n                p.y = height + p.len;\r\n                p.x = Math.random() * width;\r\n            }\r\n\r\n            if (p.x > width) {\r\n                p.x = -10;\r\n            } else if (p.x < -10) {\r\n                p.x = width;\r\n            }\r\n        }\r\n    }\r\n\r\n    render(ctx: CanvasRenderingContext2D) {\r\n        if (!this.active) return;\r\n\r\n        ctx.strokeStyle = 'rgba(174, 194, 224, 0.6)'; // Blue-ish white\r\n        ctx.lineWidth = this.isStorm ? 2 : 1;\r\n        ctx.beginPath();\r\n\r\n        for (const p of this.particles) {\r\n            ctx.moveTo(p.x, p.y);\r\n            // Draw Trail (Backwards from head)\r\n            // p.x, p.y is the head (bottom)\r\n            ctx.lineTo(p.x - (p.renderDx || 0), p.y - (p.renderDy || p.len));\r\n        }\r\n\r\n        ctx.stroke();\r\n    }\r\n}\r\n\r\n// ES6 Module Export\r\nexport { RainVFX };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\vfx\\weather\\SnowVFX.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\vite-env.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\workers\\GroundRenderWorker.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'height' is assigned a value but never used.","line":8,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'config' is assigned a value but never used.","line":15,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'hw' is assigned a value but never used.","line":45,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":45,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'nw' is assigned a value but never used.","line":46,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":46,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'clamp' is defined but never used.","line":166,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":166,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// GroundRenderWorker.ts\r\n// Handles CPU intense pixel manipulation for ground blending\r\n\r\nself.onmessage = async (e: MessageEvent) => {\r\n    const {\r\n        jobId,\r\n        width,\r\n        height,\r\n        splatWeights,\r\n        baseBuffer,\r\n        midBuffer,\r\n        overlayBuffer,\r\n        heightBuffer,\r\n        noiseBuffer,\r\n        config,\r\n        baseWidth,\r\n        midWidth,\r\n        overlayWidth,\r\n        heightWidth,\r\n        noiseWidth,\r\n        tileSize\r\n    } = e.data;\r\n\r\n    try {\r\n        const TILE_SIZE = tileSize || 128;\r\n        const totalPixels = TILE_SIZE * TILE_SIZE;\r\n        const outBuffer = new ArrayBuffer(totalPixels * 4);\r\n        const out32 = new Uint32Array(outBuffer);\r\n\r\n        const base32 = new Uint32Array(baseBuffer);\r\n        const mid32 = new Uint32Array(midBuffer);\r\n        const overlay32 = new Uint32Array(overlayBuffer);\r\n        const h32 = new Uint32Array(heightBuffer);\r\n        const n32 = new Uint32Array(noiseBuffer);\r\n\r\n        const calcDim = (buf: Uint32Array, passed: number | undefined) => {\r\n            if (passed && passed > 64) return passed;\r\n            if (buf.length > 1024) return Math.floor(Math.sqrt(buf.length));\r\n            return 128;\r\n        };\r\n\r\n        const bw = calcDim(base32, baseWidth || width);\r\n        const mw = calcDim(mid32, midWidth || width);\r\n        const ow = calcDim(overlay32, overlayWidth || width);\r\n        const hw = calcDim(h32, heightWidth || width);\r\n        const nw = calcDim(n32, noiseWidth || width);\r\n\r\n        const mh = mw;\r\n        const oh = ow;\r\n\r\n        const weightData =\r\n            typeof splatWeights === 'number'\r\n                ? null\r\n                : upscaleWeights(splatWeights, TILE_SIZE, TILE_SIZE);\r\n\r\n        for (let y = 0; y < TILE_SIZE; y++) {\r\n            for (let x = 0; x < TILE_SIZE; x++) {\r\n                const outIdx = y * TILE_SIZE + x;\r\n\r\n                const srcX_Base = Math.floor((x / TILE_SIZE) * bw);\r\n                const srcY_Base = Math.floor((y / TILE_SIZE) * bw);\r\n                const baseIdx = srcY_Base * bw + srcX_Base;\r\n\r\n                const srcX_Mid = Math.floor((x / TILE_SIZE) * mw);\r\n                const srcY_Mid = Math.floor((y / TILE_SIZE) * mh);\r\n                const midIdx = srcY_Mid * mw + srcX_Mid;\r\n\r\n                const srcX_Overlay = Math.floor((x / TILE_SIZE) * ow);\r\n                const srcY_Overlay = Math.floor((y / TILE_SIZE) * oh);\r\n                const overlayIdx = srcY_Overlay * ow + srcX_Overlay;\r\n\r\n                let normWeight = 0;\r\n                if (typeof splatWeights === 'number') {\r\n                    normWeight = splatWeights / 255.0;\r\n                } else if (weightData) {\r\n                    normWeight = weightData[outIdx] / 255.0;\r\n                }\r\n\r\n                if (normWeight <= 0.01) {\r\n                    out32[outIdx] = base32[baseIdx];\r\n                    continue;\r\n                }\r\n                if (normWeight >= 0.99) {\r\n                    out32[outIdx] = overlay32[overlayIdx];\r\n                    continue;\r\n                }\r\n\r\n                // 3-layer blend: weight 00.5 lerp basemid, 0.51.0 lerp midoverlay (weight alone drives visual)\r\n                let blendVal: number;\r\n                if (normWeight < 0.5) {\r\n                    const t = normWeight * 2;\r\n                    blendVal = lerp32(base32[baseIdx], mid32[midIdx], t);\r\n                } else {\r\n                    const t = (normWeight - 0.5) * 2;\r\n                    blendVal = lerp32(mid32[midIdx], overlay32[overlayIdx], t);\r\n                }\r\n                out32[outIdx] =\r\n                    (255 << 24) |\r\n                    (((blendVal >> 16) & 0xff) << 16) |\r\n                    (((blendVal >> 8) & 0xff) << 8) |\r\n                    (blendVal & 0xff);\r\n            }\r\n        }\r\n\r\n        self.postMessage({ jobId, success: true, buffer: outBuffer }, [outBuffer]);\r\n    } catch (err: unknown) {\r\n        self.postMessage({ jobId, success: false, error: (err as Error).message });\r\n    }\r\n};\r\n\r\nfunction lerp32(a: number, b: number, t: number): number {\r\n    const aR = a & 0xff,\r\n        aG = (a >> 8) & 0xff,\r\n        aB = (a >> 16) & 0xff;\r\n    const bR = b & 0xff,\r\n        bG = (b >> 8) & 0xff,\r\n        bB = (b >> 16) & 0xff;\r\n    const r = (aR + (bR - aR) * t) | 0;\r\n    const g = (aG + (bG - aG) * t) | 0;\r\n    const bl = (aB + (bB - aB) * t) | 0;\r\n    return (255 << 24) | (bl << 16) | (g << 8) | r;\r\n}\r\n\r\nfunction upscaleWeights(\r\n    weights: Uint8ClampedArray,\r\n    width: number,\r\n    height: number\r\n): Uint8ClampedArray {\r\n    // Bilinear interpolation from 6x6 grid (positions -1..4) to WxH for symmetric tile-edge blending\r\n    const out = new Uint8ClampedArray(width * height);\r\n\r\n    for (let y = 0; y < height; y++) {\r\n        for (let x = 0; x < width; x++) {\r\n            // Map pixel (0,0) -> grid -1, pixel (width, height) -> grid 4\r\n            const u = -1 + (x / width) * 5;\r\n            const v = -1 + (y / height) * 5;\r\n\r\n            const px0 = Math.floor(u);\r\n            const px1 = Math.min(4, px0 + 1);\r\n            const py0 = Math.floor(v);\r\n            const py1 = Math.min(4, py0 + 1);\r\n\r\n            const ix0 = Math.max(0, Math.min(5, px0 + 1));\r\n            const ix1 = Math.max(0, Math.min(5, px1 + 1));\r\n            const iy0 = Math.max(0, Math.min(5, py0 + 1));\r\n            const iy1 = Math.max(0, Math.min(5, py1 + 1));\r\n\r\n            const uRatio = u - px0;\r\n            const vRatio = v - py0;\r\n\r\n            const w00 = weights[iy0 * 6 + ix0];\r\n            const w10 = weights[iy0 * 6 + ix1];\r\n            const w01 = weights[iy1 * 6 + ix0];\r\n            const w11 = weights[iy1 * 6 + ix1];\r\n\r\n            const wTop = w00 + (w10 - w00) * uRatio;\r\n            const wBot = w01 + (w11 - w01) * uRatio;\r\n            const w = wTop + (wBot - wTop) * vRatio;\r\n\r\n            out[y * width + x] = w;\r\n        }\r\n    }\r\n    return out;\r\n}\r\n\r\nfunction clamp(value: number, min: number, max: number): number {\r\n    return Math.max(min, Math.min(max, value));\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\workers\\MapgenWorker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\world\\AmbientSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\world\\BiomeManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'BiomeDef' is defined but never used.","line":14,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":18,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"BiomeDef"},"fix":{"range":[459,468],"text":""},"desc":"Remove unused variable \"BiomeDef\"."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * BiomeManager - Handles world biome boundaries, detection, and roads\r\n *\r\n * World Size: 30,000 x 30,000 pixels\r\n * Biomes: Badlands (N), Grasslands (W), Ironhaven (C), Tundra (E), Desert (SW)\r\n *\r\n * Uses polygon boundaries for natural-looking biome shapes.\r\n */\r\n\r\nimport { Logger } from '@core/Logger';\r\nimport { RoadsData } from '@data/RoadsData';\r\nimport { Registry } from '@core/Registry';\r\nimport { MathUtils } from '@core/MathUtils';\r\nimport { BiomeDef, RoadDef } from '../types/world';\r\nimport { BIOME_POLYGONS } from './BiomePolygons';\r\n\r\nconst BiomeManager = {\r\n    BIOME_IDS: {\r\n        OCEAN: 'ocean',\r\n        IRONHAVEN: 'ironhaven',\r\n        GRASSLANDS: 'grasslands',\r\n        DESERT: 'desert',\r\n        BADLANDS: 'badlands',\r\n        TUNDRA: 'tundra'\r\n    },\r\n\r\n    BIOMES: BIOME_POLYGONS,\r\n\r\n    // Roads data now loaded from RoadsData.js\r\n    get ROADS(): RoadDef[] {\r\n        return (RoadsData?.ROADS || []) as RoadDef[];\r\n    },\r\n\r\n    ROAD_SPEED_MULTIPLIER: 1.3,\r\n    WORLD_WIDTH: 30000,\r\n    WORLD_HEIGHT: 30000,\r\n    IRONHAVEN_OFFSET: { x: 10000, y: 10000 },\r\n\r\n    init() {\r\n        Logger.info(\r\n            '[BiomeManager] Initialized - World size:',\r\n            this.WORLD_WIDTH,\r\n            'x',\r\n            this.WORLD_HEIGHT\r\n        );\r\n        Logger.info('[BiomeManager] Biomes:', Object.keys(this.BIOMES).join(', '));\r\n    },\r\n\r\n    /**\r\n     * Get the biome at a given world position using polygon hit test\r\n     */\r\n    getBiomeAt(x: number, y: number) {\r\n        // Check each biome's polygon (order matters - Ironhaven checked first for priority)\r\n        const priority = ['ironhaven', 'grasslands', 'tundra', 'badlands', 'desert'];\r\n        for (const biomeId of priority) {\r\n            const biome = this.BIOMES[biomeId];\r\n            if (biome.polygon && this.pointInPolygon(x, y, biome.polygon)) {\r\n                return biome;\r\n            }\r\n        }\r\n        return null; // Ocean\r\n    },\r\n\r\n    /**\r\n     * Point-in-polygon test using ray casting algorithm\r\n     */\r\n    pointInPolygon(x: number, y: number, polygon: { x: number; y: number }[]) {\r\n        let inside = false;\r\n        const n = polygon.length;\r\n\r\n        for (let i = 0, j = n - 1; i < n; j = i++) {\r\n            const xi = polygon[i].x,\r\n                yi = polygon[i].y;\r\n            const xj = polygon[j].x,\r\n                yj = polygon[j].y;\r\n\r\n            if (yi > y !== yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi) {\r\n                inside = !inside;\r\n            }\r\n        }\r\n        return inside;\r\n    },\r\n\r\n    getBiomeIdAt(x: number, y: number) {\r\n        const biome = this.getBiomeAt(x, y);\r\n        return biome ? biome.id : this.BIOME_IDS.OCEAN;\r\n    },\r\n\r\n    isOnRoad(x: number, y: number) {\r\n        for (const road of this.ROADS) {\r\n            if (this.pointToSplineDistance(x, y, road) <= road.width / 2) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    },\r\n\r\n    getSpeedMultiplier(x: number, y: number) {\r\n        return this.isOnRoad(x, y) ? this.ROAD_SPEED_MULTIPLIER : 1.0;\r\n    },\r\n\r\n    pointToLineDistance(px: number, py: number, from: { x: number; y: number }, to: { x: number; y: number }) {\r\n        const dx = to.x - from.x;\r\n        const dy = to.y - from.y;\r\n        const lengthSq = dx * dx + dy * dy;\r\n\r\n        if (lengthSq === 0) {\r\n            return MathUtils.distance(px, py, from.x, from.y);\r\n        }\r\n\r\n        let t = ((px - from.x) * dx + (py - from.y) * dy) / lengthSq;\r\n        // t = Math.max(0, Math.min(1, t));\r\n        t = MathUtils.clamp(t, 0, 1);\r\n\r\n        const projX = from.x + t * dx;\r\n        const projY = from.y + t * dy;\r\n\r\n        return MathUtils.distance(px, py, projX, projY);\r\n    },\r\n\r\n    evaluateBezierTangent(t: number, points: { x: number; y: number }[]) {\r\n        const [p0, p1, p2, p3] = points;\r\n        const mt = 1 - t;\r\n        const mt2 = mt * mt;\r\n        const t2 = t * t;\r\n\r\n        // First derivative of cubic Bezier\r\n        const dx = 3 * mt2 * (p1.x - p0.x) + 6 * mt * t * (p2.x - p1.x) + 3 * t2 * (p3.x - p2.x);\r\n        const dy = 3 * mt2 * (p1.y - p0.y) + 6 * mt * t * (p2.y - p1.y) + 3 * t2 * (p3.y - p2.y);\r\n        const len = Math.sqrt(dx * dx + dy * dy) || 1; // Keeping Math.sqrt here for vector normalization as MathUtils doesn't have normalize yet\r\n\r\n        return { x: dx / len, y: dy / len };\r\n    },\r\n\r\n    isValidPosition(x: number, y: number) {\r\n        return this.getBiomeAt(x, y) !== null;\r\n    },\r\n\r\n    ironhavenToWorld(localX: number, localY: number) {\r\n        return {\r\n            x: localX + this.IRONHAVEN_OFFSET.x,\r\n            y: localY + this.IRONHAVEN_OFFSET.y\r\n        };\r\n    },\r\n\r\n    worldToIronhaven(worldX: number, worldY: number) {\r\n        return {\r\n            x: worldX - this.IRONHAVEN_OFFSET.x,\r\n            y: worldY - this.IRONHAVEN_OFFSET.y\r\n        };\r\n    },\r\n\r\n    getRoads() {\r\n        return this.ROADS;\r\n    },\r\n\r\n    /**\r\n     * Get polygon points for a biome (for rendering)\r\n     */\r\n    getBiomePolygon(biomeId: string) {\r\n        return this.BIOMES[biomeId]?.polygon || [];\r\n    },\r\n\r\n    // ==================== SPLINE MATH ====================\r\n\r\n    /**\r\n     * Evaluate cubic Bezier curve at parameter t (0-1)\r\n     * @param {number} t - Parameter (0 = start, 1 = end)\r\n     * @param {Array} points - Array of 4 control points [{x, y}, ...]\r\n     * @returns {{x: number, y: number}}\r\n     */\r\n    evaluateBezier(t: number, points: { x: number; y: number }[]) {\r\n        const [p0, p1, p2, p3] = points;\r\n        const mt = 1 - t;\r\n        const mt2 = mt * mt;\r\n        const mt3 = mt2 * mt;\r\n        const t2 = t * t;\r\n        const t3 = t2 * t;\r\n\r\n        return {\r\n            x: mt3 * p0.x + 3 * mt2 * t * p1.x + 3 * mt * t2 * p2.x + t3 * p3.x,\r\n            y: mt3 * p0.y + 3 * mt2 * t * p1.y + 3 * mt * t2 * p2.y + t3 * p3.y\r\n        };\r\n    },\r\n\r\n    /**\r\n     * Get tangent vector at parameter t on Bezier curve\r\n     */\r\n\r\n    /**\r\n     * Sample N points along a spline road\r\n     * @param {object} road - Road with .points array\r\n     * @param {number} segments - Number of segments to sample\r\n     * @returns {Array} Array of {x, y, angle} objects\r\n     */\r\n    getSplinePoints(road: RoadDef, segments = 20) {\r\n        const result = [];\r\n        for (let i = 0; i <= segments; i++) {\r\n            const t = i / segments;\r\n            const pos = this.evaluateBezier(t, road.points);\r\n            const tangent = this.evaluateBezierTangent(t, road.points);\r\n            const angle = Math.atan2(tangent.y, tangent.x);\r\n            result.push({ x: pos.x, y: pos.y, angle, t });\r\n        }\r\n        return result;\r\n    },\r\n\r\n    /**\r\n     * Calculate minimum distance from point to spline road\r\n     * Uses sampling approach for performance\r\n     */\r\n    pointToSplineDistance(px: number, py: number, road: RoadDef) {\r\n        const samples = 32; // Higher = more accurate but slower\r\n        let minDistSq = Infinity;\r\n\r\n        for (let i = 0; i <= samples; i++) {\r\n            const t = i / samples;\r\n            const pos = this.evaluateBezier(t, road.points);\r\n            const dx = px - pos.x;\r\n            const dy = py - pos.y;\r\n            const distSq = dx * dx + dy * dy;\r\n            if (distSq < minDistSq) {\r\n                minDistSq = distSq;\r\n            }\r\n        }\r\n\r\n        return Math.sqrt(minDistSq);\r\n    },\r\n\r\n    /**\r\n     * Get approximate length of a spline road\r\n     */\r\n    getSplineLength(road: RoadDef) {\r\n        const samples = 20;\r\n        let length = 0;\r\n        let prevPos = this.evaluateBezier(0, road.points);\r\n\r\n        for (let i = 1; i <= samples; i++) {\r\n            const t = i / samples;\r\n            const pos = this.evaluateBezier(t, road.points);\r\n            length += Math.sqrt((pos.x - prevPos.x) ** 2 + (pos.y - prevPos.y) ** 2);\r\n            prevPos = pos;\r\n        }\r\n\r\n        return length;\r\n    },\r\n\r\n    getDebugInfo(x: number, y: number) {\r\n        const biome = this.getBiomeAt(x, y);\r\n        const onRoad = this.isOnRoad(x, y);\r\n        const biomeName = biome ? biome.name : 'Ocean';\r\n        return `Biome: ${biomeName}${onRoad ? ' [ROAD +30%]' : ''}`;\r\n    }\r\n};\r\n\r\nif (Registry) Registry.register('BiomeManager', BiomeManager);\r\n\r\nexport { BiomeManager };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\world\\BiomePolygons.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\world\\HomeBase.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'dt' is defined but never used. Allowed unused args must match /^_/u.","line":133,"column":12,"nodeType":"Identifier","messageId":"unusedVar","endLine":133,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_' is assigned a value but never used.","line":222,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":222,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * HomeBase - Player's starting home island with harvestable trees\r\n *\r\n * Creates collectible wood resources around the home island perimeter.\r\n * Trees are actual Resource entities that can be gathered.\r\n *\r\n * Owner: Level Architect\r\n */\r\n\r\nimport { Logger } from '@core/Logger';\r\nimport { GameRenderer } from '@core/GameRenderer';\r\nimport { GameConstants } from '@data/GameConstants';\r\nimport { getConfig } from '@data/GameConfig';\r\nimport { WorldManager } from './WorldManager';\r\nimport { AssetLoader } from '@core/AssetLoader';\r\nimport { entityManager } from '@core/EntityManager';\r\nimport { EventBus } from '@core/EventBus';\r\nimport { Registry } from '@core/Registry';\r\nimport { renderHomeBase } from './HomeBaseRenderer';\r\nimport type { Bounds } from '../types/world';\r\nimport type { IEntity } from '../types/core';\r\n\r\n// entityManager instance is imported, but we also need the EntityManager reference for static access\r\nconst EntityManager = entityManager;\r\n\r\nconst HomeBase = {\r\n    treeBorderWidth: 100,\r\n\r\n    // Private cache properties\r\n    _cachedBounds: null as Bounds | null,\r\n    _treeCacheFrame: 0,\r\n    _cachedTrees: [] as IEntity[],\r\n    _sortedTrees: [] as IEntity[],\r\n    _heroAtHome: false,\r\n    _heroAtForge: false,\r\n    _forgePos: null as { x: number; y: number; size: number } | null,\r\n\r\n    // Image Paths\r\n    _outpostPath: null as string | null,\r\n    _forgePath: null as string | null,\r\n    _treePath: null as string | null,\r\n    _treeConsumedPath: null as string | null,\r\n\r\n    // Image Elements\r\n    _outpostImg: null as HTMLImageElement | null,\r\n    _forgeImg: null as HTMLImageElement | null,\r\n    _treeImage: null as HTMLImageElement | null,\r\n    _treeConsumedImage: null as HTMLImageElement | null,\r\n\r\n    // Loading State\r\n    _treeLoaded: false,\r\n    _treeConsumedLoaded: false,\r\n\r\n    // Debug\r\n    _debugSpawnZone: null as {\r\n        minX: number;\r\n        minY: number;\r\n        maxX: number;\r\n        maxY: number;\r\n        centerX: number;\r\n        centerY: number;\r\n        restAreaRadius: number;\r\n    } | null,\r\n\r\n    /**\r\n     * Get tree resources from EntityManager (cached per frame)\r\n     * @returns {Array} Array of wood Resource entities on home island\r\n     */\r\n    get treeResources() {\r\n        // Return cached if same frame\r\n        const renderer = GameRenderer as unknown as { _renderTiming?: { frames: number } };\r\n        const frame = renderer?._renderTiming?.frames || 0;\r\n        if (this._treeCacheFrame === frame && this._cachedTrees) {\r\n            return this._cachedTrees;\r\n        }\r\n\r\n        if (!EntityManager || !this._cachedBounds) return [];\r\n\r\n        // Query and cache\r\n        const bounds = this._cachedBounds;\r\n        this._cachedTrees = EntityManager.getByType('Resource').filter(\r\n            (r) =>\r\n                r.resourceType.startsWith('node_woodcutting_') &&\r\n                r.x >= bounds.x && r.x <= bounds.x + bounds.width &&\r\n                r.y >= bounds.y && r.y <= bounds.y + bounds.height\r\n        );\r\n        this._treeCacheFrame = frame;\r\n\r\n        // Pre-sort trees (they don't move)\r\n        this._sortedTrees = [...this._cachedTrees].sort((a, b) => a.y - b.y);\r\n\r\n        return this._cachedTrees;\r\n    },\r\n\r\n    /**\r\n     * Initialize the home base (trees now spawned via SpawnManager)\r\n     */\r\n    init() {\r\n        if (!WorldManager) {\r\n            Logger.error('[HomeBase]', 'WorldManager not found');\r\n            return;\r\n        }\r\n\r\n        const spawn = WorldManager.getHeroSpawnPosition();\r\n        if (!spawn) {\r\n            Logger.error('[HomeBase]', 'Hero spawn not found');\r\n            return;\r\n        }\r\n\r\n        // PERF: Cache bounds around spawn point\r\n        const size = 2000;\r\n        this._cachedBounds = {\r\n            x: spawn.x - size / 2,\r\n            y: spawn.y - size / 2,\r\n            width: size,\r\n            height: size\r\n        };\r\n\r\n        // PERF: Cache image paths at init\r\n        if (AssetLoader) {\r\n            this._outpostPath = AssetLoader.getImagePath('building_residential_01');\r\n            this._forgePath = AssetLoader.getImagePath('building_industrial_01');\r\n            this._treePath = AssetLoader.getImagePath('node_woodcutting_t1_01');\r\n            this._treeConsumedPath = AssetLoader.getImagePath('node_woodcutting_t1_01_consumed');\r\n        }\r\n\r\n        // Trees are now spawned by SpawnManager.spawnHomeIslandTrees()\r\n        Logger.info('[HomeBase]', 'Initialized (trees spawned via SpawnManager)');\r\n\r\n        // Forge Button binding removed - CraftingUI not implemented\r\n    },\r\n\r\n    update(dt: number) {\r\n        if (!GameRenderer || !GameRenderer.hero) return;\r\n\r\n        const hero = GameRenderer.hero;\r\n        const bounds = this._cachedBounds;\r\n\r\n        // === Home Base / Rest Area Detection ===\r\n        // Rest zones: (1) home island center (legacy), (2) placed outpost props from map editor\r\n        const restRadius = getConfig().Interaction.REST_AREA_RADIUS;\r\n        const REST_ZONE_IDS = new Set(['building_t1_02', 'building_residential_01']);\r\n\r\n        let isAtHome = false;\r\n        if (bounds) {\r\n            const centerX = bounds.x + bounds.width / 2;\r\n            const centerY = bounds.y + bounds.height / 2;\r\n            const dx = hero.x - centerX;\r\n            const dy = hero.y - centerY;\r\n            const dist = Math.sqrt(dx * dx + dy * dy);\r\n            isAtHome = dist < restRadius;\r\n        }\r\n        if (!isAtHome && EntityManager) {\r\n            const props = EntityManager.getByType('Prop') as Array<{ x: number; y: number; registryId?: string | null }>;\r\n            for (const prop of props) {\r\n                if (prop.registryId && REST_ZONE_IDS.has(prop.registryId)) {\r\n                    const dx = hero.x - prop.x;\r\n                    const dy = hero.y - prop.y;\r\n                    if (Math.sqrt(dx * dx + dy * dy) < restRadius) {\r\n                        isAtHome = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        const wasAtHome = this._heroAtHome || false;\r\n        hero.isAtHomeOutpost = isAtHome;\r\n\r\n        if (isAtHome && !wasAtHome) {\r\n            if (EventBus) EventBus.emit(GameConstants.Events.HOME_BASE_ENTERED);\r\n            Logger.debug('[HomeBase]', 'Hero entered rest area');\r\n        } else if (!isAtHome && wasAtHome) {\r\n            if (EventBus) EventBus.emit(GameConstants.Events.HOME_BASE_EXITED);\r\n            Logger.debug('[HomeBase]', 'Hero exited rest area');\r\n        }\r\n        this._heroAtHome = isAtHome;\r\n\r\n        // === Forge Proximity Detection ===\r\n        if (this._forgePos) {\r\n            const dx = hero.x - this._forgePos.x;\r\n            const dy = hero.y - this._forgePos.y;\r\n            const dist = Math.sqrt(dx * dx + dy * dy);\r\n\r\n            const wasAtForge = this._heroAtForge || false;\r\n            const isAtForge = dist < getConfig().Interaction.FORGE_AREA_RADIUS;\r\n\r\n            if (isAtForge && !wasAtForge) {\r\n                if (EventBus) EventBus.emit(GameConstants.Events.FORGE_ENTERED);\r\n                Logger.debug('[HomeBase]', 'Hero entered forge area');\r\n            } else if (!isAtForge && wasAtForge) {\r\n                if (EventBus) EventBus.emit(GameConstants.Events.FORGE_EXITED);\r\n                Logger.debug('[HomeBase]', 'Hero exited forge area');\r\n            }\r\n\r\n            this._heroAtForge = isAtForge;\r\n        }\r\n    },\r\n\r\n    // NOTE: Tree spawning moved to SpawnManager.spawnHomeIslandTrees()\r\n    // Trees are now queried via the treeResources getter from EntityManager\r\n\r\n    render(ctx: CanvasRenderingContext2D) {\r\n        if (!this._cachedBounds && WorldManager) {\r\n            const spawn = WorldManager.getHeroSpawnPosition();\r\n            if (spawn) {\r\n                const size = 2000;\r\n                this._cachedBounds = {\r\n                    x: spawn.x - size / 2,\r\n                    y: spawn.y - size / 2,\r\n                    width: size,\r\n                    height: size\r\n                };\r\n                if (AssetLoader) {\r\n                    this._outpostPath = AssetLoader.getImagePath('building_residential_01');\r\n                    this._forgePath = AssetLoader.getImagePath('building_industrial_01');\r\n                    this._treePath = AssetLoader.getImagePath('node_woodcutting_t1_01');\r\n                    this._treeConsumedPath = AssetLoader.getImagePath('node_woodcutting_t1_01_consumed');\r\n                }\r\n            }\r\n        }\r\n        const _ = this.treeResources;\r\n        renderHomeBase(ctx, this as unknown as import('./HomeBaseRenderer').HomeBaseRenderState);\r\n    },\r\n\r\n    /**\r\n     * Get the safe spawn area (center of home island, away from trees)\r\n     * @returns {{x: number, y: number, width: number, height: number}}\r\n     */\r\n    getSafeArea() {\r\n        if (!this._cachedBounds) return null;\r\n\r\n        const b = this._cachedBounds;\r\n        const border = this.treeBorderWidth;\r\n        return {\r\n            x: b.x + border,\r\n            y: b.y + border,\r\n            width: b.width - border * 2,\r\n            height: b.height - border * 2\r\n        };\r\n    },\r\n\r\n    /**\r\n     * Check if blocking by trees - now always returns false (trees don't block)\r\n     * @returns {boolean}\r\n     */\r\n    isBlockedByTrees(_x: number, _y: number) {\r\n        return false; // Trees are resources, not barriers\r\n    }\r\n};\r\n\r\nif (Registry) Registry.register('HomeBase', HomeBase);\r\n\r\nexport { HomeBase };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\world\\HomeBaseRenderer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\world\\IslandManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\world\\MapDataService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\world\\MapObjectSpawner.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'HeroSpawnPosition' is defined but never used.","line":18,"column":26,"nodeType":"Identifier","messageId":"unusedVar","endLine":18,"endColumn":43,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"HeroSpawnPosition"},"fix":{"range":[866,885],"text":""},"desc":"Remove unused variable \"HeroSpawnPosition\"."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * MapObjectSpawner - Spawns entities from map editor data\r\n *\r\n * Listens to BroadcastChannel 'game-map-updates' for real-time sync.\r\n * Fetches initial map on init when running with dashboard.\r\n */\r\nimport { Logger } from '@core/Logger';\r\nimport { entityManager } from '@core/EntityManager';\r\nimport { EntityRegistry } from '@entities/EntityLoader';\r\nimport { Prop } from './Prop';\r\nimport { Resource } from '../gameplay/Resource';\r\nimport { Enemy } from '../gameplay/EnemyCore';\r\nimport { Boss } from '../gameplay/Boss';\r\nimport { Registry } from '@core/Registry';\r\nimport { fetchMapData, getObjectsFromMapData, getPrefetchedMapData, clearPrefetchedMapData } from './MapDataService';\r\nimport type { MapData } from './MapDataService';\r\nimport type { Mapgen4Param, ManualTownsAndRailroads } from '../tools/map-editor/Mapgen4Generator';\r\nimport type { MapObject, HeroSpawnPosition } from '../tools/map-editor/MapEditorTypes';\r\nimport type { IEntity } from '../types/core';\r\n\r\nconst CHANNEL_NAME = 'game-map-updates';\r\nconst POS_TOLERANCE = 2;\r\n\r\nfunction makeKey(x: number, y: number): string {\r\n    return `${Math.round(x)},${Math.round(y)}`;\r\n}\r\n\r\nfunction findEntityAt(\r\n    map: Map<string, IEntity>,\r\n    x: number,\r\n    y: number,\r\n    id?: string\r\n): { entity: IEntity; key: string } | null {\r\n    const roundX = Math.round(x);\r\n    const roundY = Math.round(y);\r\n    for (const [key, entity] of map) {\r\n        const [kx, ky] = key.split(',').map(Number);\r\n        if (Math.abs(kx - roundX) <= POS_TOLERANCE && Math.abs(ky - roundY) <= POS_TOLERANCE) {\r\n            if (!id || (entity as { resourceType?: string; registryId?: string }).resourceType === id || (entity as { registryId?: string }).registryId === id) {\r\n                return { entity, key };\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\nfunction spawnEntityForMapObject(obj: MapObject): IEntity | null {\r\n    const { id, x, y } = obj;\r\n\r\n    if (EntityRegistry.environment?.[id]) {\r\n        const prop = new Prop({ x, y, registryId: id });\r\n        entityManager.add(prop);\r\n        return prop;\r\n    }\r\n\r\n    if (EntityRegistry.nodes?.[id] || EntityRegistry.resources?.[id]) {\r\n        const resource = new Resource({ x, y, resourceType: id, isMapPlaced: true });\r\n        entityManager.add(resource);\r\n        return resource;\r\n    }\r\n\r\n    if (EntityRegistry.enemies?.[id]) {\r\n        const enemy = new Enemy({ x, y, enemyType: id });\r\n        entityManager.add(enemy);\r\n        return enemy;\r\n    }\r\n\r\n    if (EntityRegistry.bosses?.[id]) {\r\n        const boss = new Boss({ x, y, bossType: id });\r\n        entityManager.add(boss);\r\n        return boss;\r\n    }\r\n\r\n    Logger.warn(`[MapObjectSpawner] Unknown asset id: ${id}`);\r\n    return null;\r\n}\r\n\r\nfunction clearMapSpawnedEntities(map: Map<string, IEntity>): void {\r\n    for (const entity of map.values()) {\r\n        entityManager.remove(entity);\r\n    }\r\n    map.clear();\r\n}\r\n\r\nconst MapObjectSpawner = {\r\n    _entityMap: new Map<string, IEntity>(),\r\n    _initialized: false,\r\n\r\n    async init(_game?: unknown): Promise<void> {\r\n        if (this._initialized) return;\r\n\r\n        this._setupChannel();\r\n        await this._loadInitialMap();\r\n        this._initialized = true;\r\n        Logger.info('[MapObjectSpawner] Initialized');\r\n    },\r\n\r\n    _setupChannel(): void {\r\n        if (typeof window === 'undefined' || typeof BroadcastChannel === 'undefined') return;\r\n\r\n        const channel = new BroadcastChannel(CHANNEL_NAME);\r\n        channel.onmessage = (event: MessageEvent) => {\r\n            const { type, id, x, y, oldX, oldY, newX, newY, data } = event.data || {};\r\n\r\n            switch (type) {\r\n                case 'MAP_FULL':\r\n                    this._applyFullMap(data);\r\n                    break;\r\n                case 'MAP_HERO_SPAWN':\r\n                    if (typeof x === 'number' && typeof y === 'number') {\r\n                        const wm = Registry?.get<{ setHeroSpawn: (x: number, y: number) => void }>('WorldManager');\r\n                        wm?.setHeroSpawn(x, y);\r\n                    }\r\n                    break;\r\n                case 'MAP_OBJECT_ADD':\r\n                    if (id != null && x != null && y != null) {\r\n                        this._addOne({ id, x, y });\r\n                    }\r\n                    break;\r\n                case 'MAP_OBJECT_REMOVE':\r\n                    if (x != null && y != null) {\r\n                        this._removeOne(x, y, id);\r\n                    }\r\n                    break;\r\n                case 'MAP_OBJECT_MOVE':\r\n                    if (id != null && oldX != null && oldY != null && newX != null && newY != null) {\r\n                        this._moveOne(id, oldX, oldY, newX, newY);\r\n                    }\r\n                    break;\r\n            }\r\n        };\r\n        Logger.info('[MapObjectSpawner] Listening for map updates');\r\n    },\r\n\r\n    async _loadInitialMap(): Promise<void> {\r\n        const data = getPrefetchedMapData() ?? (await fetchMapData());\r\n        if (data) {\r\n            this._applyFullMap(data);\r\n        }\r\n        clearPrefetchedMapData();\r\n    },\r\n\r\n    _applyFullMap(data: MapData | null): void {\r\n        if (data?.mapgen4Param) {\r\n            const worldManager = Registry?.get<{ setMapgen4ParamAndRebuild: (p: Mapgen4Param, m?: ManualTownsAndRailroads) => void }>('WorldManager');\r\n            worldManager?.setMapgen4ParamAndRebuild(data.mapgen4Param, {\r\n                manualTowns: data.manualTowns,\r\n                manualStations: data.manualStations,\r\n                railroadWaypoints: data.railroadWaypoints\r\n            });\r\n        }\r\n        const worldManager = Registry?.get<{ setHeroSpawn: (x: number, y: number) => void; clearHeroSpawn: () => void }>('WorldManager');\r\n        if (data?.heroSpawn && typeof data.heroSpawn.x === 'number' && typeof data.heroSpawn.y === 'number') {\r\n            worldManager?.setHeroSpawn(data.heroSpawn.x, data.heroSpawn.y);\r\n        } else {\r\n            worldManager?.clearHeroSpawn();\r\n        }\r\n        clearMapSpawnedEntities(this._entityMap);\r\n        const objects = getObjectsFromMapData(data);\r\n        for (const obj of objects) {\r\n            const entity = spawnEntityForMapObject(obj);\r\n            if (entity) {\r\n                this._entityMap.set(makeKey(obj.x, obj.y), entity);\r\n            }\r\n        }\r\n        Logger.info(`[MapObjectSpawner] Loaded ${objects.length} objects from map`);\r\n    },\r\n\r\n    _addOne(obj: MapObject): void {\r\n        const existing = findEntityAt(this._entityMap, obj.x, obj.y);\r\n        if (existing) return;\r\n\r\n        const entity = spawnEntityForMapObject(obj);\r\n        if (entity) {\r\n            this._entityMap.set(makeKey(obj.x, obj.y), entity);\r\n        }\r\n    },\r\n\r\n    _removeOne(x: number, y: number, id?: string): void {\r\n        const found = findEntityAt(this._entityMap, x, y, id);\r\n        if (found) {\r\n            entityManager.remove(found.entity);\r\n            this._entityMap.delete(found.key);\r\n        }\r\n    },\r\n\r\n    _moveOne(id: string, oldX: number, oldY: number, newX: number, newY: number): void {\r\n        const found = findEntityAt(this._entityMap, oldX, oldY, id);\r\n        if (found) {\r\n            found.entity.x = newX;\r\n            found.entity.y = newY;\r\n            this._entityMap.delete(found.key);\r\n            this._entityMap.set(makeKey(newX, newY), found.entity);\r\n        }\r\n    }\r\n};\r\n\r\nif (typeof window !== 'undefined') {\r\n    (window as unknown as { MapObjectSpawner: typeof MapObjectSpawner }).MapObjectSpawner = MapObjectSpawner;\r\n}\r\n\r\nexport { MapObjectSpawner };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\world\\Prop.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\src\\world\\WorldManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'SCALE' is assigned a value but never used.","line":48,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":48,"endColumn":12}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * WorldManager - Mapgen4 polygon map integration\r\n *\r\n * Replaces WorldManager for the main game. Builds mesh+map from mapgen4,\r\n * provides world size, hero spawn, and stub isWalkable/isBlocked (walk everywhere).\r\n * Entity placement is done via map editor.\r\n *\r\n * Owner: Director\r\n */\r\n\r\nimport { Logger } from '@core/Logger';\r\nimport { Registry } from '@core/Registry';\r\nimport { AssetLoader } from '@core/AssetLoader';\r\nimport { getPrefetchedMapData } from './MapDataService';\r\nimport { buildMeshAndMap, computeTownsAndRoads, DEFAULT_MAPGEN4_PARAM } from '../tools/map-editor/Mapgen4Generator';\r\nimport type {\r\n    MeshAndMap,\r\n    Mapgen4Param,\r\n    TownSite,\r\n    RoadSegment,\r\n    RailroadCrossing,\r\n    ManualTownsAndRailroads\r\n} from '../tools/map-editor/Mapgen4Generator';\r\n\r\n/** Deep-merge loaded mapgen4Param with defaults so towns/railroads are never lost. */\r\nfunction mergeMapgen4Param(loaded: Mapgen4Param | undefined): Mapgen4Param {\r\n    if (!loaded) return DEFAULT_MAPGEN4_PARAM;\r\n    return {\r\n        ...DEFAULT_MAPGEN4_PARAM,\r\n        ...loaded,\r\n        elevation: { ...DEFAULT_MAPGEN4_PARAM.elevation, ...loaded.elevation },\r\n        biomes: { ...DEFAULT_MAPGEN4_PARAM.biomes, ...loaded.biomes },\r\n        rivers: { ...DEFAULT_MAPGEN4_PARAM.rivers, ...loaded.rivers },\r\n        towns: loaded.towns\r\n            ? { ...DEFAULT_MAPGEN4_PARAM.towns!, ...loaded.towns }\r\n            : DEFAULT_MAPGEN4_PARAM.towns,\r\n        roads: loaded.roads\r\n            ? { ...DEFAULT_MAPGEN4_PARAM.roads!, ...loaded.roads }\r\n            : DEFAULT_MAPGEN4_PARAM.roads,\r\n        railroads: loaded.railroads\r\n            ? { ...DEFAULT_MAPGEN4_PARAM.railroads!, ...loaded.railroads }\r\n            : DEFAULT_MAPGEN4_PARAM.railroads\r\n    };\r\n}\r\n\r\nconst MESH_SIZE = 1000;\r\nconst WORLD_SIZE = 160000;\r\nconst SCALE = WORLD_SIZE / MESH_SIZE;\r\n\r\nclass WorldManagerService {\r\n    private meshAndMap: MeshAndMap | null = null;\r\n    private param: Mapgen4Param = DEFAULT_MAPGEN4_PARAM;\r\n\r\n    private _heroSpawn: { x: number; y: number } | null = null;\r\n    private _cachedTowns: TownSite[] = [];\r\n    private _cachedRoadSegments: RoadSegment[] = [];\r\n    private _cachedRailroadPath: number[] = [];\r\n    private _cachedRailroadCrossings: RailroadCrossing[] = [];\r\n    private _cachedRailroadStationIds: number[] = [];\r\n    private _manualData?: ManualTownsAndRailroads;\r\n\r\n    constructor() {\r\n        Logger.info('[WorldManager] Constructed');\r\n    }\r\n\r\n    private buildMeshAndCacheTownsRoads(): void {\r\n        this.meshAndMap = buildMeshAndMap(this.param);\r\n        const { towns, roadSegments, railroadPath, railroadCrossings, railroadStationIds } =\r\n            computeTownsAndRoads(\r\n                this.meshAndMap!.mesh,\r\n                this.meshAndMap!.map,\r\n                this.param,\r\n                this._manualData\r\n            );\r\n        this._cachedTowns = towns;\r\n        this._cachedRoadSegments = roadSegments;\r\n        this._cachedRailroadPath = railroadPath;\r\n        this._cachedRailroadCrossings = railroadCrossings;\r\n        this._cachedRailroadStationIds = railroadStationIds;\r\n\r\n        Logger.info(\r\n            '[WorldManager] Generated:',\r\n            towns.length, 'towns,',\r\n            roadSegments.length, 'road segments,',\r\n            railroadPath.length, 'railroad path nodes,',\r\n            railroadCrossings.length, 'crossings.',\r\n            'Railroads enabled:', !!this.param.railroads?.enabled,\r\n            'Towns enabled:', !!this.param.towns?.enabled\r\n        );\r\n\r\n        if (railroadPath.length >= 2) {\r\n            for (const biome of ['grasslands', 'tundra', 'desert', 'badlands']) {\r\n                AssetLoader.preloadImage(`ground_base_gravel_${biome}_01`);\r\n                AssetLoader.preloadImage(`arch_railtrack_metal_${biome}_clean`);\r\n                AssetLoader.preloadImage(`arch_railtrack_wood_01_${biome}_clean`);\r\n                AssetLoader.preloadImage(`arch_railtrack_wood_02_${biome}_clean`);\r\n                AssetLoader.preloadImage(`arch_railtrack_wood_03_${biome}_clean`);\r\n            }\r\n        }\r\n    }\r\n\r\n    init() {\r\n        Logger.info('[WorldManager] init() called');\r\n        const prefetched = getPrefetchedMapData();\r\n        if (prefetched) {\r\n            if (prefetched.mapgen4Param) {\r\n                this.param = mergeMapgen4Param(prefetched.mapgen4Param);\r\n                Logger.info(\r\n                    '[WorldManager] Using mapgen4Param from map data, meshSeed:', this.param.meshSeed,\r\n                    'towns:', this.param.towns?.numTowns ?? '?',\r\n                    'railroads:', this.param.railroads?.enabled ?? false\r\n                );\r\n            }\r\n            this._manualData = {\r\n                manualTowns: prefetched.manualTowns,\r\n                manualStations: prefetched.manualStations,\r\n                railroadWaypoints: prefetched.railroadWaypoints\r\n            };\r\n        } else {\r\n            this.param = DEFAULT_MAPGEN4_PARAM;\r\n            Logger.info('[WorldManager] No mapgen4Param in prefetched data, using DEFAULT_MAPGEN4_PARAM, meshSeed:', this.param.meshSeed);\r\n        }\r\n        this.buildMeshAndCacheTownsRoads();\r\n    }\r\n\r\n    getWorldSize(): { width: number; height: number } {\r\n        return { width: WORLD_SIZE, height: WORLD_SIZE };\r\n    }\r\n\r\n    getHeroSpawnPosition(): { x: number; y: number } {\r\n        if (this._heroSpawn) return this._heroSpawn;\r\n        return { x: WORLD_SIZE / 2, y: WORLD_SIZE / 2 };\r\n    }\r\n\r\n    /** Set hero spawn from map data. Called when map is loaded or hero spawn is moved in editor. */\r\n    setHeroSpawn(x: number, y: number): void {\r\n        this._heroSpawn = { x, y };\r\n    }\r\n\r\n    /** Clear hero spawn (revert to map center). Called when loading a map with no hero spawn. */\r\n    clearHeroSpawn(): void {\r\n        this._heroSpawn = null;\r\n    }\r\n\r\n    getMesh(): MeshAndMap | null {\r\n        return this.meshAndMap;\r\n    }\r\n\r\n    getMapgen4Param(): Mapgen4Param {\r\n        return this.param;\r\n    }\r\n\r\n    /** Apply mapgen4 params and manual data from loaded map, then rebuild mesh. */\r\n    setMapgen4ParamAndRebuild(param: Mapgen4Param, manualData?: ManualTownsAndRailroads): void {\r\n        this.param = mergeMapgen4Param(param);\r\n        if (manualData) {\r\n            this._manualData = manualData;\r\n        }\r\n        this.buildMeshAndCacheTownsRoads();\r\n        Logger.info('[WorldManager] Mesh rebuilt with map params, meshSeed:', param.meshSeed);\r\n    }\r\n\r\n    /** Cached towns, roads, and railroads for polygon map rendering (avoids recompute every frame). */\r\n    getCachedTownsAndRoads(): {\r\n        towns: TownSite[];\r\n        roadSegments: RoadSegment[];\r\n        railroadPath: number[];\r\n        railroadCrossings: RailroadCrossing[];\r\n        railroadStationIds: number[];\r\n    } {\r\n        return {\r\n            towns: this._cachedTowns,\r\n            roadSegments: this._cachedRoadSegments,\r\n            railroadPath: this._cachedRailroadPath,\r\n            railroadCrossings: this._cachedRailroadCrossings,\r\n            railroadStationIds: this._cachedRailroadStationIds\r\n        };\r\n    }\r\n\r\n    /** World coords  mesh coords (0..1000) */\r\n    worldToMesh(x: number, y: number): { x: number; y: number } {\r\n        return { x: (x / WORLD_SIZE) * MESH_SIZE, y: (y / WORLD_SIZE) * MESH_SIZE };\r\n    }\r\n\r\n    /** Mesh coords (0..1000)  world coords */\r\n    meshToWorld(mx: number, my: number): { x: number; y: number } {\r\n        return { x: (mx / MESH_SIZE) * WORLD_SIZE, y: (my / MESH_SIZE) * WORLD_SIZE };\r\n    }\r\n\r\n    // --- Stub: walk everywhere ---\r\n    isWalkable(_x: number, _y: number): boolean {\r\n        return true;\r\n    }\r\n\r\n    isBlocked(_x: number, _y: number): boolean {\r\n        return false;\r\n    }\r\n}\r\n\r\nconst WorldManager = new WorldManagerService();\r\nif (Registry) Registry.register('WorldManager', WorldManager);\r\n\r\nexport { WorldManager, WorldManagerService };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\test_clone.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tests\\core\\DamageSystem.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tests\\core\\EntityManager.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tests\\core\\EventBus.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tests\\core\\EventBus.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tests\\core\\Logger.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tests\\core\\Quadtree.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tests\\core\\Registry.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tests\\map-editor\\Mapgen4BiomeConfig.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tests\\map-editor\\Mapgen4Generator.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":78,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":78,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3423,3426],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3423,3426],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":100,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":100,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4244,4247],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4244,4247],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Mapgen4Generator unit tests.\r\n * Tests deterministic mesh generation and drawCachedMeshToCanvas behavior.\r\n */\r\nimport { describe, it, expect } from 'vitest';\r\nimport {\r\n    buildMeshAndMap,\r\n    DEFAULT_MAPGEN4_PARAM,\r\n    type Mapgen4Param\r\n} from '../../src/tools/map-editor/Mapgen4Generator';\r\nimport { drawProceduralToCanvas } from '../../src/tools/map-editor/MapEditorProceduralRenderer';\r\n\r\nfunction makeParam(overrides: Partial<Mapgen4Param> = {}): Mapgen4Param {\r\n    return { ...DEFAULT_MAPGEN4_PARAM, ...overrides };\r\n}\r\n\r\ndescribe('Mapgen4Generator', () => {\r\n    describe('buildMeshAndMap', () => {\r\n        it('returns mesh and map with expected structure', () => {\r\n            const { mesh, map } = buildMeshAndMap(DEFAULT_MAPGEN4_PARAM);\r\n\r\n            expect(mesh).toBeDefined();\r\n            expect(map).toBeDefined();\r\n            expect(mesh.numSolidRegions).toBeGreaterThan(0);\r\n            expect(mesh.numSolidSides).toBeGreaterThan(0);\r\n            expect(map.elevation_r).toBeInstanceOf(Float32Array);\r\n            expect(map.rainfall_r).toBeInstanceOf(Float32Array);\r\n            expect(map.flow_s).toBeInstanceOf(Float32Array);\r\n            expect(map.elevation_r.length).toBeGreaterThanOrEqual(mesh.numSolidRegions);\r\n        });\r\n\r\n        it('produces deterministic output for same params', () => {\r\n            const param = makeParam({ meshSeed: 99999 });\r\n            const a = buildMeshAndMap(param);\r\n            const b = buildMeshAndMap(param);\r\n\r\n            expect(a.mesh.numSolidRegions).toBe(b.mesh.numSolidRegions);\r\n            expect(a.mesh.numSolidSides).toBe(b.mesh.numSolidSides);\r\n\r\n            const n = Math.min(10, a.mesh.numSolidRegions);\r\n            for (let r = 0; r < n; r++) {\r\n                expect(a.map.elevation_r[r]).toBe(b.map.elevation_r[r]);\r\n                expect(a.map.rainfall_r[r]).toBe(b.map.rainfall_r[r]);\r\n            }\r\n        });\r\n\r\n        it('produces different output for different meshSeed', () => {\r\n            const a = buildMeshAndMap(makeParam({ meshSeed: 111 }));\r\n            const b = buildMeshAndMap(makeParam({ meshSeed: 222 }));\r\n\r\n            // Different seeds produce different mesh structure or different elevation/rainfall\r\n            const structureDiffers = a.mesh.numSolidRegions !== b.mesh.numSolidRegions;\r\n            const n = Math.min(50, a.mesh.numSolidRegions, b.mesh.numSolidRegions);\r\n            const elevationDiffers = Array.from({ length: n }).some(\r\n                (_, r) => a.map.elevation_r[r] !== b.map.elevation_r[r]\r\n            );\r\n            expect(structureDiffers || elevationDiffers).toBe(true);\r\n        });\r\n    });\r\n\r\n    describe('drawProceduralToCanvas', () => {\r\n        it('draws without throwing when given valid inputs', () => {\r\n            const { mesh, map } = buildMeshAndMap(DEFAULT_MAPGEN4_PARAM);\r\n            const canvas = document.createElement('canvas');\r\n            canvas.width = 200;\r\n            canvas.height = 200;\r\n\r\n            // Mock a typical procedural cache object needed for drawProceduralToCanvas\r\n            const procCache = {\r\n                meshAndMap: { mesh, map },\r\n                param: DEFAULT_MAPGEN4_PARAM,\r\n                cellRegions: [],\r\n                towns: [],\r\n                roadSegments: [],\r\n                railroadPath: [],\r\n                railroadCrossings: [],\r\n                railroadStationIds: []\r\n            } as any;\r\n\r\n            expect(() => {\r\n                drawProceduralToCanvas(procCache, canvas, { x: 0, y: 0, width: 1000, height: 1000 }, new Set());\r\n            }).not.toThrow();\r\n        });\r\n\r\n        it('handles viewport clipping (partial viewport)', () => {\r\n            const { mesh, map } = buildMeshAndMap(DEFAULT_MAPGEN4_PARAM);\r\n            const canvas = document.createElement('canvas');\r\n            canvas.width = 50;\r\n            canvas.height = 50;\r\n\r\n            const procCache = {\r\n                meshAndMap: { mesh, map },\r\n                param: DEFAULT_MAPGEN4_PARAM,\r\n                cellRegions: [],\r\n                towns: [],\r\n                roadSegments: [],\r\n                railroadPath: [],\r\n                railroadCrossings: [],\r\n                railroadStationIds: []\r\n            } as any;\r\n\r\n            expect(() => {\r\n                drawProceduralToCanvas(procCache, canvas, { x: 200, y: 300, width: 400, height: 400 }, new Set());\r\n            }).not.toThrow();\r\n        });\r\n    });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tests\\systems\\EconomySystem.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\asset_prompts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\audio\\_config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\audio\\asset_queue.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\audio\\sfx_combat.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\buildings\\_config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\buildings\\asset_queue.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\buildings\\structures.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\dashboard\\scripts\\build.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\dashboard\\scripts\\debug_parse_standalone.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'path' is defined but never used.","line":3,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":12,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"path"},"fix":{"range":[24,48],"text":""},"desc":"Remove unused import declaration."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport fs from 'fs';\r\nimport path from 'path';\r\n\r\nconst filepath = 'c:/Users/Anthony/.gemini/antigravity/scratch/jurassic-knights-valley/src/entities/nodes/node_mining_t1_01.ts';\r\n\r\nfunction readTsEntity(filepath: string) {\r\n    try {\r\n        const content = fs.readFileSync(filepath, 'utf-8');\r\n        console.log(`Reading file: ${filepath}`);\r\n\r\n        let match = content.match(/export\\s+default\\s+(\\{[\\s\\S]*\\})\\s*satisfies/);\r\n        if (!match) {\r\n            match = content.match(/export\\s+default\\s+(\\{[\\s\\S]*\\})\\s*;?\\s*$/);\r\n        }\r\n\r\n        if (!match) {\r\n            console.log(\"No match found!\");\r\n            return null;\r\n        }\r\n\r\n        const jsonStr = match[1];\r\n        console.log(\"Captured JSON string length:\", jsonStr.length);\r\n        // console.log(\"JSON String Snippet:\", jsonStr.substring(0, 200));\r\n\r\n        try {\r\n            const parseFn = new Function(`return ${jsonStr};`);\r\n            const parsed = parseFn();\r\n            return parsed;\r\n        } catch (e) {\r\n            console.error(\"Parse error:\", e);\r\n            return null;\r\n        }\r\n    } catch (e) {\r\n        console.error(\"Read error:\", e);\r\n        return null;\r\n    }\r\n}\r\n\r\nconst entity = readTsEntity(filepath);\r\nconsole.log(\"Parsed Entity:\", JSON.stringify(entity, null, 2));\r\nconsole.log(\"Biome Field:\", entity?.biome);\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\dashboard\\src\\ActionDelegator.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'updateWeaponMeta' is defined but never used.","line":10,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":21,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"updateWeaponMeta"},"fix":{"range":[197,220],"text":""},"desc":"Remove unused variable \"updateWeaponMeta\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'saveRegenerationQueueToFile' is defined but never used.","line":13,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":32,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"saveRegenerationQueueToFile"},"fix":{"range":[281,315],"text":""},"desc":"Remove unused variable \"saveRegenerationQueueToFile\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'inspector' is assigned a value but never used.","line":70,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":70,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'t' is defined but never used. Allowed unused args must match /^_/u.","line":133,"column":32,"nodeType":"Identifier","messageId":"unusedVar","endLine":133,"endColumn":33}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\r\n    updateCategoryStatus,\r\n    updateConsumedStatus,\r\n    updateItemWeapon,\r\n    updateItemStat,\r\n    updateItemField,\r\n    updateItemTier,\r\n    updateDisplayField,\r\n    updateDisplaySize,\r\n    updateWeaponMeta,\r\n    markSfxForRegeneration,\r\n    markAllSfxForRegeneration,\r\n    saveRegenerationQueueToFile,\r\n    remakeAsset,\r\n    saveAssetPrompt\r\n} from './api';\r\nimport {\r\n    navigateToAsset,\r\n    approveCategoryItem,\r\n    declineCategoryItem,\r\n    remakeCategoryItem,\r\n    approveAsset,\r\n    declineAsset,\r\n    declineAssetPrompt,\r\n    declineCategoryItemById,\r\n    remakeCategoryItemById,\r\n    showCategoryView,\r\n    loadManifest,\r\n    showConfigView\r\n} from './views';\r\nimport { openModal, toggleComparisonView, closeModal } from './modals';\r\nimport { playSound } from './AudioManager';\r\nimport { showTemplatesView } from './templates';\r\nimport {\r\n    setCategoryStatusFilter,\r\n    setCategoryBiomeFilter,\r\n    setCategoryTierFilter,\r\n    setCategoryFileFilter,\r\n    setCategoryWeaponTypeFilter,\r\n    setCategoryHandsFilter,\r\n    setCategoryNodeSubtypeFilter,\r\n    setCategoryImageSize,\r\n    setCategorySortOrder,\r\n    resetCategoryFilters\r\n} from './filters';\r\nimport {\r\n    setSelectedAssetId,\r\n    setCurrentInspectorTab,\r\n    setImageParam,\r\n    categoryData,\r\n    assetPrompts,\r\n    selectedAssetId\r\n} from './state';\r\nimport { renderCategoryView } from './categoryRenderer';\r\nimport { renderInspector } from './inspectorRenderer';\r\n\r\n// Helper to switch tabs in inspector\r\nfunction switchInspectorTab(tabName: string, target: HTMLElement) {\r\n    // 0. Update State\r\n    setCurrentInspectorTab(tabName);\r\n\r\n    // 1. Update Buttons\r\n    const container = target.closest('.inspector-tabs');\r\n    if (container) {\r\n        container.querySelectorAll('.tab-btn').forEach((b) => b.classList.remove('active'));\r\n        target.classList.add('active');\r\n    }\r\n\r\n    // 2. toggle Content\r\n    const inspector = document.getElementById('inspectorPanel'); // Check if ID is correct, inspectorRenderer uses ID 'inspectorContent' but parent is probably panel\r\n    // Actually inspectorRenderer uses 'inspectorContent'. Let's check where 'inspectorPanel' is coming from.\r\n    // The previous code had 'inspectorPanel'. I will assume it renders into a container.\r\n    // However, looking at inspectorRenderer.ts: const container = document.getElementById('inspectorContent');\r\n    // So we should query inside 'inspectorContent' or just query document.\r\n\r\n    // Safer to query document for the active content\r\n    document\r\n        .querySelectorAll('.tab-content')\r\n        .forEach((el) => ((el as HTMLElement).style.display = 'none'));\r\n    const activeContent = document.getElementById(`tab-${tabName}`);\r\n    if (activeContent) activeContent.style.display = 'block';\r\n}\r\n\r\n// Action Handler Signature\r\ntype ActionHandler = (dataset: DOMStringMap, target: HTMLElement) => void | Promise<void>;\r\n\r\nconst actions: Record<string, ActionHandler> = {\r\n    // Navigation\r\n    'navigate-asset': (d) => navigateToAsset(d.category!, d.id!),\r\n    'navigate-category': (d) => showCategoryView(d.category!),\r\n    'toggle-templates': () => showTemplatesView(),\r\n    'toggle-config': () => showConfigView(),\r\n    'toggle-map-editor': () => {\r\n        const container = document.getElementById('map-editor-container');\r\n        const isOpen = container && container.style.display !== 'none';\r\n        if (isOpen) {\r\n            import('./views').then(({ loadManifest }) => loadManifest());\r\n            import('@dashboard/mapEditorView').then(({ hideMapEditorView }) => hideMapEditorView());\r\n        } else {\r\n            import('@dashboard/mapEditorView').then((m) => m.showMapEditorView());\r\n        }\r\n    },\r\n    'refresh-manifest': () => loadManifest(),\r\n    'save-map-data': () => import('@dashboard/mapEditorView').then((m) => m.saveMapFromPanel()),\r\n\r\n    // Selection & Inspector\r\n    'select-asset': (d) => {\r\n        setSelectedAssetId(d.id!);\r\n        // Re-render grid to update selection highlight\r\n        renderCategoryView();\r\n        // Render inspector\r\n        renderInspector();\r\n    },\r\n    'switch-tab': (d, t) => switchInspectorTab(d.tab!, t),\r\n    'copy-id': (d) => {\r\n        navigator.clipboard.writeText(d.id!);\r\n        // Visual feedback?\r\n        console.log('Copied ID:', d.id);\r\n    },\r\n\r\n    // Status\r\n    'approve-item': (d) => approveCategoryItem(d.category!, d.file!, d.id!),\r\n    'decline-item': (d) => declineCategoryItem(d.category!, d.file!, d.id!, d.safeId!),\r\n    'remake-item': (d) => remakeCategoryItem(d.category!, d.file!, d.id!, d.safeId!),\r\n\r\n    // Quick Actions (Legacy Assets)\r\n    'approve-asset': (d) => approveAsset(d.path!),\r\n    'decline-asset': (d) => declineAsset(d.path!, d.name!, d.safeId!),\r\n    'decline-asset-prompt': (d) => declineAssetPrompt(d.path!, d.name!),\r\n    'remake-asset': (d) => remakeAsset(d.path!, d.name!, d.safeId!),\r\n\r\n    // Quick Actions (Category Cards)\r\n    'quick-approve': async (d, t) => {\r\n        // Prevent selecting the card when clicking the button\r\n        // (Handled by stopPropagation in delegator, but good to note)\r\n        await approveCategoryItem(d.category!, d.file!, d.id!);\r\n    },\r\n    'quick-decline': async (d, t) => {\r\n        // Try to find a sibling input in the card footer\r\n        const footer = t.closest('.card-footer');\r\n        const input = footer?.querySelector('.feedback-input') as HTMLInputElement;\r\n\r\n        const reason = input ? input.value : '';\r\n\r\n        // If reason is empty, we still proceed with decline status.\r\n        // User explicitly requested NO POPUP.\r\n        await updateCategoryStatus(d.category!, d.file!, d.id!, 'declined', reason);\r\n    },\r\n\r\n    // Field Updates\r\n    'update-status': (d) => updateCategoryStatus(d.category!, d.file!, d.id!, d.value!),\r\n    // 'update-consumed-status' handled globally below to support notes\r\n    'update-tier': (d) => updateItemTier(d.category!, d.file!, d.id!, parseInt(d.value!)),\r\n    'update-weapon': (d) => updateItemWeapon(d.category!, d.file!, d.id!, d.value!),\r\n    'update-field': (d) =>\r\n        updateItemField(d.category!, d.file!, d.id!, d.field!, parseValue(d.value!)),\r\n\r\n    'update-prompt': async (d) => {\r\n        const prompt = d.value || '';\r\n        const assetId = d.id!;\r\n\r\n        // Optimistic update\r\n        assetPrompts[assetId] = prompt;\r\n\r\n        await saveAssetPrompt(assetId, prompt);\r\n        console.log(`[Delegator] Asset prompt saved for ${assetId}`);\r\n    },\r\n\r\n    'paste-image-to-path': async (d) => {\r\n        const path = d.path;\r\n        if (!path) {\r\n            alert('No original file path set for this asset. Set one in the source code first.');\r\n            return;\r\n        }\r\n\r\n        try {\r\n            const items = await navigator.clipboard.read();\r\n            for (const item of items) {\r\n                if (item.types.includes('image/png') || item.types.includes('image/jpeg')) {\r\n                    // Same logic as uploadImageFile\r\n                    // Read content\r\n                    await uploadImageFile(\r\n                        await item.getType(\r\n                            item.types.includes('image/png') ? 'image/png' : 'image/jpeg'\r\n                        ),\r\n                        path,\r\n                        d.id\r\n                    ); // d.id might be undefined if not on a card with ID, but path is key.\r\n                    // If d.id is missing, we can try to infer or just pass undefined (grid won't auto-refresh specific card but full render will catch it)\r\n                    return;\r\n                }\r\n            }\r\n            alert('No image found on clipboard!');\r\n        } catch (err) {\r\n            console.error(err);\r\n            alert('Failed to read clipboard. Ensure you accepted permissions.');\r\n        }\r\n    },\r\n    'update-display': (d) =>\r\n        updateDisplayField(d.category!, d.file!, d.id!, d.field!, parseFloat(d.value!)),\r\n    'update-display-size': (d) =>\r\n        updateDisplaySize(d.category!, d.file!, d.id!, parseInt(d.value!)),\r\n\r\n    // Stats\r\n    'update-stat': (d) => updateItemStat(d.category!, d.file!, d.id!, d.key!, parseValue(d.value!)),\r\n\r\n    // Modals\r\n    'open-modal': (d) => openModal(d.path!, d.name!, d.status!),\r\n    'image-drop-zone': (d) => {\r\n        // If not selected, select it first\r\n        if (d.id && d.id !== selectedAssetId) {\r\n            setSelectedAssetId(d.id);\r\n            renderCategoryView();\r\n            renderInspector();\r\n        } else {\r\n            // If already selected (or no ID), open modal\r\n            openModal(d.path!, d.name!, d.status!);\r\n        }\r\n    },\r\n    'close-modal': () => closeModal(),\r\n    'toggle-comparison': () => toggleComparisonView(),\r\n\r\n    // Audio\r\n    'play-sound': (d) => playSound(d.id!),\r\n    'mark-sfx': (d) => markSfxForRegeneration(d.sfxId!, d.assetId!),\r\n    'mark-all-sfx': (d, t) => markAllSfxForRegeneration(d.assetId!, JSON.parse(d.sfxIds!), t),\r\n\r\n    // Filters & Sorting\r\n    'set-category-status': (d) => setCategoryStatusFilter(d.value!),\r\n    'set-category-biome': (d) => setCategoryBiomeFilter(d.value!),\r\n    'set-category-tier': (d) => setCategoryTierFilter(parseInt(d.value!) || d.value!), // Tier can be 'all' (string) or number\r\n    'set-category-file': (d) => setCategoryFileFilter(d.value!),\r\n    'set-category-weapon': (d) => setCategoryWeaponTypeFilter(d.value!),\r\n    'set-category-hands': (d) => setCategoryHandsFilter(d.value!),\r\n    'set-category-node-subtype': (d) => setCategoryNodeSubtypeFilter(d.value!),\r\n    'set-category-size': (d) => setCategoryImageSize(parseInt(d.value!)),\r\n    'set-category-sort': (d) => setCategorySortOrder(d.value!),\r\n    'reset-filters': () => resetCategoryFilters(),\r\n\r\n    // Advanced Image Actions (Split View)\r\n    'decline-item-by-id': (d) =>\r\n        declineCategoryItemById(d.category!, d.file!, d.id!, d.noteInputId!),\r\n    'remake-item-by-id': (d) => remakeCategoryItemById(d.category!, d.file!, d.id!, d.noteInputId!),\r\n\r\n    // Complex Consumed Status Updates (requires note lookup)\r\n    'update-consumed-status': (d) => {\r\n        const note = d.noteInputId\r\n            ? (document.getElementById(d.noteInputId) as HTMLInputElement)?.value\r\n            : '';\r\n        let val = d.value!;\r\n        let finalNote = note;\r\n\r\n        // Special handling for 'remake' value in consumed status\r\n        if (val === 'remake') {\r\n            val = 'declined';\r\n            finalNote = 'Remake: ' + (note || 'needs redo');\r\n        }\r\n\r\n        updateConsumedStatus(d.category!, d.file!, d.id!, val, finalNote);\r\n    }\r\n};\r\n\r\nfunction parseValue(val: string): string | number | boolean {\r\n    if (val === 'true') return true;\r\n    if (val === 'false') return false;\r\n    if (!isNaN(Number(val)) && val.trim() !== '') return Number(val);\r\n    return val;\r\n}\r\n\r\nlet abortController: AbortController | null = null;\r\n\r\nexport function disposeDelegation() {\r\n    if (abortController) {\r\n        abortController.abort();\r\n        abortController = null;\r\n        console.log('[Delegator] Cleaned up event listeners');\r\n    }\r\n}\r\n\r\nexport function initEventDelegation() {\r\n    // Clean up existing if any (prevents dupes)\r\n    disposeDelegation();\r\n\r\n    abortController = new AbortController();\r\n    const signal = abortController.signal;\r\n\r\n    document.body.addEventListener(\r\n        'click',\r\n        async (e) => {\r\n            // Log all clicks for debugging\r\n            // console.log('[Delegator] Click on:', e.target);\r\n\r\n            const target = (e.target as HTMLElement).closest('[data-action]') as HTMLElement;\r\n            if (!target) return;\r\n\r\n            const actionName = target.dataset.action;\r\n            console.log('[ActionDelegator] Action triggering:', actionName, target.dataset);\r\n\r\n            if (actionName && actions[actionName]) {\r\n                e.stopPropagation(); // Prevent bubbling if handled\r\n                try {\r\n                    await actions[actionName](target.dataset, target);\r\n                } catch (err) {\r\n                    console.error(`[Delegator] Action '${actionName}' failed:`, err);\r\n                }\r\n            }\r\n        },\r\n        { signal }\r\n    );\r\n\r\n    // Handle Input Changes (delegated change events)\r\n    document.body.addEventListener(\r\n        'input',\r\n        (e) => {\r\n            const target = e.target as HTMLElement;\r\n            if (target && target.matches('textarea.feedback-input')) {\r\n                target.style.height = 'auto';\r\n                target.style.height = target.scrollHeight + 'px';\r\n            }\r\n        },\r\n        { signal }\r\n    );\r\n\r\n    // Drag & Drop Delegation\r\n    document.body.addEventListener(\r\n        'dragover',\r\n        (e) => {\r\n            const trg = e.target as HTMLElement;\r\n            const target = trg.closest('[data-action=\"image-drop-zone\"]');\r\n\r\n            // Debug Log - throttling\r\n            if (Math.random() < 0.05) {\r\n                console.log('[DragDebug] Target:', trg.tagName, trg.className, 'Zone:', target);\r\n            }\r\n\r\n            if (target) {\r\n                e.preventDefault(); // Allow drop\r\n                e.dataTransfer!.dropEffect = 'copy';\r\n                (target as HTMLElement).style.borderColor = '#2196f3';\r\n                (target as HTMLElement).style.background = '#2196f322';\r\n            }\r\n        },\r\n        { signal }\r\n    );\r\n\r\n    document.body.addEventListener(\r\n        'dragleave',\r\n        (e) => {\r\n            const target = (e.target as HTMLElement).closest('[data-action=\"image-drop-zone\"]');\r\n            if (target) {\r\n                (target as HTMLElement).style.borderColor = '#444';\r\n                (target as HTMLElement).style.background = '#1a1a1a';\r\n            }\r\n        },\r\n        { signal }\r\n    );\r\n\r\n    document.body.addEventListener(\r\n        'drop',\r\n        async (e) => {\r\n            const trg = e.target as HTMLElement;\r\n            const target = trg.closest('[data-action=\"image-drop-zone\"]') as HTMLElement;\r\n\r\n            console.log('[Delegator] DROP Event on:', trg.tagName, trg.className, 'Zone:', target);\r\n\r\n            if (target) {\r\n                e.preventDefault();\r\n                e.stopPropagation();\r\n                target.style.borderColor = '#444';\r\n                target.style.background = '#1a1a1a';\r\n\r\n                // Check for file\r\n                const path = target.dataset.path;\r\n                const id = target.dataset.id;\r\n\r\n                if (!path) {\r\n                    console.warn('[Delegator] Drop: No original file path set.');\r\n                    return;\r\n                }\r\n\r\n                if (e.dataTransfer?.files.length) {\r\n                    const file = e.dataTransfer.files[0];\r\n                    if (!file.type.startsWith('image/')) {\r\n                        console.warn('[Delegator] Dropped file is not an image.');\r\n                        return;\r\n                    }\r\n\r\n                    // Read & Upload\r\n                    await uploadImageFile(file, path, id);\r\n                }\r\n            }\r\n        },\r\n        { signal }\r\n    );\r\n\r\n    document.body.addEventListener(\r\n        'change',\r\n        async (e) => {\r\n            const target = (e.target as HTMLElement).closest('[data-action]') as\r\n                | HTMLInputElement\r\n                | HTMLSelectElement;\r\n            if (!target) return;\r\n\r\n            const actionName = target.dataset.action;\r\n            // For inputs, we often want to use the input's current value as the payload\r\n            // Override dataset.value with actual input value\r\n            if (target.dataset.captureValue === 'true') {\r\n                target.dataset.value = target.value;\r\n            }\r\n\r\n            if (actionName && actions[actionName]) {\r\n                try {\r\n                    await actions[actionName](target.dataset, target);\r\n                } catch (err) {\r\n                    console.error(`[Delegator] Change Action '${actionName}' failed:`, err);\r\n                }\r\n            }\r\n        },\r\n        { signal }\r\n    );\r\n}\r\n\r\n// Utility for Upload\r\n// Utility for Upload\r\nasync function uploadImageFile(blob: Blob, path: string, assetId?: string) {\r\n    try {\r\n        const reader = new FileReader();\r\n        reader.onload = async () => {\r\n            const base64 = reader.result as string;\r\n\r\n            if (!path) return;\r\n\r\n            // Show loading state immediately\r\n            if (assetId) {\r\n                const card = document.querySelector(`.asset-card[data-id=\"${assetId}\"]`);\r\n                if (card) {\r\n                    const gridImg = card.querySelector('img.asset-image') as HTMLImageElement;\r\n                    if (gridImg) gridImg.style.opacity = '0.5';\r\n                }\r\n            }\r\n            const inspectorImg = document.querySelector(\r\n                '.inspector-placeholder img, .inspector-content img'\r\n            ) as HTMLImageElement;\r\n            if (inspectorImg) inspectorImg.style.opacity = '0.5';\r\n\r\n            // Helper to refresh UI\r\n            const preloadAndRefresh = async (targetPath: string, targetId: string | undefined) => {\r\n                // Normalize path for browser request\r\n                let checkPath = targetPath;\r\n                if (!checkPath.startsWith('/')) checkPath = '/' + checkPath;\r\n                checkPath =\r\n                    '/images/' + checkPath.replace(/^(assets\\/)?images\\//, '').replace(/^\\//, '');\r\n\r\n                const timestamp = Date.now();\r\n\r\n                // Update state\r\n                if (targetId) setImageParam(targetId, timestamp);\r\n\r\n                const checkUrl = `${checkPath}?t=${timestamp}`;\r\n                console.log('[Delegator] Preload checking URL:', checkUrl);\r\n\r\n                // Retry logic for Windows FS latency\r\n                const maxAttempts = 20;\r\n                for (let i = 0; i < maxAttempts; i++) {\r\n                    const success = await new Promise<boolean>((resolve) => {\r\n                        const img = new Image();\r\n                        img.onload = () => resolve(true);\r\n                        img.onerror = () => resolve(false);\r\n                        img.src = checkUrl;\r\n                    });\r\n\r\n                    if (success) {\r\n                        console.log('[Delegator] Preload success! Triggering re-render.');\r\n                        renderCategoryView();\r\n                        renderInspector();\r\n                        return;\r\n                    }\r\n                    await new Promise((r) => setTimeout(r, 250));\r\n                }\r\n                console.warn('[Delegator] Preload failed, forcing render anyway.');\r\n                renderCategoryView();\r\n                renderInspector();\r\n            };\r\n\r\n            try {\r\n                // Normalize path for upload (remove leading slash)\r\n                const cleanPath = path.replace(/^\\//, '');\r\n                const body = {\r\n                    path: cleanPath,\r\n                    image: base64\r\n                };\r\n\r\n                const response = await fetch('/api/upload_image', {\r\n                    method: 'POST',\r\n                    headers: { 'Content-Type': 'application/json' },\r\n                    body: JSON.stringify(body)\r\n                });\r\n\r\n                const result = await response.json();\r\n\r\n                if (result.success !== false) {\r\n                    console.log('[Delegator] Image uploaded successfully to:', cleanPath);\r\n\r\n                    // --- SYNC CHECK: If uploading Original, also update Clean (if exists) ---\r\n                    if (assetId && typeof categoryData !== 'undefined' && categoryData?.files) {\r\n                        // Find asset\r\n                        let asset: { id: string; [key: string]: unknown } | null = null;\r\n                        for (const list of Object.values(categoryData.files)) {\r\n                            const found = list.find((i: { id: string }) => i.id === assetId);\r\n                            if (found) {\r\n                                asset = found;\r\n                                break;\r\n                            }\r\n                        }\r\n\r\n                        if (asset && asset.files) {\r\n                            const originalFile = asset.files.original || '';\r\n                            const cleanFile = asset.files.clean || '';\r\n\r\n                            // Check if we just uploaded the Original\r\n                            // Note: cleanPath is relative (images/...), asset.files are relative usually\r\n                            const isOriginal =\r\n                                cleanPath.endsWith(originalFile) ||\r\n                                originalFile.endsWith(cleanPath);\r\n\r\n                            if (isOriginal && cleanFile && cleanFile !== originalFile) {\r\n                                console.log('[Delegator] Syncing Clean image:', cleanFile);\r\n                                // Silent upload to clean path\r\n                                await fetch('/api/upload_image', {\r\n                                    method: 'POST',\r\n                                    headers: { 'Content-Type': 'application/json' },\r\n                                    body: JSON.stringify({\r\n                                        path: cleanFile,\r\n                                        image: base64\r\n                                    })\r\n                                }).catch((e) => console.warn('[Delegator] Clean Sync Failed', e));\r\n                            }\r\n                        }\r\n                    }\r\n                    // -----------------------------------------------------------------------\r\n\r\n                    // Wait for file system to settle\r\n                    await new Promise((resolve) => setTimeout(resolve, 500));\r\n\r\n                    await preloadAndRefresh(path, assetId);\r\n                } else {\r\n                    console.error('[Delegator] Upload failed:', result.message);\r\n                    alert('Upload failed: ' + (result.message || 'Unknown error'));\r\n                    renderCategoryView(); // Restore opacity\r\n                }\r\n            } catch (err) {\r\n                console.error('[Delegator] Upload Exception:', err);\r\n                alert('Upload error occurred');\r\n                renderCategoryView();\r\n            }\r\n        }; // Closes the outer reader.onload\r\n        reader.readAsDataURL(blob); // Use the `blob` parameter here\r\n    } catch (err) {\r\n        console.error('[Delegator] Upload Exception:', err);\r\n        alert('Upload error occurred');\r\n        renderCategoryView();\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\dashboard\\src\\AssetPaletteView.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\dashboard\\src\\AudioManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\dashboard\\src\\MapStorage.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\dashboard\\src\\OutlinerPanel.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'refreshCallback' is assigned a value but never used.","line":56,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":56,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * OutlinerPanel  UE5-inspired World Outliner for the Map Editor\r\n *\r\n * Features:\r\n * - Search / filter bar (real-time, debounced)\r\n * - Category tree groups with collapse/expand (persisted via localStorage)\r\n * - Per-item visibility (eye) and lock toggles (editor-only state)\r\n * - Multi-selection (Ctrl+Click, Shift+Click)\r\n * - Right-click context menu (Focus, Delete, Select All of Type)\r\n * - Item count per group\r\n */\r\n\r\nimport type { MapEditorCore } from '../../../src/tools/map-editor/MapEditorCore';\r\nimport type { MapObject } from '../../../src/tools/map-editor/MapEditorTypes';\r\n\r\n//  Types \r\n\r\ninterface OutlinerItem {\r\n    kind: 'town' | 'station' | 'object';\r\n    /** Display label */\r\n    label: string;\r\n    /** Category group key */\r\n    group: string;\r\n    /** For objects: the MapObject ref. For towns: regionId. For stations: regionId + order. */\r\n    ref: MapObject | { regionId: number } | { regionId: number; order: number };\r\n    /** Unique key for selection tracking */\r\n    key: string;\r\n}\r\n\r\ninterface EditorItemState {\r\n    visible: boolean;\r\n    locked: boolean;\r\n}\r\n\r\n//  Constants \r\n\r\nconst COLLAPSE_STORAGE_KEY = 'outliner-collapsed-groups';\r\nconst SEARCH_DEBOUNCE_MS = 150;\r\n\r\nconst GROUP_CONFIG: Record<string, { icon: string; label: string; order: number }> = {\r\n    towns: { icon: '', label: 'Towns', order: 0 },\r\n    stations: { icon: '', label: 'Stations', order: 1 },\r\n    environment: { icon: '', label: 'Environment', order: 2 },\r\n    nodes: { icon: '', label: 'Nodes', order: 3 },\r\n    enemies: { icon: '', label: 'Enemies', order: 4 },\r\n    npcs: { icon: '', label: 'NPCs', order: 5 },\r\n    equipment: { icon: '', label: 'Equipment', order: 6 },\r\n    items: { icon: '', label: 'Items', order: 7 },\r\n    ground: { icon: '', label: 'Ground', order: 8 },\r\n    other: { icon: '', label: 'Other', order: 9 },\r\n};\r\n\r\n//  Module State \r\n\r\nlet editorRef: MapEditorCore | null = null;\r\nlet refreshCallback: (() => void) | null = null;\r\nlet runPreviewCallback: (() => Promise<void>) | null = null;\r\n\r\nconst itemStates = new Map<string, EditorItemState>();\r\nconst selectedKeys = new Set<string>();\r\nlet lastClickedKey: string | null = null;\r\nlet searchQuery = '';\r\nlet searchTimer: ReturnType<typeof setTimeout> | null = null;\r\nlet collapsedGroups: Set<string>;\r\n\r\n// Load collapsed groups from localStorage\r\nfunction loadCollapsedGroups(): Set<string> {\r\n    try {\r\n        const raw = localStorage.getItem(COLLAPSE_STORAGE_KEY);\r\n        return raw ? new Set(JSON.parse(raw)) : new Set();\r\n    } catch {\r\n        return new Set();\r\n    }\r\n}\r\n\r\nfunction saveCollapsedGroups(): void {\r\n    localStorage.setItem(COLLAPSE_STORAGE_KEY, JSON.stringify([...collapsedGroups]));\r\n}\r\n\r\ncollapsedGroups = loadCollapsedGroups();\r\n\r\n//  Helpers \r\n\r\nfunction getItemState(key: string): EditorItemState {\r\n    let s = itemStates.get(key);\r\n    if (!s) {\r\n        s = { visible: true, locked: false };\r\n        itemStates.set(key, s);\r\n    }\r\n    return s;\r\n}\r\n\r\nfunction classifyObjectGroup(id: string): string {\r\n    const prefixes: [string, string][] = [\r\n        ['environment_', 'environment'],\r\n        ['env_', 'environment'],\r\n        ['node_', 'nodes'],\r\n        ['enemy_', 'enemies'],\r\n        ['boss_', 'enemies'],\r\n        ['npc_', 'npcs'],\r\n        ['weapon_', 'equipment'],\r\n        ['tool_', 'equipment'],\r\n        ['armor_', 'equipment'],\r\n        ['item_', 'items'],\r\n        ['ground_', 'ground'],\r\n    ];\r\n    for (const [prefix, group] of prefixes) {\r\n        if (id.startsWith(prefix)) return group;\r\n    }\r\n    return 'other';\r\n}\r\n\r\nfunction cleanLabel(id: string): string {\r\n    return id\r\n        .replace(/_original$/, '')\r\n        .replace(/_/g, ' ')\r\n        .replace(/\\b\\w/g, (c) => c.toUpperCase());\r\n}\r\n\r\n//  Build Items \r\n\r\nfunction buildItems(): OutlinerItem[] {\r\n    if (!editorRef) return [];\r\n    const items: OutlinerItem[] = [];\r\n\r\n    // Towns\r\n    const towns = editorRef.getManualTowns();\r\n    towns.forEach((regionId, i) => {\r\n        items.push({\r\n            kind: 'town',\r\n            label: `Town ${i + 1} (region ${regionId})`,\r\n            group: 'towns',\r\n            ref: { regionId },\r\n            key: `town_${regionId}`,\r\n        });\r\n    });\r\n\r\n    // Stations\r\n    const stations = editorRef.getManualStations();\r\n    const sorted = [...stations].sort((a, b) => a.order - b.order);\r\n    sorted.forEach((s) => {\r\n        items.push({\r\n            kind: 'station',\r\n            label: `Station #${s.order} (region ${s.regionId})`,\r\n            group: 'stations',\r\n            ref: { regionId: s.regionId, order: s.order },\r\n            key: `station_${s.regionId}_${s.order}`,\r\n        });\r\n    });\r\n\r\n    // Objects\r\n    const cm = editorRef.getChunkManager();\r\n    const objects = cm?.getAllObjects() ?? [];\r\n    for (const obj of objects) {\r\n        const group = classifyObjectGroup(obj.id);\r\n        items.push({\r\n            kind: 'object',\r\n            label: cleanLabel(obj.id),\r\n            group,\r\n            ref: obj,\r\n            key: `obj_${obj.id}_${Math.round(obj.x)}_${Math.round(obj.y)}`,\r\n        });\r\n    }\r\n\r\n    return items;\r\n}\r\n\r\n//  Context Menu \r\n\r\nfunction showContextMenu(x: number, y: number, item: OutlinerItem): void {\r\n    hideContextMenu();\r\n    const menu = document.createElement('div');\r\n    menu.className = 'outliner-context-menu';\r\n    menu.style.left = `${x}px`;\r\n    menu.style.top = `${y}px`;\r\n    menu.id = 'outliner-ctx-menu';\r\n\r\n    const actions: { label: string; action: () => void }[] = [];\r\n\r\n    if (item.kind === 'object') {\r\n        const obj = item.ref as MapObject;\r\n        actions.push({\r\n            label: ' Focus',\r\n            action: () => {\r\n                editorRef?.setSelectedObject(obj);\r\n                editorRef?.centerViewOn(obj.x, obj.y);\r\n            },\r\n        });\r\n        actions.push({\r\n            label: ' Delete',\r\n            action: () => {\r\n                editorRef?.setSelectedObject(obj);\r\n                editorRef?.removeSelectedObject();\r\n                runPreviewCallback?.().catch(() => { });\r\n                refresh();\r\n            },\r\n        });\r\n    } else if (item.kind === 'town') {\r\n        const t = item.ref as { regionId: number };\r\n        actions.push({\r\n            label: ' Delete Town',\r\n            action: () => {\r\n                editorRef?.removeManualTown(t.regionId);\r\n                runPreviewCallback?.().catch(() => { });\r\n                refresh();\r\n            },\r\n        });\r\n    } else if (item.kind === 'station') {\r\n        const s = item.ref as { regionId: number };\r\n        actions.push({\r\n            label: ' Delete Station',\r\n            action: () => {\r\n                editorRef?.removeManualStation(s.regionId);\r\n                runPreviewCallback?.().catch(() => { });\r\n                refresh();\r\n            },\r\n        });\r\n    }\r\n\r\n    // Select all of type\r\n    actions.push({\r\n        label: ` Select All ${GROUP_CONFIG[item.group]?.label ?? item.group}`,\r\n        action: () => {\r\n            const items = buildItems().filter((i) => i.group === item.group);\r\n            selectedKeys.clear();\r\n            items.forEach((i) => selectedKeys.add(i.key));\r\n            refresh();\r\n        },\r\n    });\r\n\r\n    for (const a of actions) {\r\n        const btn = document.createElement('button');\r\n        btn.className = 'outliner-ctx-item';\r\n        btn.textContent = a.label;\r\n        btn.addEventListener('click', () => {\r\n            a.action();\r\n            hideContextMenu();\r\n        });\r\n        menu.appendChild(btn);\r\n    }\r\n\r\n    document.body.appendChild(menu);\r\n\r\n    // Close on outside click\r\n    const closeHandler = (e: MouseEvent) => {\r\n        if (!menu.contains(e.target as Node)) {\r\n            hideContextMenu();\r\n            document.removeEventListener('click', closeHandler, true);\r\n        }\r\n    };\r\n    setTimeout(() => document.addEventListener('click', closeHandler, true), 0);\r\n}\r\n\r\nfunction hideContextMenu(): void {\r\n    document.getElementById('outliner-ctx-menu')?.remove();\r\n}\r\n\r\n//  Render \r\n\r\nfunction refresh(): void {\r\n    const container = document.getElementById('outliner-tree');\r\n    if (!container || !editorRef) return;\r\n\r\n    const items = buildItems();\r\n\r\n    // Filter\r\n    const query = searchQuery.toLowerCase().trim();\r\n    const filtered = query\r\n        ? items.filter((i) => i.label.toLowerCase().includes(query) || i.key.toLowerCase().includes(query))\r\n        : items;\r\n\r\n    // Group\r\n    const groups = new Map<string, OutlinerItem[]>();\r\n    for (const item of filtered) {\r\n        const list = groups.get(item.group) ?? [];\r\n        list.push(item);\r\n        groups.set(item.group, list);\r\n    }\r\n\r\n    // Sort groups by config order\r\n    const sortedGroupKeys = [...groups.keys()].sort((a, b) => {\r\n        return (GROUP_CONFIG[a]?.order ?? 99) - (GROUP_CONFIG[b]?.order ?? 99);\r\n    });\r\n\r\n    // Current selection in editor\r\n    const editorSel = editorRef.getSelectedObject();\r\n\r\n    container.innerHTML = '';\r\n\r\n    if (sortedGroupKeys.length === 0) {\r\n        container.innerHTML = '<div class=\"outliner-empty\">No items match your search.</div>';\r\n        return;\r\n    }\r\n\r\n    for (const groupKey of sortedGroupKeys) {\r\n        const groupItems = groups.get(groupKey)!;\r\n        const config = GROUP_CONFIG[groupKey] ?? { icon: '', label: groupKey, order: 99 };\r\n        const isCollapsed = collapsedGroups.has(groupKey);\r\n\r\n        // Group header\r\n        const groupEl = document.createElement('div');\r\n        groupEl.className = 'outliner-group';\r\n\r\n        const header = document.createElement('div');\r\n        header.className = 'outliner-group-header';\r\n        header.innerHTML = `<span class=\"outliner-chevron ${isCollapsed ? 'collapsed' : ''}\">${isCollapsed ? '' : ''}</span>\r\n            <span class=\"outliner-group-icon\">${config.icon}</span>\r\n            <span class=\"outliner-group-label\">${config.label}</span>\r\n            <span class=\"outliner-group-count\">(${groupItems.length})</span>`;\r\n        header.addEventListener('click', () => {\r\n            if (collapsedGroups.has(groupKey)) {\r\n                collapsedGroups.delete(groupKey);\r\n            } else {\r\n                collapsedGroups.add(groupKey);\r\n            }\r\n            saveCollapsedGroups();\r\n            refresh();\r\n        });\r\n        groupEl.appendChild(header);\r\n\r\n        // Items (hidden if collapsed)\r\n        if (!isCollapsed) {\r\n            const listEl = document.createElement('div');\r\n            listEl.className = 'outliner-group-items';\r\n\r\n            for (const item of groupItems) {\r\n                const state = getItemState(item.key);\r\n                const isSelected = selectedKeys.has(item.key);\r\n                const isEditorSelected = item.kind === 'object' && editorSel &&\r\n                    (item.ref as MapObject).id === editorSel.id &&\r\n                    Math.abs((item.ref as MapObject).x - editorSel.x) < 1 &&\r\n                    Math.abs((item.ref as MapObject).y - editorSel.y) < 1;\r\n\r\n                const row = document.createElement('div');\r\n                row.className = 'outliner-item' +\r\n                    (isSelected ? ' selected' : '') +\r\n                    (isEditorSelected ? ' editor-selected' : '') +\r\n                    (!state.visible ? ' hidden-item' : '') +\r\n                    (state.locked ? ' locked-item' : '');\r\n                row.dataset.key = item.key;\r\n\r\n                // Visibility toggle\r\n                const eyeBtn = document.createElement('button');\r\n                eyeBtn.className = 'outliner-toggle outliner-eye';\r\n                eyeBtn.textContent = state.visible ? '' : '';\r\n                eyeBtn.title = state.visible ? 'Hide' : 'Show';\r\n                eyeBtn.addEventListener('click', (e) => {\r\n                    e.stopPropagation();\r\n                    state.visible = !state.visible;\r\n                    refresh();\r\n                });\r\n\r\n                // Icon\r\n                const icon = document.createElement('span');\r\n                icon.className = 'outliner-item-icon';\r\n                icon.textContent = config.icon;\r\n\r\n                // Label\r\n                const label = document.createElement('span');\r\n                label.className = 'outliner-item-label';\r\n                label.textContent = item.label;\r\n\r\n                // Coordinates (for objects)\r\n                const coords = document.createElement('span');\r\n                coords.className = 'outliner-item-coords';\r\n                if (item.kind === 'object') {\r\n                    const obj = item.ref as MapObject;\r\n                    coords.textContent = `${Math.round(obj.x)}, ${Math.round(obj.y)}`;\r\n                }\r\n\r\n                // Lock toggle\r\n                const lockBtn = document.createElement('button');\r\n                lockBtn.className = 'outliner-toggle outliner-lock';\r\n                lockBtn.textContent = state.locked ? '' : '';\r\n                lockBtn.title = state.locked ? 'Unlock' : 'Lock';\r\n                lockBtn.addEventListener('click', (e) => {\r\n                    e.stopPropagation();\r\n                    state.locked = !state.locked;\r\n                    refresh();\r\n                });\r\n\r\n                row.appendChild(eyeBtn);\r\n                row.appendChild(icon);\r\n                row.appendChild(label);\r\n                row.appendChild(coords);\r\n                row.appendChild(lockBtn);\r\n\r\n                // Click: select\r\n                row.addEventListener('click', (e) => {\r\n                    handleItemClick(item, e);\r\n                });\r\n\r\n                // Right-click: context menu\r\n                row.addEventListener('contextmenu', (e) => {\r\n                    e.preventDefault();\r\n                    showContextMenu(e.clientX, e.clientY, item);\r\n                });\r\n\r\n                listEl.appendChild(row);\r\n            }\r\n\r\n            groupEl.appendChild(listEl);\r\n        }\r\n\r\n        container.appendChild(groupEl);\r\n    }\r\n\r\n    // Update selection count\r\n    const countEl = document.getElementById('outliner-sel-count');\r\n    if (countEl) {\r\n        countEl.textContent = selectedKeys.size > 0 ? `${selectedKeys.size} selected` : '';\r\n    }\r\n}\r\n\r\n//  Selection Logic \r\n\r\nfunction handleItemClick(item: OutlinerItem, e: MouseEvent): void {\r\n    const allItems = buildItems();\r\n\r\n    if (e.shiftKey && lastClickedKey) {\r\n        // Range select\r\n        const allKeys = allItems.map((i) => i.key);\r\n        const start = allKeys.indexOf(lastClickedKey);\r\n        const end = allKeys.indexOf(item.key);\r\n        if (start >= 0 && end >= 0) {\r\n            const [from, to] = start < end ? [start, end] : [end, start];\r\n            if (!e.ctrlKey) selectedKeys.clear();\r\n            for (let i = from; i <= to; i++) {\r\n                selectedKeys.add(allKeys[i]);\r\n            }\r\n        }\r\n    } else if (e.ctrlKey) {\r\n        // Toggle\r\n        if (selectedKeys.has(item.key)) {\r\n            selectedKeys.delete(item.key);\r\n        } else {\r\n            selectedKeys.add(item.key);\r\n        }\r\n    } else {\r\n        // Single select\r\n        selectedKeys.clear();\r\n        selectedKeys.add(item.key);\r\n    }\r\n\r\n    lastClickedKey = item.key;\r\n\r\n    // Focus in editor\r\n    if (item.kind === 'object') {\r\n        const obj = item.ref as MapObject;\r\n        editorRef?.setSelectedObject(obj);\r\n        editorRef?.centerViewOn(obj.x, obj.y);\r\n    }\r\n\r\n    refresh();\r\n}\r\n\r\n//  Toolbar Actions \r\n\r\nfunction deleteSelected(): void {\r\n    if (selectedKeys.size === 0 || !editorRef) return;\r\n    const items = buildItems();\r\n\r\n    for (const item of items) {\r\n        if (!selectedKeys.has(item.key)) continue;\r\n\r\n        if (item.kind === 'object') {\r\n            editorRef.setSelectedObject(item.ref as MapObject);\r\n            editorRef.removeSelectedObject();\r\n        } else if (item.kind === 'town') {\r\n            editorRef.removeManualTown((item.ref as { regionId: number }).regionId);\r\n        } else if (item.kind === 'station') {\r\n            editorRef.removeManualStation((item.ref as { regionId: number }).regionId);\r\n        }\r\n    }\r\n\r\n    selectedKeys.clear();\r\n    runPreviewCallback?.().catch(() => { });\r\n    refresh();\r\n}\r\n\r\nfunction selectAll(): void {\r\n    const items = buildItems();\r\n    selectedKeys.clear();\r\n    items.forEach((i) => selectedKeys.add(i.key));\r\n    refresh();\r\n}\r\n\r\nfunction deselectAll(): void {\r\n    selectedKeys.clear();\r\n    refresh();\r\n}\r\n\r\nfunction expandAll(): void {\r\n    collapsedGroups.clear();\r\n    saveCollapsedGroups();\r\n    refresh();\r\n}\r\n\r\nfunction collapseAll(): void {\r\n    const items = buildItems();\r\n    const groups = new Set(items.map((i) => i.group));\r\n    collapsedGroups = groups;\r\n    saveCollapsedGroups();\r\n    refresh();\r\n}\r\n\r\n//  Public API \r\n\r\nexport const OutlinerPanel = {\r\n    /**\r\n     * Initialize the outliner panel. Call once after the HTML container exists.\r\n     */\r\n    init(\r\n        editor: MapEditorCore,\r\n        onRefresh: () => void,\r\n        onRunPreview: () => Promise<void>\r\n    ): void {\r\n        editorRef = editor;\r\n        refreshCallback = onRefresh;\r\n        runPreviewCallback = onRunPreview;\r\n\r\n        // Search bar\r\n        const searchInput = document.getElementById('outliner-search') as HTMLInputElement | null;\r\n        if (searchInput) {\r\n            searchInput.addEventListener('input', () => {\r\n                if (searchTimer) clearTimeout(searchTimer);\r\n                searchTimer = setTimeout(() => {\r\n                    searchQuery = searchInput.value;\r\n                    refresh();\r\n                }, SEARCH_DEBOUNCE_MS);\r\n            });\r\n        }\r\n\r\n        // Toolbar buttons\r\n        document.getElementById('outliner-btn-delete')?.addEventListener('click', deleteSelected);\r\n        document.getElementById('outliner-btn-select-all')?.addEventListener('click', selectAll);\r\n        document.getElementById('outliner-btn-deselect')?.addEventListener('click', deselectAll);\r\n        document.getElementById('outliner-btn-expand')?.addEventListener('click', expandAll);\r\n        document.getElementById('outliner-btn-collapse')?.addEventListener('click', collapseAll);\r\n    },\r\n\r\n    /**\r\n     * Re-render the outliner tree. Call whenever editor data changes.\r\n     */\r\n    refresh,\r\n\r\n    /**\r\n     * Check if an object is hidden by the outliner visibility toggle.\r\n     */\r\n    isHidden(obj: MapObject): boolean {\r\n        const key = `obj_${obj.id}_${Math.round(obj.x)}_${Math.round(obj.y)}`;\r\n        return !getItemState(key).visible;\r\n    },\r\n\r\n    /**\r\n     * Check if an object is locked by the outliner lock toggle.\r\n     */\r\n    isLocked(obj: MapObject): boolean {\r\n        const key = `obj_${obj.id}_${Math.round(obj.x)}_${Math.round(obj.y)}`;\r\n        return getItemState(key).locked;\r\n    },\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\dashboard\\src\\ResizePanels.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\dashboard\\src\\api-server.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'GAME_CONSTANTS_PATH' is assigned a value but never used.","line":23,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":23,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'parseBodyTypeConfig' is defined but never used.","line":678,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":678,"endColumn":29}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Dashboard API - TypeScript/Node.js Implementation\r\n *\r\n * Replaces the Python serve_dashboard.py with pure TypeScript.\r\n * Runs as Vite middleware for a single unified dev server.\r\n *\r\n * Reads entity data directly from src/entities/{category}/*.ts files.\r\n */\r\n\r\nimport fs from 'fs';\r\nimport path from 'path';\r\nimport { fileURLToPath } from 'url';\r\nimport type { ServerResponse } from 'http';\r\nimport type { Connect, ViteDevServer } from 'vite';\r\n\r\nconst __dirname = path.dirname(fileURLToPath(import.meta.url));\r\nconst BASE_DIR = path.resolve(__dirname, '../../..');\r\nconst TOOLS_DIR = path.resolve(BASE_DIR, 'tools');\r\nconst IMAGES_DIR = path.resolve(BASE_DIR, 'assets/images');\r\nconst ENTITIES_DIR = path.resolve(BASE_DIR, 'src/entities');\r\nconst MAPS_DIR = path.resolve(BASE_DIR, 'src/data/maps');\r\nconst PUBLIC_MAPS_DIR = path.resolve(BASE_DIR, 'public/maps');\r\nconst GAME_CONSTANTS_PATH = path.resolve(BASE_DIR, 'src/data/GameConstants.ts');\r\nconst GAME_CONFIG_PATH = path.resolve(BASE_DIR, 'src/data/GameConfig.ts');\r\nconst BODY_TYPE_CONFIG_PATH = path.resolve(BASE_DIR, 'src/config/BodyTypeConfig.ts');\r\n\r\n// Ensure maps directory exists\r\nif (!fs.existsSync(MAPS_DIR)) {\r\n    fs.mkdirSync(MAPS_DIR, { recursive: true });\r\n}\r\n\r\n// ============================================\r\n// UTILITY FUNCTIONS\r\n// ============================================\r\n\r\nfunction sendJson(res: ServerResponse, data: unknown): void {\r\n    const json = JSON.stringify(data);\r\n    res.setHeader('Content-Type', 'application/json');\r\n    res.setHeader('Access-Control-Allow-Origin', '*');\r\n    res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate');\r\n    res.setHeader('Pragma', 'no-cache');\r\n    res.setHeader('Expires', '0');\r\n    res.end(json);\r\n}\r\n\r\nfunction readJsonFile(filepath: string): unknown {\r\n    if (!fs.existsSync(filepath)) return null;\r\n    return JSON.parse(fs.readFileSync(filepath, 'utf-8'));\r\n}\r\n\r\nfunction writeJsonFile(filepath: string, data: unknown): void {\r\n    fs.writeFileSync(filepath, JSON.stringify(data, null, 2));\r\n}\r\n\r\nfunction saveImage(\r\n    relPath: string,\r\n    base64Data: string\r\n): { success: boolean; message?: string; error?: string } {\r\n    try {\r\n        // Validation\r\n        if (!relPath || relPath.includes('..')) return { success: false, error: 'Invalid path' };\r\n\r\n        let absPath;\r\n        // Normalize: paths like 'images/...' should map to 'assets/images/...'\r\n        // Paths like 'assets/images/...' stay as-is\r\n        if (relPath.startsWith('assets/')) {\r\n            absPath = path.join(BASE_DIR, relPath);\r\n        } else if (relPath.startsWith('images/')) {\r\n            // Map 'images/...' to 'assets/images/...'\r\n            absPath = path.join(BASE_DIR, 'assets', relPath);\r\n        } else {\r\n            // Assume it's a relative path within assets/images\r\n            absPath = path.join(BASE_DIR, 'assets/images', relPath);\r\n        }\r\n\r\n        console.log(`[API] Saving image: relPath='${relPath}' -> absPath='${absPath}'`);\r\n\r\n        // Ensure directory exists\r\n        const dir = path.dirname(absPath);\r\n        if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });\r\n\r\n        // Remove header if present (data:image/png;base64,...)\r\n        const base64Image = base64Data.split(';base64,').pop();\r\n        if (!base64Image) return { success: false, error: 'Invalid base64 data' };\r\n\r\n        fs.writeFileSync(absPath, base64Image, { encoding: 'base64' });\r\n        console.log(`[API] Saved image to ${absPath}`);\r\n        return { success: true, message: 'Image saved' };\r\n    } catch (e) {\r\n        console.error(`[API] Failed to save image:`, e);\r\n        return { success: false, error: String(e) };\r\n    }\r\n}\r\n\r\nfunction saveMap(\r\n    filename: string,\r\n    data: unknown\r\n): { success: boolean; message?: string; error?: string } {\r\n    try {\r\n        // Sanitize filename\r\n        const safeName = filename.replace(/[^a-zA-Z0-9_\\-.]/g, '_');\r\n        const filepath = path.join(\r\n            MAPS_DIR,\r\n            safeName.endsWith('.json') ? safeName : `${safeName}.json`\r\n        );\r\n\r\n        writeJsonFile(filepath, data);\r\n        if (safeName === 'default' || safeName === 'default.json') {\r\n            if (!fs.existsSync(PUBLIC_MAPS_DIR)) fs.mkdirSync(PUBLIC_MAPS_DIR, { recursive: true });\r\n            const publicPath = path.join(PUBLIC_MAPS_DIR, 'default.json');\r\n            fs.copyFileSync(filepath, publicPath);\r\n            console.log(`[API] Synced default map to ${publicPath}`);\r\n\r\n            // Auto-save backup\r\n            const backupPath = path.join(MAPS_DIR, 'default_backup.json');\r\n            writeJsonFile(backupPath, data);\r\n            const publicBackupPath = path.join(PUBLIC_MAPS_DIR, 'default_backup.json');\r\n            fs.copyFileSync(backupPath, publicBackupPath);\r\n            console.log(`[API] Synced backup map to ${publicBackupPath}`);\r\n        }\r\n        console.log(`[API] Saved map: ${safeName}`);\r\n        return { success: true, message: `Map saved to ${safeName}` };\r\n    } catch (e) {\r\n        console.error(`[API] Failed to save map:`, e);\r\n        return { success: false, error: String(e) };\r\n    }\r\n}\r\n\r\nfunction listMaps(): { success: boolean; maps?: string[]; error?: string } {\r\n    try {\r\n        if (!fs.existsSync(MAPS_DIR)) return { success: true, maps: [] };\r\n        const files = fs.readdirSync(MAPS_DIR);\r\n        const maps = files.filter((f) => f.endsWith('.json')).map((f) => f.replace(/\\.json$/, ''));\r\n        return { success: true, maps };\r\n    } catch (e) {\r\n        console.error(`[API] Failed to list maps:`, e);\r\n        return { success: false, error: String(e) };\r\n    }\r\n}\r\n\r\nfunction loadMap(filename: string): { success: boolean; data?: unknown; error?: string } {\r\n    try {\r\n        const safeName = filename.replace(/[^a-zA-Z0-9_\\-.]/g, '_');\r\n        const filepath = path.join(\r\n            MAPS_DIR,\r\n            safeName.endsWith('.json') ? safeName : `${safeName}.json`\r\n        );\r\n\r\n        if (!fs.existsSync(filepath)) {\r\n            return { success: false, error: 'Map not found' };\r\n        }\r\n        const data = readJsonFile(filepath);\r\n        return { success: true, data };\r\n    } catch (e) {\r\n        console.error(`[API] Failed to load map:`, e);\r\n        return { success: false, error: String(e) };\r\n    }\r\n}\r\n\r\nfunction deleteMap(filename: string): { success: boolean; error?: string } {\r\n    try {\r\n        const safeName = filename.replace(/[^a-zA-Z0-9_\\-.]/g, '_');\r\n        const filepath = path.join(\r\n            MAPS_DIR,\r\n            safeName.endsWith('.json') ? safeName : `${safeName}.json`\r\n        );\r\n\r\n        if (!fs.existsSync(filepath)) {\r\n            return { success: false, error: 'Map not found' };\r\n        }\r\n        fs.unlinkSync(filepath);\r\n        console.log(`[API] Deleted map: ${safeName}`);\r\n        return { success: true };\r\n    } catch (e) {\r\n        console.error(`[API] Failed to delete map:`, e);\r\n        return { success: false, error: String(e) };\r\n    }\r\n}\r\n\r\n// ============================================\r\n// TYPESCRIPT ENTITY PARSING\r\n// ============================================\r\n\r\ninterface EntityData {\r\n    id?: string;\r\n    name?: string;\r\n    status?: string;\r\n    files?: { original?: string; clean?: string };\r\n    _sourceFile?: string;\r\n    imageModifiedTime?: number;\r\n    sourceDescription?: string;\r\n    description?: string;\r\n    [key: string]: unknown;\r\n}\r\n\r\nfunction readTsEntity(filepath: string): EntityData | null {\r\n    try {\r\n        const content = fs.readFileSync(filepath, 'utf-8');\r\n\r\n        // Extract JSON object from: export default { ... } satisfies ...\r\n        let match = content.match(/export\\s+default\\s+(\\{[\\s\\S]*\\})\\s*satisfies/);\r\n        if (!match) {\r\n            // Try simpler pattern: export default { ... }; (with possible newline before ;)\r\n            match = content.match(/export\\s+default\\s+(\\{[\\s\\S]*\\})\\s*;?\\s*$/);\r\n        }\r\n        if (!match) {\r\n            // Try variable definition pattern: const entity: Type = { ... }; export default entity;\r\n            // We capture the object literal assigned to the variable\r\n            match = content.match(\r\n                /const\\s+\\w+\\s*(?::\\s*[^=]+)?\\s*=\\s*(\\{[\\s\\S]*?\\})\\s*;?[\\s\\n]*export\\s+default/\r\n            );\r\n        }\r\n\r\n        if (!match) return null;\r\n\r\n        const jsonStr = match[1];\r\n\r\n        try {\r\n            // Use Function constructor to parse JS object literal (handles single quotes, unquoted keys, etc.)\r\n            // This is safe because we're reading local trusted files\r\n            const parseFn = new Function(`return ${jsonStr};`);\r\n            const parsed = parseFn() as EntityData;\r\n\r\n            return parsed;\r\n        } catch (e) {\r\n            console.error(`[API] Failed to parse entity ${filepath}:`, e);\r\n            return null;\r\n        }\r\n    } catch (e) {\r\n        console.error(`[API] Failed to read file ${filepath}:`, e);\r\n        return null;\r\n    }\r\n}\r\n\r\nfunction writeTsEntity(filepath: string, entity: EntityData): void {\r\n    // Determine entity type from category\r\n    const relPath = path.relative(ENTITIES_DIR, filepath);\r\n    const category = relPath.split(path.sep)[0];\r\n\r\n    const typeMap: Record<string, string> = {\r\n        enemies: 'EnemyEntity',\r\n        bosses: 'BossEntity',\r\n        equipment: 'EquipmentEntity',\r\n        items: 'ItemEntity',\r\n        resources: 'ResourceEntity',\r\n        nodes: 'NodeEntity',\r\n        environment: 'EnvironmentEntity',\r\n        npcs: 'NPCEntity',\r\n        hero: 'HeroEntity',\r\n        ui: 'UIEntity'\r\n    };\r\n    const entityType = typeMap[category] || 'BaseEntity';\r\n\r\n    const jsonStr = JSON.stringify(entity, null, 4);\r\n    const tsContent = `/**\r\n * Entity: ${entity.id || 'unknown'}\r\n * Auto-generated. Edit in dashboard.\r\n */\r\nimport type { ${entityType} } from '@types/entities';\r\n\r\nexport default ${jsonStr} satisfies ${entityType};\r\n`;\r\n\r\n    fs.writeFileSync(filepath, tsContent);\r\n}\r\n\r\nfunction findEntityFile(category: string, itemId: string): string | null {\r\n    const catDir = path.join(ENTITIES_DIR, category);\r\n    if (!fs.existsSync(catDir)) return null;\r\n\r\n    // Direct path\r\n    const directPath = path.join(catDir, `${itemId}.ts`);\r\n    if (fs.existsSync(directPath)) return directPath;\r\n\r\n    // Try with enemy_ prefix\r\n    if (category === 'enemies' || category === 'bosses') {\r\n        const prefixedPath = path.join(catDir, `enemy_${itemId}.ts`);\r\n        if (fs.existsSync(prefixedPath)) return prefixedPath;\r\n    }\r\n\r\n    // Search all files recursively\r\n    const searchDir = (dir: string): string | null => {\r\n        const entries = fs.readdirSync(dir, { withFileTypes: true });\r\n        for (const entry of entries) {\r\n            const fullPath = path.join(dir, entry.name);\r\n            if (entry.isDirectory()) {\r\n                const found = searchDir(fullPath);\r\n                if (found) return found;\r\n            } else if (entry.name.endsWith('.ts') && entry.name !== 'index.ts') {\r\n                const entity = readTsEntity(fullPath);\r\n                if (entity && entity.id === itemId) {\r\n                    return fullPath;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n\r\n    return searchDir(catDir);\r\n}\r\n\r\n// ============================================\r\n// CATEGORY HANDLERS\r\n// ============================================\r\n\r\nconst CATEGORIES = [\r\n    'enemies',\r\n    'bosses',\r\n    'npcs',\r\n    'equipment',\r\n    'items',\r\n    'resources',\r\n    'environment',\r\n    'ground',\r\n    'nodes',\r\n    'ui',\r\n    'hero'\r\n];\r\n\r\nfunction getManifest(): { categories: Record<string, { name: string; count: number }> } {\r\n    const categories: Record<string, { name: string; count: number }> = {};\r\n\r\n    for (const cat of CATEGORIES) {\r\n        const catDir = path.join(ENTITIES_DIR, cat);\r\n        let count = 0;\r\n\r\n        if (fs.existsSync(catDir)) {\r\n            const countFiles = (dir: string): number => {\r\n                let c = 0;\r\n                const entries = fs.readdirSync(dir, { withFileTypes: true });\r\n                for (const entry of entries) {\r\n                    if (entry.isDirectory()) {\r\n                        c += countFiles(path.join(dir, entry.name));\r\n                    } else if (entry.name.endsWith('.ts') && entry.name !== 'index.ts') {\r\n                        c++;\r\n                    }\r\n                }\r\n                return c;\r\n            };\r\n            count = countFiles(catDir);\r\n        }\r\n\r\n        categories[cat] = {\r\n            name: cat.charAt(0).toUpperCase() + cat.slice(1),\r\n            count\r\n        };\r\n    }\r\n\r\n    return { categories };\r\n}\r\n\r\nfunction getCategoryData(category: string): {\r\n    files: Record<string, EntityData[]>;\r\n    category: string;\r\n    entities: EntityData[];\r\n} {\r\n    if (!category) {\r\n        return { files: {}, category: category || 'unknown', entities: [] };\r\n    }\r\n    const catDir = path.join(ENTITIES_DIR, category);\r\n\r\n    if (!fs.existsSync(catDir)) {\r\n        return { files: {}, category, entities: [] };\r\n    }\r\n\r\n    const entities: EntityData[] = [];\r\n\r\n    const collectEntities = (dir: string): void => {\r\n        const entries = fs.readdirSync(dir, { withFileTypes: true });\r\n        for (const entry of entries) {\r\n            const fullPath = path.join(dir, entry.name);\r\n            if (entry.isDirectory()) {\r\n                collectEntities(fullPath);\r\n            } else if (entry.name.endsWith('.ts') && entry.name !== 'index.ts') {\r\n                const entity = readTsEntity(fullPath);\r\n                if (entity) {\r\n                    if (!entity.status) entity.status = 'pending';\r\n                    entity._sourceFile = entry.name.replace('.ts', '');\r\n\r\n                    // Get image modified time\r\n                    const filesDict = entity.files || {};\r\n                    const originalPath = filesDict.original || filesDict.clean || '';\r\n                    if (originalPath) {\r\n                        let absPath = originalPath;\r\n                        if (\r\n                            originalPath.startsWith('assets/') ||\r\n                            originalPath.startsWith('images/')\r\n                        ) {\r\n                            absPath = path.join(BASE_DIR, originalPath);\r\n                        } else {\r\n                            absPath = path.join(BASE_DIR, 'assets', originalPath);\r\n                        }\r\n                        if (fs.existsSync(absPath)) {\r\n                            entity.imageModifiedTime = Math.floor(fs.statSync(absPath).mtimeMs);\r\n                        } else {\r\n                            entity.imageModifiedTime = 0;\r\n                        }\r\n                    } else {\r\n                        entity.imageModifiedTime = 0;\r\n                    }\r\n\r\n                    // Fallback for sourceDescription\r\n                    if (!entity.sourceDescription) {\r\n                        entity.sourceDescription =\r\n                            (entity.description as string) || (entity.name as string) || '';\r\n                    }\r\n\r\n                    entities.push(entity);\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    collectEntities(catDir);\r\n\r\n    // Group by sourceFile for backward compatibility\r\n    const files: Record<string, EntityData[]> = {};\r\n    for (const entity of entities) {\r\n        injectImplicitData(entity, category);\r\n        const sourceFile = (entity.sourceFile as string) || category;\r\n        if (!files[sourceFile]) files[sourceFile] = [];\r\n        files[sourceFile].push(entity);\r\n\r\n        if (entity.id === 'node_mining_t1_01') {\r\n            console.log('[API Debug] Sending entity node_mining_t1_01:', JSON.stringify(entity));\r\n        }\r\n    }\r\n\r\n    return { files, category, entities };\r\n}\r\n\r\nfunction injectImplicitData(entity: EntityData, category: string) {\r\n    if (!entity.sfx) entity.sfx = {};\r\n    const sfx = entity.sfx as Record<string, string>;\r\n\r\n    // Nodes: mine, break, respawn\r\n    if (category === 'nodes') {\r\n        const id = entity.id || 'unknown';\r\n        if (!sfx.mine) sfx.mine = `sfx_mine_${id}`;\r\n        if (!sfx.break) sfx.break = `sfx_resource_break_${id}`;\r\n        if (!sfx.respawn) sfx.respawn = `sfx_respawn_${id}`;\r\n    }\r\n\r\n    // Items/Resources: pickup, drop\r\n    if (category === 'items' || category === 'resources') {\r\n        if (!sfx.pickup) sfx.pickup = 'sfx_resource_collect'; // Generic fallback\r\n        if (!sfx.drop) sfx.drop = 'sfx_item_drop_light';\r\n    }\r\n\r\n    // Equipment: equip, use\r\n    if (category === 'equipment') {\r\n        const isWeapon =\r\n            entity.slot === 'weapon' || (entity.id && (entity.id as string).includes('tool'));\r\n        if (!sfx.equip) sfx.equip = isWeapon ? 'sfx_equip_weapon' : 'sfx_equip_armor';\r\n\r\n        if (isWeapon && !sfx.use) {\r\n            // Check for specific weapon type if available\r\n            const weaponType = (entity.weaponType as string) || 'sword';\r\n            sfx.use = `sfx_weapon_swing`; // Generic or specific based on type?\r\n            // Actually game uses sfx_hero_swing usually, but individual weapons might want overrides\r\n            // Let's suggest specific convention\r\n            if (!sfx.use) sfx.use = `sfx_weapon_swing_${weaponType}`;\r\n        }\r\n    }\r\n\r\n    // NPCs: greet, buy\r\n    if (category === 'npcs') {\r\n        if (!sfx.greet) sfx.greet = 'sfx_npc_greet';\r\n        if (!sfx.buy) sfx.buy = 'sfx_npc_buy';\r\n    }\r\n}\r\n\r\nfunction updateCategoryStatus(\r\n    category: string,\r\n    _file: string,\r\n    id: string,\r\n    status: string,\r\n    note?: string\r\n): { success: boolean; message?: string; error?: string } {\r\n    const entityPath = findEntityFile(category, id);\r\n    if (!entityPath) {\r\n        return { success: false, error: `Entity not found: ${id}` };\r\n    }\r\n\r\n    const entity = readTsEntity(entityPath);\r\n    if (!entity) {\r\n        return { success: false, error: `Could not parse entity: ${id}` };\r\n    }\r\n\r\n    entity.status = status;\r\n    if (note) {\r\n        entity.declineNote = note;\r\n    } else if (status !== 'declined' && entity.declineNote) {\r\n        delete entity.declineNote;\r\n    }\r\n\r\n    writeTsEntity(entityPath, entity);\r\n    console.log(`[API] Updated ${id} status = ${status}`);\r\n    return { success: true, message: `Updated ${id} to ${status}` };\r\n}\r\n\r\nfunction updateEntity(\r\n    category: string,\r\n    _file: string,\r\n    id: string,\r\n    updates: Record<string, unknown>\r\n): { success: boolean; message?: string; error?: string } {\r\n    const entityPath = findEntityFile(category, id);\r\n    if (!entityPath) {\r\n        return { success: false, error: `Entity not found: ${id}` };\r\n    }\r\n\r\n    const entity = readTsEntity(entityPath);\r\n    if (!entity) {\r\n        return { success: false, error: `Could not parse entity: ${id}` };\r\n    }\r\n\r\n    for (const [field, value] of Object.entries(updates)) {\r\n        if (field.includes('.')) {\r\n            const [parent, child] = field.split('.', 2);\r\n            if (!entity[parent]) entity[parent] = {};\r\n            (entity[parent] as Record<string, unknown>)[child] = value;\r\n        } else if (value === null && field in entity) {\r\n            delete entity[field];\r\n        } else {\r\n            entity[field] = value;\r\n        }\r\n    }\r\n\r\n    writeTsEntity(entityPath, entity);\r\n    console.log(`[API] Updated ${id}: ${Object.keys(updates).join(', ')}`);\r\n    return { success: true, message: `Updated ${id}` };\r\n}\r\n\r\n// ============================================\r\n// SFX QUEUE HANDLERS\r\n// ============================================\r\n\r\nfunction getSfxQueue(): { queue: unknown[]; lastUpdated: string | null } {\r\n    const queueFile = path.join(TOOLS_DIR, 'sfx_regeneration_queue.json');\r\n    const data = readJsonFile(queueFile) as { queue: unknown[]; lastUpdated: string } | null;\r\n    return data || { queue: [], lastUpdated: null };\r\n}\r\n\r\nfunction saveSfxQueue(queue: unknown[]): { success: boolean; message: string } {\r\n    const queueFile = path.join(TOOLS_DIR, 'sfx_regeneration_queue.json');\r\n    const data = {\r\n        queue,\r\n        lastUpdated: new Date().toISOString(),\r\n        note: 'SFX marked for regeneration'\r\n    };\r\n    writeJsonFile(queueFile, data);\r\n    return { success: true, message: `Saved ${queue.length} items` };\r\n}\r\n\r\n// ============================================\r\n// NOTES & PROMPTS HANDLERS\r\n// ============================================\r\n\r\nfunction getNotes(): Record<string, string> {\r\n    const notesFile = path.join(TOOLS_DIR, 'decline_notes.json');\r\n    return (readJsonFile(notesFile) as Record<string, string>) || {};\r\n}\r\n\r\nfunction saveNotes(assetName: string, notes: string): { success: boolean } {\r\n    const notesFile = path.join(TOOLS_DIR, 'decline_notes.json');\r\n    const existing = getNotes();\r\n    existing[assetName] = notes;\r\n    writeJsonFile(notesFile, existing);\r\n    return { success: true };\r\n}\r\n\r\nfunction getPrompts(): Record<string, unknown> {\r\n    const promptsFile = path.join(TOOLS_DIR, 'asset_prompts.json');\r\n    return (readJsonFile(promptsFile) as Record<string, unknown>) || {};\r\n}\r\n\r\nfunction savePrompts(prompts: Record<string, unknown>): { success: boolean } {\r\n    const promptsFile = path.join(TOOLS_DIR, 'asset_prompts.json');\r\n    writeJsonFile(promptsFile, prompts);\r\n    return { success: true };\r\n}\r\n\r\n// ============================================\r\n// CONFIG HANDLERS\r\n// ============================================\r\n\r\ninterface ConfigSection {\r\n    [key: string]: unknown;\r\n}\r\n\r\ninterface GameConfig {\r\n    [key: string]: ConfigSection | unknown;\r\n}\r\n\r\nfunction extractSectionContent(content: string, section: string): string | null {\r\n    const sectionStart = content.indexOf(`${section}:`);\r\n    if (sectionStart === -1) return null;\r\n    const openBrace = content.indexOf('{', sectionStart);\r\n    if (openBrace === -1) return null;\r\n    let depth = 1,\r\n        pos = openBrace + 1;\r\n    while (depth > 0 && pos < content.length) {\r\n        if (content[pos] === '{') depth++;\r\n        else if (content[pos] === '}') depth--;\r\n        pos++;\r\n    }\r\n    if (depth !== 0) return null;\r\n    return content.substring(openBrace + 1, pos - 1);\r\n}\r\n\r\nfunction parseGameConfig(): Partial<GameConfig> {\r\n    if (!fs.existsSync(GAME_CONFIG_PATH)) return {};\r\n    const content = fs.readFileSync(GAME_CONFIG_PATH, 'utf-8');\r\n    const result: Partial<GameConfig> = {};\r\n\r\n    // 1. Find DEFAULTS block\r\n    const defaultsStart = content.indexOf('const DEFAULTS = {');\r\n    if (defaultsStart === -1) return {};\r\n\r\n    // 2. Discover sections by looking for \"Key: {\" pattern inside DEFAULTS\r\n    // We assume standard formatting (Key: {) with 4 spaces indentation for top-level\r\n    const sections: string[] = [];\r\n    const sectionRegex = /^ {4}(\\w+):\\s*\\{/gm;\r\n\r\n    // Limit search to the DEFAULTS block to avoid false positives\r\n    // Extract block roughly\r\n    let braceCount = 0;\r\n    let blockEndIndex = defaultsStart;\r\n    let foundFirstBrace = false;\r\n\r\n    for (let i = defaultsStart; i < content.length; i++) {\r\n        if (content[i] === '{') {\r\n            braceCount++;\r\n            foundFirstBrace = true;\r\n        } else if (content[i] === '}') {\r\n            braceCount--;\r\n        }\r\n\r\n        if (foundFirstBrace && braceCount === 0) {\r\n            blockEndIndex = i;\r\n            break;\r\n        }\r\n    }\r\n\r\n    const defaultsBlock = content.substring(defaultsStart, blockEndIndex + 1);\r\n\r\n    let match;\r\n    while ((match = sectionRegex.exec(defaultsBlock)) !== null) {\r\n        sections.push(match[1]);\r\n    }\r\n\r\n    console.log('[API] Discovered config sections:', sections);\r\n\r\n    for (const section of sections) {\r\n        const sectionContent = extractSectionContent(content, section);\r\n\r\n        if (sectionContent) {\r\n            try {\r\n                // Convert to valid JSON\r\n                let jsonStr = '{' + sectionContent + '}';\r\n                // Remove comments\r\n                jsonStr = jsonStr.replace(/\\/\\/.*$/gm, '');\r\n                // Add quotes to keys\r\n                jsonStr = jsonStr.replace(/(\\w+):/g, '\"$1\":');\r\n                // Remove trailing commas\r\n                jsonStr = jsonStr.replace(/,(\\s*[}\\]])/g, '$1');\r\n                result[section as keyof GameConfig] = JSON.parse(jsonStr);\r\n            } catch (e) {\r\n                console.log(`[Config] Failed to parse section: ${section}`, e);\r\n            }\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nfunction parseBodyTypeConfig(): Record<string, { scale: number }> {\r\n    if (!fs.existsSync(BODY_TYPE_CONFIG_PATH)) return {};\r\n\r\n    const content = fs.readFileSync(BODY_TYPE_CONFIG_PATH, 'utf-8');\r\n    const result: Record<string, { scale: number }> = {};\r\n\r\n    // Match: bodyType: { scale: number }\r\n    const matches = content.matchAll(/(\\w+):\\s*\\{\\s*scale:\\s*([\\d.]+)\\s*\\}/g);\r\n    for (const match of matches) {\r\n        result[match[1]] = { scale: parseFloat(match[2]) };\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nfunction getConfig(): GameConfig {\r\n    const config = parseGameConfig();\r\n\r\n    // cast to any to allow dynamic keys\r\n    return config as GameConfig;\r\n}\r\n\r\nfunction updateConfigValue(\r\n    section: string,\r\n    key: string,\r\n    value: unknown\r\n): { success: boolean; message?: string; error?: string } {\r\n    console.log(\r\n        `[Config] updateConfigValue called: section='${section}', key='${key}', value='${value}'`\r\n    );\r\n    try {\r\n        if (section === 'BodyTypes') {\r\n            // Update BodyTypeConfig.ts\r\n            let content = fs.readFileSync(BODY_TYPE_CONFIG_PATH, 'utf-8');\r\n            const regex = new RegExp(`(${key}:\\\\s*\\\\{\\\\s*scale:\\\\s*)([\\\\d.]+)(\\\\s*\\\\})`, 'g');\r\n            content = content.replace(regex, `$1${value}$3`);\r\n            fs.writeFileSync(BODY_TYPE_CONFIG_PATH, content);\r\n            console.log(`[Config] Updated BodyTypes.${key} = ${value}`);\r\n        } else if (section === 'WeaponDefaults') {\r\n            // Handle nested weapon keys like 'sword.range'\r\n            let content = fs.readFileSync(GAME_CONFIG_PATH, 'utf-8');\r\n            const [weaponType, stat] = key.split('.');\r\n            const keyRegex = new RegExp(`(${weaponType}:\\\\s*\\\\{[^}]*${stat}:\\\\s*)([\\\\d.]+)`, 'g');\r\n            content = content.replace(keyRegex, `$1${value}`);\r\n            fs.writeFileSync(GAME_CONFIG_PATH, content);\r\n            console.log(`[Config] Updated WeaponDefaults.${key} = ${value}`);\r\n        } else {\r\n            // Update GameConfig.ts\r\n            let content = fs.readFileSync(GAME_CONFIG_PATH, 'utf-8');\r\n\r\n            // Match the key within the section\r\n            const keyRegex = new RegExp(`(${key}:\\\\s*)([^,\\\\n]+)`, 'g');\r\n            content = content.replace(keyRegex, `$1${value}`);\r\n\r\n            fs.writeFileSync(GAME_CONFIG_PATH, content);\r\n            console.log(`[Config] Updated ${section}.${key} = ${value}`);\r\n        }\r\n\r\n        return { success: true, message: `Updated ${section}.${key}` };\r\n    } catch (error) {\r\n        return { success: false, error: String(error) };\r\n    }\r\n}\r\n\r\nfunction resetConfigSection(section: string): {\r\n    success: boolean;\r\n    message?: string;\r\n    error?: string;\r\n} {\r\n    console.log(`[Config] Resetting section: ${section}`);\r\n    try {\r\n        let content = fs.readFileSync(GAME_CONFIG_PATH, 'utf-8');\r\n\r\n        // Find the section in DEFAULTS and copy values to the live config\r\n        const defaultsMatch = content.match(\r\n            new RegExp(`DEFAULTS\\\\s*=\\\\s*\\\\{[\\\\s\\\\S]*?${section}:\\\\s*\\\\{([^}]+)\\\\}`)\r\n        );\r\n        if (!defaultsMatch) {\r\n            return { success: false, error: `Section ${section} not found in DEFAULTS` };\r\n        }\r\n\r\n        // Parse default values\r\n        const defaultContent = defaultsMatch[1];\r\n        const keyValuePairs = defaultContent.matchAll(/(\\w+):\\s*([^,\\n]+)/g);\r\n\r\n        for (const match of keyValuePairs) {\r\n            const key = match[1];\r\n            const defaultValue = match[2].trim();\r\n            // Update live section with default value\r\n            const keyRegex = new RegExp(`(${section}:[\\\\s\\\\S]*?${key}:\\\\s*)([^,\\\\n]+)`, 'g');\r\n            content = content.replace(keyRegex, `$1${defaultValue}`);\r\n        }\r\n\r\n        fs.writeFileSync(GAME_CONFIG_PATH, content);\r\n        return { success: true, message: `Reset ${section} to defaults` };\r\n    } catch (error) {\r\n        return { success: false, error: String(error) };\r\n    }\r\n}\r\n\r\nfunction saveConfigDefaults(section: string): {\r\n    success: boolean;\r\n    message?: string;\r\n    error?: string;\r\n} {\r\n    console.log(`[Config] Saving ${section} as new defaults`);\r\n    try {\r\n        let content = fs.readFileSync(GAME_CONFIG_PATH, 'utf-8');\r\n\r\n        // Find current values in the live section\r\n        const sectionContent = extractSectionContent(content, section);\r\n        if (!sectionContent) {\r\n            return { success: false, error: `Section ${section} not found` };\r\n        }\r\n\r\n        // Parse current values and update DEFAULTS\r\n        const keyValuePairs = sectionContent.matchAll(/(\\w+):\\s*([^,\\n}]+)/g);\r\n\r\n        for (const match of keyValuePairs) {\r\n            const key = match[1];\r\n            const currentValue = match[2].trim();\r\n            // Update DEFAULTS section with current value\r\n            const defaultKeyRegex = new RegExp(\r\n                `(DEFAULTS\\\\s*=[\\\\s\\\\S]*?${section}:[\\\\s\\\\S]*?${key}:\\\\s*)([^,\\\\n}]+)`,\r\n                'g'\r\n            );\r\n            content = content.replace(defaultKeyRegex, `$1${currentValue}`);\r\n        }\r\n\r\n        fs.writeFileSync(GAME_CONFIG_PATH, content);\r\n        return { success: true, message: `Saved ${section} as new defaults` };\r\n    } catch (error) {\r\n        return { success: false, error: String(error) };\r\n    }\r\n}\r\n\r\n// ============================================\r\n// ASSET SYNC\r\n// ============================================\r\n\r\nfunction syncAssetsToGame(): { success: boolean; message: string } {\r\n    console.log('[API] Sync assets to game requested');\r\n    return { success: true, message: 'Asset sync initiated' };\r\n}\r\n\r\n// ============================================\r\n// VITE MIDDLEWARE PLUGIN\r\n// ============================================\r\n\r\nasync function parseBody(req: Connect.IncomingMessage): Promise<Record<string, unknown>> {\r\n    return new Promise((resolve) => {\r\n        let body = '';\r\n        req.on('data', (chunk) => (body += chunk));\r\n        req.on('end', () => {\r\n            try {\r\n                resolve(body ? JSON.parse(body) : {});\r\n            } catch {\r\n                resolve({});\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\nexport function dashboardApiPlugin() {\r\n    return {\r\n        name: 'dashboard-api',\r\n        configureServer(server: ViteDevServer) {\r\n            // Redirect /tools/dashboard -> /dashboard so the browser uses /dashboard/ as base.\r\n            // All module requests become /dashboard/src/... and get rewritten to /tools/dashboard/src/...\r\n            const rewrite = (req: { url?: string }, res: ServerResponse, next: () => void) => {\r\n                const url = (req.url || '').split('?')[0];\r\n                const query = (req.url || '').includes('?') ? (req.url || '').slice((req.url || '').indexOf('?')) : '';\r\n                if (url === '/tools/dashboard' || url === '/tools/dashboard/' || url.startsWith('/tools/dashboard/')) {\r\n                    const target = '/dashboard' + url.slice('/tools/dashboard'.length) + query;\r\n                    res.statusCode = 302;\r\n                    res.setHeader('Location', target);\r\n                    res.end();\r\n                    return;\r\n                }\r\n                if (url === '/dashboard' || url === '/dashboard/' || url.startsWith('/dashboard/')) {\r\n                    req.url = req.url!.replace(/^\\/dashboard/, '/tools/dashboard');\r\n                }\r\n                next();\r\n            };\r\n            const stack = (server.middlewares as { stack?: unknown[] }).stack;\r\n            if (Array.isArray(stack)) {\r\n                stack.unshift({ route: '', handle: rewrite });\r\n            } else {\r\n                server.middlewares.use(rewrite);\r\n            }\r\n\r\n            // Handle API routes\r\n            server.middlewares.use(async (req, res, next) => {\r\n                const url = req.url || '';\r\n\r\n                // Only handle /api/* routes\r\n                if (!url.startsWith('/api')) {\r\n                    return next();\r\n                }\r\n\r\n                console.log(`[API] ${req.method} ${url}`);\r\n\r\n                try {\r\n                    // GET endpoints\r\n                    if (req.method === 'GET') {\r\n                        if (url === '/api/manifest') {\r\n                            return sendJson(res, getManifest());\r\n                        }\r\n                        if (url === '/api/get_sfx_queue') {\r\n                            return sendJson(res, getSfxQueue());\r\n                        }\r\n                        if (url === '/api/get_notes') {\r\n                            return sendJson(res, getNotes());\r\n                        }\r\n                        if (url === '/api/get_prompts') {\r\n                            return sendJson(res, getPrompts());\r\n                        }\r\n                        if (url === '/api/config') {\r\n                            return sendJson(res, getConfig());\r\n                        }\r\n                        if (url === '/api/list_maps') {\r\n                            return sendJson(res, listMaps());\r\n                        }\r\n                        if (url.startsWith('/api/load_map')) {\r\n                            const parsed = new URL(\r\n                                url,\r\n                                `http://${req.headers.host || 'localhost'}`\r\n                            );\r\n                            const filename = parsed.searchParams.get('filename') || '';\r\n                            return sendJson(res, loadMap(filename));\r\n                        }\r\n                    }\r\n\r\n                    // POST endpoints\r\n                    if (req.method === 'POST') {\r\n                        const data = await parseBody(req);\r\n                        const apiPath = url.split('?')[0];\r\n\r\n                        if (apiPath === '/api/get_category') {\r\n                            return sendJson(res, getCategoryData(data.category as string));\r\n                        }\r\n                        if (apiPath === '/api/update_category_status') {\r\n                            return sendJson(\r\n                                res,\r\n                                updateCategoryStatus(\r\n                                    data.category as string,\r\n                                    data.file as string,\r\n                                    data.id as string,\r\n                                    data.status as string,\r\n                                    data.note as string | undefined\r\n                                )\r\n                            );\r\n                        }\r\n                        if (apiPath === '/api/update_entity') {\r\n                            return sendJson(\r\n                                res,\r\n                                updateEntity(\r\n                                    data.category as string,\r\n                                    data.file as string,\r\n                                    data.id as string,\r\n                                    data.updates as Record<string, unknown>\r\n                                )\r\n                            );\r\n                        }\r\n                        if (apiPath === '/api/save_sfx_regen_queue') {\r\n                            return sendJson(res, saveSfxQueue(data.queue as unknown[]));\r\n                        }\r\n                        if (apiPath === '/api/save_notes') {\r\n                            return sendJson(\r\n                                res,\r\n                                saveNotes(data.assetName as string, data.notes as string)\r\n                            );\r\n                        }\r\n                        if (apiPath === '/api/save_prompts') {\r\n                            return sendJson(res, savePrompts(data));\r\n                        }\r\n                        if (apiPath === '/api/sync_assets' || apiPath === '/api/sync_to_game') {\r\n                            return sendJson(res, syncAssetsToGame());\r\n                        }\r\n                        if (apiPath === '/api/get_all_categories') {\r\n                            const result: Record<string, unknown> = {};\r\n                            for (const cat of CATEGORIES) {\r\n                                result[cat] = getCategoryData(cat);\r\n                            }\r\n                            return sendJson(res, result);\r\n                        }\r\n                        if (apiPath === '/api/update_config') {\r\n                            return sendJson(\r\n                                res,\r\n                                updateConfigValue(\r\n                                    data.section as string,\r\n                                    data.key as string,\r\n                                    data.value\r\n                                )\r\n                            );\r\n                        }\r\n                        if (apiPath === '/api/reset_config_section') {\r\n                            return sendJson(res, resetConfigSection(data.section as string));\r\n                        }\r\n                        if (apiPath === '/api/save_config_defaults') {\r\n                            return sendJson(res, saveConfigDefaults(data.section as string));\r\n                        }\r\n                        if (apiPath === '/api/save_map') {\r\n                            return sendJson(res, saveMap(data.filename as string, data.mapData));\r\n                        }\r\n                        if (apiPath === '/api/delete_map') {\r\n                            return sendJson(res, deleteMap(data.filename as string));\r\n                        }\r\n                        if (apiPath === '/api/upload_image') {\r\n                            return sendJson(\r\n                                res,\r\n                                saveImage(data.path as string, data.image as string)\r\n                            );\r\n                        }\r\n                    }\r\n\r\n                    // OPTIONS for CORS\r\n                    if (req.method === 'OPTIONS') {\r\n                        res.setHeader('Access-Control-Allow-Origin', '*');\r\n                        res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');\r\n                        res.setHeader('Access-Control-Allow-Headers', 'Content-Type');\r\n                        res.statusCode = 204;\r\n                        return res.end();\r\n                    }\r\n\r\n                    // Not found\r\n                    res.statusCode = 404;\r\n                    return sendJson(res, { error: 'Not found' });\r\n                } catch (error) {\r\n                    console.error('[API] Error:', error);\r\n                    res.statusCode = 500;\r\n                    return sendJson(res, { success: false, error: String(error) });\r\n                }\r\n            });\r\n\r\n            // Serve images from assets/images\r\n            server.middlewares.use('/images', (req, res, next) => {\r\n                const urlPath = (req.url || '').split('?')[0].replace(/^\\//, ''); // Strip query + leading slash\r\n                const imagePath = path.join(IMAGES_DIR, urlPath);\r\n                if (fs.existsSync(imagePath)) {\r\n                    const ext = path.extname(imagePath).toLowerCase();\r\n                    const mimeTypes: Record<string, string> = {\r\n                        '.png': 'image/png',\r\n                        '.jpg': 'image/jpeg',\r\n                        '.jpeg': 'image/jpeg',\r\n                        '.gif': 'image/gif',\r\n                        '.webp': 'image/webp'\r\n                    };\r\n                    res.setHeader('Content-Type', mimeTypes[ext] || 'application/octet-stream');\r\n                    fs.createReadStream(imagePath).pipe(res);\r\n                } else {\r\n                    next();\r\n                }\r\n            });\r\n        }\r\n    };\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\dashboard\\src\\api.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setManifest' is defined but never used.","line":7,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":16,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"setManifest"},"fix":{"range":[90,102],"text":""},"desc":"Remove unused variable \"setManifest\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setDeclineNotes' is defined but never used.","line":8,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":20,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"setDeclineNotes"},"fix":{"range":[101,123],"text":""},"desc":"Remove unused variable \"setDeclineNotes\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setAssetPrompts' is defined but never used.","line":9,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":20,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"setAssetPrompts"},"fix":{"range":[123,145],"text":""},"desc":"Remove unused variable \"setAssetPrompts\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setMissingAssets' is defined but never used.","line":10,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":21,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"setMissingAssets"},"fix":{"range":[145,168],"text":""},"desc":"Remove unused variable \"setMissingAssets\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setCategoryData' is defined but never used.","line":11,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":20,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"setCategoryData"},"fix":{"range":[168,190],"text":""},"desc":"Remove unused variable \"setCategoryData\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setCurrentCategoryName' is defined but never used.","line":12,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":27,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"setCurrentCategoryName"},"fix":{"range":[190,219],"text":""},"desc":"Remove unused variable \"setCurrentCategoryName\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'currentCategoryName' is defined but never used.","line":19,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":24,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"currentCategoryName"},"fix":{"range":[374,400],"text":""},"desc":"Remove unused variable \"currentCategoryName\"."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Dashboard API Module\r\n * All server communication functions\r\n */\r\n\r\nimport {\r\n    setManifest,\r\n    setDeclineNotes,\r\n    setAssetPrompts,\r\n    setMissingAssets,\r\n    setCategoryData,\r\n    setCurrentCategoryName,\r\n    globalAssetLookup,\r\n    setGlobalAssetLookup,\r\n    setLootSourceMap,\r\n    setRecipeUsageMap,\r\n    sfxRegenerationQueue,\r\n    setSfxRegenerationQueue,\r\n    currentCategoryName,\r\n    categoryData,\r\n    type AssetItem,\r\n    type CategoryData,\r\n    type AssetInfo,\r\n} from './state';\r\nimport { renderCategoryView } from './categoryRenderer';\r\n\r\n// ============================================\r\n// BROADCAST CHANNEL\r\n// ============================================\r\n\r\n// Channel for sending updates to the game window\r\nconst entityChannel = new BroadcastChannel('game-entity-updates');\r\n\r\nfunction broadcastUpdate(category: string, id: string, updates: Record<string, unknown>) {\r\n    console.log(`[Dashboard] Broadcasting update for ${category}/${id}`, updates);\r\n    entityChannel.postMessage({\r\n        type: 'ENTITY_UPDATE',\r\n        category,\r\n        id,\r\n        updates\r\n    });\r\n}\r\n\r\n// ============================================\r\n// API FUNCTIONS\r\n// ============================================\r\n\r\nexport async function fetchCategory(categoryName: string): Promise<CategoryData> {\r\n    const response = await fetch('/api/get_category', {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify({ category: categoryName }),\r\n    });\r\n    return response.json();\r\n}\r\n\r\nexport async function fetchEntities(): Promise<unknown> {\r\n    const response = await fetch('/api/get_entities', {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify({}),\r\n    });\r\n    return response.json();\r\n}\r\n\r\nexport async function changeStatus(path: string, newStatus: string): Promise<void> {\r\n    await fetch('/api/change_status', {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify({ path, newStatus }),\r\n    });\r\n}\r\n\r\nexport async function saveNotes(assetName: string, notes: string): Promise<void> {\r\n    await fetch('/api/save_notes', {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify({ name: assetName, notes }),\r\n    });\r\n}\r\n\r\nexport async function fetchPrompts(): Promise<Record<string, string>> {\r\n    const response = await fetch('/api/get_prompts');\r\n    return response.json();\r\n}\r\n\r\nexport async function saveAssetPrompt(assetId: string, prompt: string): Promise<void> {\r\n    await fetch('/api/save_prompts', {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify({ [assetId]: prompt }),\r\n    });\r\n}\r\n\r\nexport async function updateCategoryStatus(\r\n    category: string,\r\n    fileName: string,\r\n    itemId: string,\r\n    newStatus: string,\r\n    note = ''\r\n): Promise<void> {\r\n    try {\r\n        const response = await fetch('/api/update_entity', {\r\n            method: 'POST',\r\n            headers: { 'Content-Type': 'application/json' },\r\n            body: JSON.stringify({\r\n                category,\r\n                file: fileName,\r\n                id: itemId,\r\n                updates: { status: newStatus, declineNote: note },\r\n            }),\r\n        });\r\n        const result = await response.json();\r\n\r\n        if (result.success) {\r\n            // Update local state\r\n            const files = categoryData?.files;\r\n            if (files && files[fileName]) {\r\n                const item = files[fileName].find((i) => i.id === itemId);\r\n                if (item) {\r\n                    item.status = newStatus as AssetItem['status'];\r\n                    if (note) item.declineNote = note;\r\n                }\r\n            }\r\n            renderCategoryView();\r\n            console.log(`[Dashboard] Updated ${itemId} status to ${newStatus}`);\r\n            broadcastUpdate(category, itemId, { status: newStatus, declineNote: note });\r\n        } else {\r\n            console.error('[Dashboard] Update failed:', result.error);\r\n        }\r\n    } catch (err) {\r\n        console.error('[Dashboard] API error:', err);\r\n    }\r\n}\r\n\r\nexport async function updateConsumedStatus(\r\n    category: string,\r\n    fileName: string,\r\n    itemId: string,\r\n    newStatus: string,\r\n    note = ''\r\n): Promise<void> {\r\n    try {\r\n        const response = await fetch('/api/update_entity', {\r\n            method: 'POST',\r\n            headers: { 'Content-Type': 'application/json' },\r\n            body: JSON.stringify({\r\n                category,\r\n                file: fileName,\r\n                id: itemId,\r\n                updates: { consumedStatus: newStatus, consumedDeclineNote: note },\r\n            }),\r\n        });\r\n        const result = await response.json();\r\n\r\n        if (result.success) {\r\n            const files = categoryData?.files;\r\n            if (files && files[fileName]) {\r\n                const item = files[fileName].find((i) => i.id === itemId);\r\n                if (item) {\r\n                    item.consumedStatus = newStatus;\r\n                }\r\n            }\r\n            renderCategoryView();\r\n            console.log(`[Dashboard] Updated ${itemId} consumed status to ${newStatus}`);\r\n            broadcastUpdate(category, itemId, { consumedStatus: newStatus, consumedDeclineNote: note });\r\n        } else {\r\n            console.error('[Dashboard] Update failed:', result.error);\r\n        }\r\n    } catch (err) {\r\n        console.error('[Dashboard] API error:', err);\r\n    }\r\n}\r\n\r\nexport async function updateItemWeapon(\r\n    category: string,\r\n    fileName: string,\r\n    itemId: string,\r\n    newWeapon: string\r\n): Promise<void> {\r\n    try {\r\n        const response = await fetch('/api/update_entity', {\r\n            method: 'POST',\r\n            headers: { 'Content-Type': 'application/json' },\r\n            body: JSON.stringify({\r\n                category,\r\n                file: fileName,\r\n                id: itemId,\r\n                updates: { weaponType: newWeapon },\r\n            }),\r\n        });\r\n        const result = await response.json();\r\n\r\n        if (result.success) {\r\n            const files = categoryData?.files;\r\n            if (files && files[fileName]) {\r\n                const item = files[fileName].find((i) => i.id === itemId);\r\n                if (item) {\r\n                    item.weaponType = newWeapon;\r\n                }\r\n            }\r\n            console.log(`[Dashboard] Updated ${itemId} weapon to ${newWeapon}`);\r\n            broadcastUpdate(category, itemId, { weaponType: newWeapon });\r\n        }\r\n    } catch (err) {\r\n        console.error('[Dashboard] API error:', err);\r\n    }\r\n}\r\n\r\nexport async function updateItemStat(\r\n    category: string,\r\n    fileName: string,\r\n    itemId: string,\r\n    statKey: string,\r\n    newValue: unknown\r\n): Promise<void> {\r\n    try {\r\n        const response = await fetch('/api/update_entity', {\r\n            method: 'POST',\r\n            headers: { 'Content-Type': 'application/json' },\r\n            body: JSON.stringify({\r\n                category,\r\n                file: fileName,\r\n                id: itemId,\r\n                updates: { [`stats.${statKey}`]: newValue },\r\n            }),\r\n        });\r\n        const result = await response.json();\r\n\r\n        if (result.success) {\r\n            const files = categoryData?.files;\r\n            if (files && files[fileName]) {\r\n                const item = files[fileName].find((i) => i.id === itemId);\r\n                if (item && typeof item.stats === 'object' && item.stats !== null) {\r\n                    (item.stats as Record<string, unknown>)[statKey] = newValue;\r\n                }\r\n            }\r\n            console.log(`[Dashboard] Updated ${itemId} stat ${statKey} to ${newValue}`);\r\n            broadcastUpdate(category, itemId, { [`stats.${statKey}`]: newValue });\r\n        }\r\n    } catch (err) {\r\n        console.error('[Dashboard] API error:', err);\r\n    }\r\n}\r\n\r\nexport async function updateItemField(\r\n    category: string,\r\n    fileName: string,\r\n    itemId: string,\r\n    field: string,\r\n    value: unknown\r\n): Promise<void> {\r\n    try {\r\n        const response = await fetch('/api/update_entity', {\r\n            method: 'POST',\r\n            headers: { 'Content-Type': 'application/json' },\r\n            body: JSON.stringify({\r\n                category,\r\n                file: fileName,\r\n                id: itemId,\r\n                updates: { [field]: value },\r\n            }),\r\n        });\r\n        const result = await response.json();\r\n\r\n        if (result.success) {\r\n            const files = categoryData?.files;\r\n            if (files && files[fileName]) {\r\n                const item = files[fileName].find((i) => i.id === itemId);\r\n                if (item) {\r\n                    (item as unknown as Record<string, unknown>)[field] = value;\r\n                }\r\n            }\r\n            console.log(`[Dashboard] Updated ${itemId} field ${field}`);\r\n            broadcastUpdate(category, itemId, { [field]: value });\r\n        }\r\n    } catch (err) {\r\n        console.error('[Dashboard] API error:', err);\r\n    }\r\n}\r\n\r\nexport async function updateItemTier(\r\n    category: string,\r\n    fileName: string,\r\n    itemId: string,\r\n    newTier: number\r\n): Promise<void> {\r\n    try {\r\n        const response = await fetch('/api/update_entity', {\r\n            method: 'POST',\r\n            headers: { 'Content-Type': 'application/json' },\r\n            body: JSON.stringify({\r\n                category,\r\n                file: fileName,\r\n                id: itemId,\r\n                updates: { tier: newTier },\r\n            }),\r\n        });\r\n        const result = await response.json();\r\n\r\n        if (result.success) {\r\n            const files = categoryData?.files;\r\n            if (files && files[fileName]) {\r\n                const item = files[fileName].find((i) => i.id === itemId);\r\n                if (item) {\r\n                    item.tier = newTier;\r\n                }\r\n            }\r\n            renderCategoryView();\r\n            console.log(`[Dashboard] Updated ${itemId} tier to ${newTier}`);\r\n            broadcastUpdate(category, itemId, { tier: newTier });\r\n        }\r\n    } catch (err) {\r\n        console.error('[Dashboard] API error:', err);\r\n    }\r\n}\r\n\r\nexport async function updateDisplayField(\r\n    category: string,\r\n    fileName: string,\r\n    itemId: string,\r\n    field: string,\r\n    value: number\r\n): Promise<void> {\r\n    console.log(`[Dashboard][updateDisplayField] CALLED with:`, { category, fileName, itemId, field, value });\r\n    try {\r\n        const payload = {\r\n            category,\r\n            file: fileName,\r\n            id: itemId,\r\n            updates: { [`display.${field}`]: value },\r\n        };\r\n        console.log(`[Dashboard][updateDisplayField] Sending to /api/update_entity:`, JSON.stringify(payload));\r\n\r\n        const response = await fetch('/api/update_entity', {\r\n            method: 'POST',\r\n            headers: { 'Content-Type': 'application/json' },\r\n            body: JSON.stringify(payload),\r\n        });\r\n        const result = await response.json();\r\n        console.log(`[Dashboard][updateDisplayField] Response:`, result);\r\n\r\n        if (result.success) {\r\n            const files = categoryData?.files;\r\n            if (files && files[fileName]) {\r\n                const item = files[fileName].find((i) => i.id === itemId);\r\n                if (item) {\r\n                    if (!item.display) item.display = {};\r\n                    (item.display as Record<string, number>)[field] = value;\r\n                }\r\n            }\r\n            console.log(`[Dashboard]  Updated ${itemId} display.${field} to ${value}`);\r\n            broadcastUpdate(category, itemId, { [`display.${field}`]: value });\r\n        } else {\r\n            console.error(`[Dashboard]  Update failed:`, result.error || result);\r\n        }\r\n    } catch (err) {\r\n        console.error('[Dashboard] API error in updateDisplayField:', err);\r\n    }\r\n}\r\n\r\nexport async function updateDisplaySize(\r\n    category: string,\r\n    fileName: string,\r\n    itemId: string,\r\n    size: number\r\n): Promise<void> {\r\n    try {\r\n        const payload = {\r\n            category,\r\n            file: fileName,\r\n            id: itemId,\r\n            updates: {\r\n                'display.width': size,\r\n                'display.height': size\r\n            },\r\n        };\r\n\r\n        const response = await fetch('/api/update_entity', {\r\n            method: 'POST',\r\n            headers: { 'Content-Type': 'application/json' },\r\n            body: JSON.stringify(payload),\r\n        });\r\n        const result = await response.json();\r\n\r\n        if (result.success) {\r\n            const files = categoryData?.files;\r\n            if (files && files[fileName]) {\r\n                const item = files[fileName].find((i) => i.id === itemId);\r\n                if (item) {\r\n                    if (!item.display) item.display = {};\r\n                    item.display.width = size;\r\n                    item.display.height = size;\r\n                }\r\n            }\r\n            broadcastUpdate(category, itemId, { 'display.width': size, 'display.height': size });\r\n            renderCategoryView();\r\n        }\r\n    } catch (err) {\r\n        console.error('[Dashboard] API error in updateDisplaySize:', err);\r\n    }\r\n}\r\n\r\n\r\nexport async function updateWeaponMeta(\r\n    category: string,\r\n    fileName: string,\r\n    itemId: string,\r\n    field: string,\r\n    value: string\r\n): Promise<void> {\r\n    try {\r\n        const response = await fetch('/api/update_entity', {\r\n            method: 'POST',\r\n            headers: { 'Content-Type': 'application/json' },\r\n            body: JSON.stringify({\r\n                category,\r\n                file: fileName,\r\n                id: itemId,\r\n                updates: { [field]: value },\r\n            }),\r\n        });\r\n        const result = await response.json();\r\n\r\n        if (result.success) {\r\n            const files = categoryData?.files;\r\n            if (files && files[fileName]) {\r\n                const item = files[fileName].find((i) => i.id === itemId);\r\n                if (item) {\r\n                    (item as unknown as Record<string, unknown>)[field] = value;\r\n                }\r\n            }\r\n            renderCategoryView();\r\n            console.log(`[Dashboard] Updated ${itemId} ${field} to ${value}`);\r\n            broadcastUpdate(category, itemId, { [field]: value });\r\n        }\r\n    } catch (err) {\r\n        console.error('[Dashboard] API error:', err);\r\n    }\r\n}\r\n\r\nexport async function remakeAsset(path: string, name: string, safeId: string): Promise<void> {\r\n    const noteInput = document.getElementById(`notes_${safeId}`) as HTMLInputElement | null;\r\n    const note = noteInput?.value || 'Remake requested';\r\n\r\n    try {\r\n        await fetch('/api/change_status', {\r\n            method: 'POST',\r\n            headers: { 'Content-Type': 'application/json' },\r\n            body: JSON.stringify({ path, newStatus: 'declined' }),\r\n        });\r\n        await saveNotes(name, `Remake: ${note}`);\r\n        console.log(`[Dashboard] Marked ${name} for remake`);\r\n    } catch (err) {\r\n        console.error('[Dashboard] Remake error:', err);\r\n    }\r\n}\r\n\r\n\r\n\r\nexport async function syncEntitiesToJson(): Promise<void> {\r\n    try {\r\n        const btn = document.getElementById('btnSyncEntities') as HTMLButtonElement | null;\r\n        if (btn) {\r\n            btn.disabled = true;\r\n            btn.textContent = ' Syncing...';\r\n        }\r\n\r\n        const response = await fetch('/api/sync_entities', {\r\n            method: 'POST',\r\n            headers: { 'Content-Type': 'application/json' },\r\n            body: JSON.stringify({}),\r\n        });\r\n        const result = await response.json();\r\n\r\n        if (btn) {\r\n            btn.disabled = false;\r\n            btn.textContent = ' Sync Entities';\r\n        }\r\n\r\n        if (result.success) {\r\n            console.log('[Dashboard] Entity sync complete:', result.message);\r\n            alert(` ${result.message}`);\r\n        } else {\r\n            console.error('[Dashboard] Entity sync failed:', result.error);\r\n            alert(` Sync failed: ${result.error}`);\r\n        }\r\n    } catch (err) {\r\n        console.error('[Dashboard] Entity sync error:', err);\r\n    }\r\n}\r\n\r\nexport async function loadGlobalAssetLookup(): Promise<void> {\r\n    try {\r\n        const categories = [\r\n            'resources', 'items', 'equipment', 'nodes',\r\n            'enemies', 'bosses', 'props', 'buildings'\r\n        ];\r\n        const lookup: Record<string, AssetInfo> = {};\r\n        const sourceMap: Record<string, string[]> = {};\r\n        const usageMap: Record<string, string[]> = {};\r\n\r\n        for (const cat of categories) {\r\n            const response = await fetch('/api/get_category', {\r\n                method: 'POST',\r\n                headers: { 'Content-Type': 'application/json' },\r\n                body: JSON.stringify({ category: cat }),\r\n            });\r\n            const data = await response.json();\r\n\r\n            // Helper to process an item for lookup key and source map\r\n            const processItem = (item: Record<string, unknown>) => {\r\n                // 1. Build Lookup (same priority as AssetLoader: clean  approved_original  original)\r\n                const displayPath = selectBestImagePath(item.files as { clean?: string; approved_original?: string; original?: string });\r\n                if (displayPath) {\r\n                    lookup[item.id] = {\r\n                        id: item.id,\r\n                        path: displayPath,\r\n                        name: item.name,\r\n                        category: cat,\r\n                    };\r\n                    if (item.name) {\r\n                        lookup[item.name] = lookup[item.id];\r\n                    }\r\n                }\r\n\r\n                // 2. Build Loot Source Map\r\n                // A. Check LOOT (Enemies)\r\n                if (item.loot && Array.isArray(item.loot)) {\r\n                    for (const drop of item.loot) {\r\n                        if (!sourceMap[drop.item]) sourceMap[drop.item] = [];\r\n                        if (!sourceMap[drop.item].includes(item.id)) {\r\n                            sourceMap[drop.item].push(item.id);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // B. Check DROPS (Nodes - New Standard)\r\n                if (item.drops && Array.isArray(item.drops)) {\r\n                    for (const drop of item.drops) {\r\n                        const dropId = drop.item;\r\n                        if (!sourceMap[dropId]) sourceMap[dropId] = [];\r\n                        if (!sourceMap[dropId].includes(item.id)) {\r\n                            sourceMap[dropId].push(item.id);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // C. Check RECIPE (Items - Reverse Ingredient Lookup)\r\n                if (item.recipe) {\r\n                    // Logic to extract ingredients from recipe string/object/array\r\n                    // Simplified: just check if we can parse it easily\r\n                    let ingredients: string[] = [];\r\n                    if (Array.isArray(item.recipe)) {\r\n                        ingredients = (item.recipe as Array<{ item: string }>).map((r) => r.item);\r\n                    } else if (typeof item.recipe === 'object') {\r\n                        ingredients = Object.keys(item.recipe);\r\n                    }\r\n                    // String parsing is safer done elsewhere or simplified here\r\n\r\n                    for (const ing of ingredients) {\r\n                        if (!usageMap[ing]) usageMap[ing] = [];\r\n                        if (!usageMap[ing].includes(item.id)) {\r\n                            usageMap[ing].push(item.id); // \"Used To Craft\" relationship\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // D. Check RESOURCE DROP (Nodes - Legacy)\r\n                if (item.resourceDrop) {\r\n                    if (!sourceMap[item.resourceDrop]) sourceMap[item.resourceDrop] = [];\r\n                    if (!sourceMap[item.resourceDrop].includes(item.id)) {\r\n                        sourceMap[item.resourceDrop].push(item.id);\r\n                    }\r\n                }\r\n            };\r\n\r\n            // Process 'files' (scanned from disk)\r\n            if (data.files) {\r\n                for (const [, items] of Object.entries(data.files as Record<string, AssetItem[]>)) {\r\n                    for (const item of items) {\r\n                        processItem(item);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Process 'entities' (code definitions, source of truth for logic)\r\n            if (data.entities && Array.isArray(data.entities)) {\r\n                for (const item of data.entities) {\r\n                    processItem(item);\r\n                }\r\n            }\r\n        }\r\n\r\n        setGlobalAssetLookup(lookup);\r\n        setLootSourceMap(sourceMap);\r\n        setRecipeUsageMap(usageMap);\r\n        console.log(`[Dashboard] Loaded ${Object.keys(lookup).length} assets, ${Object.keys(sourceMap).length} sources, ${Object.keys(usageMap).length} usages`);\r\n    } catch (err) {\r\n        console.error('[Dashboard] Failed to load asset lookup:', err);\r\n    }\r\n}\r\n\r\n/**\r\n * Select best image path from entity files (matches AssetLoader._selectBestPath).\r\n * Priority: clean  approved_original  original\r\n */\r\nexport function selectBestImagePath(files?: {\r\n    clean?: string;\r\n    approved_original?: string;\r\n    original?: string;\r\n}): string | undefined {\r\n    if (!files) return undefined;\r\n    const raw = files.clean || files.approved_original || files.original;\r\n    return raw ? raw.replace(/^(assets\\/)?images\\//, '') : undefined;\r\n}\r\n\r\nexport function getAssetImage(nameOrId: string): string {\r\n    const info = globalAssetLookup[nameOrId];\r\n    return info ? `/images/${info.path}` : '/images/PH.png';\r\n}\r\n\r\nexport function getAssetInfo(nameOrId: string): AssetInfo | null {\r\n    return globalAssetLookup[nameOrId] || null;\r\n}\r\n\r\n// ============================================\r\n// SFX REGENERATION QUEUE\r\n// ============================================\r\n\r\nexport async function saveRegenerationQueueToFile(): Promise<void> {\r\n    try {\r\n        await fetch('/api/save_sfx_queue', {\r\n            method: 'POST',\r\n            headers: { 'Content-Type': 'application/json' },\r\n            body: JSON.stringify({ queue: sfxRegenerationQueue }),\r\n        });\r\n    } catch (err) {\r\n        console.error('[Dashboard] Failed to save SFX queue:', err);\r\n    }\r\n}\r\n\r\nexport function markSfxForRegeneration(sfxId: string, assetId: string): void {\r\n    const existing = sfxRegenerationQueue.find((q) => q.assetId === assetId);\r\n    if (existing) {\r\n        if (!existing.sfxIds.includes(sfxId)) {\r\n            existing.sfxIds.push(sfxId);\r\n        }\r\n    } else {\r\n        sfxRegenerationQueue.push({ assetId, sfxIds: [sfxId] });\r\n    }\r\n    setSfxRegenerationQueue([...sfxRegenerationQueue]);\r\n    saveRegenerationQueueToFile();\r\n}\r\n\r\nexport function markAllSfxForRegeneration(\r\n    assetId: string,\r\n    sfxIds: string[],\r\n    btnElement?: HTMLElement\r\n): void {\r\n    const existing = sfxRegenerationQueue.find((q) => q.assetId === assetId);\r\n    if (existing) {\r\n        sfxIds.forEach((id) => {\r\n            if (!existing.sfxIds.includes(id)) {\r\n                existing.sfxIds.push(id);\r\n            }\r\n        });\r\n    } else {\r\n        sfxRegenerationQueue.push({ assetId, sfxIds: [...sfxIds] });\r\n    }\r\n    setSfxRegenerationQueue([...sfxRegenerationQueue]);\r\n    saveRegenerationQueueToFile();\r\n\r\n    if (btnElement) {\r\n        btnElement.textContent = ' Queued';\r\n        btnElement.style.background = '#666';\r\n        (btnElement as HTMLButtonElement).disabled = true;\r\n    }\r\n}\r\n\r\nexport function getSfxRegenerationQueue(): typeof sfxRegenerationQueue {\r\n    return sfxRegenerationQueue;\r\n}\r\n\r\nexport function clearSfxRegenerationQueue(): void {\r\n    setSfxRegenerationQueue([]);\r\n    saveRegenerationQueueToFile();\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\dashboard\\src\\builders\\ActionBuilder.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\dashboard\\src\\builders\\BadgeBuilder.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\dashboard\\src\\builders\\DropdownBuilder.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\dashboard\\src\\builders\\ImageBuilder.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\dashboard\\src\\builders\\InfoBuilder.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\dashboard\\src\\builders\\SfxVfxBuilder.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\dashboard\\src\\builders\\StatsBuilder.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\dashboard\\src\\builders\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\dashboard\\src\\categoryRenderer.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'lootSourceMap' is defined but never used.","line":14,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":18,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"lootSourceMap"},"fix":{"range":[245,265],"text":""},"desc":"Remove unused variable \"lootSourceMap\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'typeField' is assigned a value but never used.","line":549,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":549,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport {\r\n    AssetItem,\r\n    CategoryData,\r\n    categoryFilter,\r\n    currentCategoryName,\r\n    selectedAssetId,\r\n    categoryImageSize,\r\n    globalAssetLookup,\r\n    CATEGORY_COLORS,\r\n    setCategoryData,\r\n    categoryData,\r\n    CATEGORY_ICONS,\r\n    lootSourceMap,\r\n    imageParams,\r\n} from './state';\r\n\r\n// ============================================\r\n// CONSTANTS & COLORS\r\n// ============================================\r\n\r\nconst TIER_COLORS: Record<string, string> = {\r\n    '1': '#9e9e9e', // Common\r\n    '2': '#4caf50', // Uncommon\r\n    '3': '#2196f3', // Rare\r\n    '4': '#9c27b0', // Epic\r\n    '5': '#ff9800', // Legendary\r\n};\r\n\r\nconst BIOME_COLORS: Record<string, string> = {\r\n    'grasslands': '#4caf50',\r\n    'tundra': '#3498db',\r\n    'desert': '#e67e22',\r\n    'badlands': '#c0392b',\r\n    'global': '#7f8c8d'\r\n};\r\n\r\nconst STATUS_COLORS: Record<string, string> = {\r\n    'pending': '#f1c40f',\r\n    'approved': '#2ecc71',\r\n    'declined': '#e74c3c',\r\n    'clean': '#3498db',\r\n    'all': '#7f8c8d'\r\n};\r\n\r\n// ============================================\r\n// MAIN RENDERER\r\n// ============================================\r\n\r\nexport function renderCategoryView(data?: CategoryData | null) {\r\n    // 1. Update State if new data passed\r\n    if (data) {\r\n        setCategoryData(data);\r\n    }\r\n\r\n    const activeData = data || categoryData;\r\n    if (!activeData) return;\r\n\r\n    // 2. Setup Container\r\n    // 2. Setup Container\r\n    let container = document.getElementById('categoryGrid');\r\n\r\n    // If grid is missing (e.g. wiped by loading screen), rebuild layout\r\n    if (!container) {\r\n        const main = document.getElementById('mainContent');\r\n        if (!main) return;\r\n\r\n        main.innerHTML = `\r\n            <style>\r\n                .status-stamp {\r\n                    position: absolute;\r\n                    top: 10px;\r\n                    right: -25px;\r\n                    transform: rotate(45deg);\r\n                    padding: 2px 25px;\r\n                    font-size: 0.6rem;\r\n                    font-weight: 900;\r\n                    letter-spacing: 1px;\r\n                    text-transform: uppercase;\r\n                    box-shadow: 0 2px 4px rgba(0,0,0,0.3);\r\n                    z-index: 10;\r\n                    pointer-events: none;\r\n                    text-shadow: 0 1px 2px rgba(0,0,0,0.5);\r\n                    border: 1px solid rgba(255,255,255,0.3);\r\n                }\r\n                .status-stamp.approved {\r\n                    background: #2ecc71;\r\n                    color: white;\r\n                }\r\n                .status-stamp.declined {\r\n                    background: #e74c3c;\r\n                    color: white;\r\n                }\r\n                .status-stamp.pending {\r\n                    background: #f1c40f;\r\n                    color: #333;\r\n                    text-shadow: none;\r\n                }\r\n            </style>\r\n            <div class=\"sticky-bar\">\r\n                <div class=\"header-row\">\r\n                    <h2 id=\"categoryTitle\" class=\"category-title\">${currentCategoryName.toUpperCase()}</h2>\r\n                    <div id=\"filterContainer\" class=\"filter-container\"></div>\r\n                </div>\r\n            </div>\r\n            <div id=\"categoryGrid\" class=\"asset-grid\"></div>\r\n        `;\r\n\r\n        container = document.getElementById('categoryGrid');\r\n        if (!container) return;\r\n    }\r\n\r\n    container.innerHTML = '';\r\n\r\n    // 3. Render Filters\r\n    const filterContainer = document.getElementById('filterContainer');\r\n    if (filterContainer) {\r\n        // Flatten all items for filter counts/options\r\n        const allItems = activeData.entities || [];\r\n        renderDynamicFilters(filterContainer, allItems, activeData.files || {});\r\n    }\r\n\r\n    // 4. Apply Filters\r\n    let items = activeData.entities || [];\r\n\r\n    // Filter Logic\r\n    if (categoryFilter.status !== 'all') {\r\n        items = items.filter(i => (i.status || 'pending') === categoryFilter.status);\r\n    }\r\n    if (categoryFilter.biome !== 'all') {\r\n        items = items.filter(i => i.biome === categoryFilter.biome);\r\n    }\r\n    if (categoryFilter.tier !== 'all') {\r\n        items = items.filter(i => String(i.tier || (i.id.match(/_t(\\d)_/)?.[1]) || 0) === String(categoryFilter.tier));\r\n    }\r\n    if (categoryFilter.file !== 'all') {\r\n        if (currentCategoryName === 'ground') {\r\n            // For ground, 'file' filter maps to 'category' part of ID\r\n            items = items.filter(i => {\r\n                const parts = i.id.split('_');\r\n                return parts[1] === categoryFilter.file;\r\n            });\r\n        } else {\r\n            // 'file' filter usually maps to source file key in data.files\r\n            // But here we might check if item is in that specific list\r\n            // Or if we have a sourceFile property.\r\n            // Let's use the file map check if data.files is present\r\n            if (activeData.files && activeData.files[categoryFilter.file]) {\r\n                const fileItems = new Set(activeData.files[categoryFilter.file].map(i => i.id));\r\n                items = items.filter(i => fileItems.has(i.id));\r\n            }\r\n        }\r\n    }\r\n    if (categoryFilter.nodeSubtype !== 'all') {\r\n        if (currentCategoryName === 'ground') {\r\n            // For ground, 'nodeSubtype' filter maps to 'material' part of ID\r\n            items = items.filter(i => {\r\n                const parts = i.id.split('_');\r\n                const biomes = ['grasslands', 'tundra', 'desert', 'badlands', 'global'];\r\n                const biomeIndex = parts.findIndex(p => biomes.includes(p));\r\n                if (biomeIndex > 2) {\r\n                    const mat = parts.slice(2, biomeIndex).join('_');\r\n                    return mat === categoryFilter.nodeSubtype;\r\n                }\r\n                return false;\r\n            });\r\n        } else {\r\n            items = items.filter(i => i.nodeSubtype === categoryFilter.nodeSubtype);\r\n        }\r\n    }\r\n\r\n    // 5. Render Cards\r\n    const fragment = document.createDocumentFragment();\r\n\r\n    // Virtualize? No, pagination/lazy load maybe. For now just render all.\r\n    // If > 500 items, verify performance.\r\n\r\n    items.forEach(item => {\r\n        // Determine 'fileName' context (often passed or derived)\r\n        // We'll trust dataset or just use default.\r\n        const fileName = categoryFilter.file !== 'all' ? categoryFilter.file : (findFileForItem(item, activeData.files) || 'unknown');\r\n\r\n        const card = createCategoryCard(item, fileName);\r\n        fragment.appendChild(card);\r\n    });\r\n\r\n    container.appendChild(fragment);\r\n\r\n    // Update Header Counts\r\n    const headerTitle = document.getElementById('categoryTitle');\r\n    if (headerTitle) {\r\n        headerTitle.innerHTML = `${CATEGORY_ICONS[currentCategoryName] || ''} ${currentCategoryName.toUpperCase()} <span style=\"opacity:0.6; font-size:0.8em\">(${items.length})</span>`;\r\n    }\r\n}\r\n\r\nfunction findFileForItem(item: AssetItem, files: Record<string, AssetItem[]> | undefined): string | null {\r\n    if (!files) return null;\r\n    for (const [fName, list] of Object.entries(files)) {\r\n        if (list.some(i => i.id === item.id)) return fName;\r\n    }\r\n    return null;\r\n}\r\n\r\n\r\n// ============================================\r\n// FILTER RENDERING\r\n// ============================================\r\n\r\nfunction renderDynamicFilters(container: HTMLElement, allItems: AssetItem[], files: Record<string, AssetItem[]>) {\r\n    container.innerHTML = '';\r\n\r\n    // 1. STATUS MODULE\r\n    const statusGroup = createFilterModule('Status');\r\n    const statusContent = statusGroup.querySelector('.module-content')!;\r\n    ['all', 'pending', 'approved', 'declined', 'clean'].forEach(status => {\r\n        const color = STATUS_COLORS[status];\r\n        statusContent.appendChild(createFilterBtn(\r\n            status.charAt(0).toUpperCase() + status.slice(1),\r\n            'set-category-status',\r\n            status,\r\n            categoryFilter.status === status,\r\n            color\r\n        ));\r\n    });\r\n    container.appendChild(statusGroup);\r\n\r\n    // 2. TIER MODULE (Skip for Ground)\r\n    if (currentCategoryName !== 'ground') {\r\n        const tierGroup = createFilterModule('Tier');\r\n        const tierContent = tierGroup.querySelector('.module-content')!;\r\n        ['all', 1, 2, 3, 4, 5].forEach(t => {\r\n            const label = t === 'all' ? 'All' : `T${t}`;\r\n            // Lookup Tier color\r\n            const color = t === 'all' ? undefined : TIER_COLORS[String(t)];\r\n\r\n            tierContent.appendChild(createFilterBtn(\r\n                label,\r\n                'set-category-tier',\r\n                String(t),\r\n                String(categoryFilter.tier) === String(t),\r\n                color\r\n            ));\r\n        });\r\n        container.appendChild(tierGroup);\r\n    }\r\n\r\n    // 2.5 GROUND SPECIFIC FILTERS (Category & Material)\r\n    if (currentCategoryName === 'ground') {\r\n        const categories = new Set<string>();\r\n        const materials = new Set<string>();\r\n\r\n        allItems.forEach(item => {\r\n            // ID Format: ground_[category]_[material]_[biome]_[index]\r\n            const parts = item.id.split('_');\r\n            if (parts.length >= 4) {\r\n                // ground = 0, category = 1, material = 2... (might be multi-word)\r\n                // Let's assume standard known categories: base, overgrown, interior, vertical, damage\r\n                const groundCats = ['base', 'overgrown', 'interior', 'vertical', 'damage'];\r\n                const cat = parts[1];\r\n                if (groundCats.includes(cat)) {\r\n                    categories.add(cat);\r\n                    // Material is everything between category and biome\r\n                    // Biome is usually known or at end-1\r\n                    // Let's rely on indices assuming biome is 2nd to last if last is number?\r\n                    // Actually, let's just grab the part after category and before biome.\r\n                    // Common biomes: grasslands, tundra, desert, badlands\r\n                    const biomes = ['grasslands', 'tundra', 'desert', 'badlands', 'global'];\r\n                    const biomeIndex = parts.findIndex(p => biomes.includes(p));\r\n\r\n                    if (biomeIndex > 2) {\r\n                        const mat = parts.slice(2, biomeIndex).join('_');\r\n                        materials.add(mat);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        // RENDER CATEGORY FILTER\r\n        if (categories.size > 0) {\r\n            const group = createFilterModule('Category');\r\n            const content = group.querySelector('.module-content')!;\r\n\r\n            // Re-purpose 'file' filter for 'category' since we don't use file filter for ground much?\r\n            // User requested explicit badges and filters.\r\n            // Let's use 'nodeSubtype' field in state for 'Category' and 'weaponType' for 'Material' hacks?\r\n            // OR just add new filter fields to state?\r\n            // For now, let's map 'Category' -> 'file' (Type) and 'Material' -> 'nodeSubtype' (Subtype)\r\n            // This reuses existing state fields without schema change.\r\n\r\n            content.appendChild(createFilterBtn('All', 'set-category-file', 'all', categoryFilter.file === 'all'));\r\n            [...categories].sort().forEach(c => {\r\n                content.appendChild(createFilterBtn(\r\n                    c.charAt(0).toUpperCase() + c.slice(1),\r\n                    'set-category-file',\r\n                    c,\r\n                    categoryFilter.file === c,\r\n                    '#9b59b6'\r\n                ));\r\n            });\r\n            container.appendChild(group);\r\n        }\r\n\r\n        // RENDER MATERIAL FILTER\r\n        if (materials.size > 0) {\r\n            const group = createFilterModule('Material');\r\n            const content = group.querySelector('.module-content')!;\r\n\r\n            content.appendChild(createFilterBtn('All', 'set-category-node-subtype', 'all', categoryFilter.nodeSubtype === 'all'));\r\n            [...materials].sort().forEach(m => {\r\n                content.appendChild(createFilterBtn(\r\n                    m.replace(/_/g, ' ').toUpperCase(),\r\n                    'set-category-node-subtype',\r\n                    m,\r\n                    categoryFilter.nodeSubtype === m,\r\n                    '#e67e22'\r\n                ));\r\n            });\r\n            container.appendChild(group);\r\n        }\r\n    }\r\n\r\n    // 3. BIOME MODULE\r\n    const biomes = [...new Set(allItems.map((i) => i.biome).filter((b) => b && b !== 'all'))] as string[];\r\n    if (biomes.length > 0) {\r\n        const biomeGroup = createFilterModule('Biome');\r\n        const biomeContent = biomeGroup.querySelector('.module-content')!;\r\n\r\n        biomeContent.appendChild(createFilterBtn('All', 'set-category-biome', 'all', categoryFilter.biome === 'all'));\r\n\r\n        biomes.forEach(b => {\r\n            const color = BIOME_COLORS[b.toLowerCase()];\r\n            biomeContent.appendChild(createFilterBtn(\r\n                b,\r\n                'set-category-biome',\r\n                b,\r\n                categoryFilter.biome === b,\r\n                color\r\n            ));\r\n        });\r\n        container.appendChild(biomeGroup);\r\n    }\r\n\r\n    // 4. TYPE MODULE\r\n    const fileNames = Object.keys(files);\r\n    if (fileNames.length > 1) {\r\n        const fileGroup = createFilterModule('Type');\r\n        const fileContent = fileGroup.querySelector('.module-content')!;\r\n\r\n        fileContent.appendChild(createFilterBtn('All', 'set-category-file', 'all', categoryFilter.file === 'all'));\r\n\r\n        fileNames.forEach(f => {\r\n            const displayName = f.replace(/^(equipment_|item_|items_|resources_|enemies_|)/, '');\r\n            const color = CATEGORY_COLORS[displayName] || '#7f8c8d';\r\n\r\n            fileContent.appendChild(createFilterBtn(\r\n                displayName,\r\n                'set-category-file',\r\n                f,\r\n                categoryFilter.file === f,\r\n                color\r\n            ));\r\n        });\r\n        container.appendChild(fileGroup);\r\n    }\r\n\r\n    // 5. NODE SUBTYPE MODULE\r\n    if (currentCategoryName === 'nodes') {\r\n        const subtypes = [...new Set(allItems.map(i => i.nodeSubtype).filter(s => s))];\r\n        if (subtypes.length > 0) {\r\n            const subGroup = createFilterModule('Subtype');\r\n            const subContent = subGroup.querySelector('.module-content')!;\r\n\r\n            subContent.appendChild(createFilterBtn('All', 'set-category-node-subtype', 'all', categoryFilter.nodeSubtype === 'all'));\r\n\r\n            subtypes.forEach(s => {\r\n                const isActive = categoryFilter.nodeSubtype === s;\r\n                subContent.appendChild(createFilterBtn(\r\n                    s!.charAt(0).toUpperCase() + s!.slice(1),\r\n                    'set-category-node-subtype',\r\n                    s!,\r\n                    isActive,\r\n                    isActive ? '#d35400' : '#e67e22'\r\n                ));\r\n            });\r\n            container.appendChild(subGroup);\r\n        }\r\n    }\r\n\r\n    // 5. ACTIONS\r\n    const actionGroup = document.createElement('div');\r\n    actionGroup.className = 'filter-actions';\r\n\r\n    const resetBtn = document.createElement('button');\r\n    resetBtn.className = 'filter-reset-btn';\r\n    resetBtn.innerHTML = `<span> RESET</span>`;\r\n    resetBtn.dataset.action = 'reset-filters';\r\n    resetBtn.title = \"Clear all active filters\";\r\n    actionGroup.appendChild(resetBtn);\r\n\r\n    container.appendChild(actionGroup);\r\n}\r\n\r\nfunction createFilterModule(label: string): HTMLElement {\r\n    const group = document.createElement('div');\r\n    group.className = 'filter-module';\r\n\r\n    const labelEl = document.createElement('div');\r\n    labelEl.className = 'module-label';\r\n    labelEl.textContent = label;\r\n    group.appendChild(labelEl);\r\n\r\n    const content = document.createElement('div');\r\n    content.className = 'module-content';\r\n    group.appendChild(content);\r\n\r\n    return group;\r\n}\r\n\r\nfunction createFilterBtn(text: string, action: string, value: string, isActive: boolean, color?: string): HTMLElement {\r\n    const btn = document.createElement('button');\r\n    btn.className = `filter-pill ${isActive ? 'active' : ''}`;\r\n    btn.textContent = text;\r\n    btn.dataset.action = action;\r\n    btn.dataset.value = value;\r\n\r\n    // Color Logic\r\n    if (color) {\r\n        if (isActive) {\r\n            btn.style.backgroundColor = color;\r\n            btn.style.color = '#fff';\r\n            btn.style.borderColor = color;\r\n            btn.style.textShadow = '0 1px 2px rgba(0,0,0,0.5)';\r\n        } else {\r\n            btn.style.color = color;\r\n            btn.style.borderColor = color;\r\n            btn.style.border = `1px solid ${color}40`;\r\n        }\r\n    }\r\n\r\n    return btn;\r\n}\r\n\r\n\r\n// ============================================\r\n// CARD CREATION\r\n// ============================================\r\n\r\nexport function createCategoryCard(item: AssetItem, fileName: string): HTMLElement {\r\n    const card = document.createElement('div');\r\n    const isSelected = selectedAssetId === item.id;\r\n    card.className = `asset-card ${item.status || 'pending'} ${isSelected ? 'selected' : ''}`;\r\n\r\n    // Bind Selection Action\r\n    card.dataset.action = 'select-asset';\r\n    card.dataset.id = item.id;\r\n    card.dataset.file = fileName;\r\n    card.dataset.category = currentCategoryName;\r\n\r\n    // Width override\r\n    card.style.width = (categoryImageSize + 24) + 'px';\r\n\r\n    // 1. STATUS BAR\r\n    const statusHtml = `<div class=\"status-indicator ${item.status || 'pending'}\"></div>`;\r\n\r\n    // 2. IMAGE\r\n    let imgPath = item.files?.clean || item.files?.original || '/images/PH.png';\r\n    if (!imgPath.startsWith('/') && !imgPath.startsWith('http')) {\r\n        imgPath = `/images/${imgPath.replace(/^(assets\\/)?images\\//, '')}`;\r\n    }\r\n\r\n    // Determine Upload Target (Prefer Original)\r\n    let uploadPath = item.files?.original || item.files?.clean || imgPath;\r\n    if (!uploadPath.startsWith('/') && !uploadPath.startsWith('http')) {\r\n        uploadPath = `/images/${uploadPath.replace(/^(assets\\/)?images\\//, '')}`;\r\n    }\r\n\r\n    // Debug: Log render state\r\n    // console.log('[Renderer] Rendering:', item.id, 'Param:', imageParams[item.id]);\r\n\r\n    // const debugBorder = imageParams[item.id] ? '2px solid #4caf50' : '1px solid #333';\r\n\r\n    const status = item.status || 'pending';\r\n    const stampLabel = status === 'approved' ? 'APPROVED' : status === 'declined' ? 'DECLINED' : 'PENDING';\r\n    const stampClass = status;\r\n\r\n    const imgHtml = `\r\n        <div class=\"card-image-container\" style=\"height:${categoryImageSize}px; position:relative; overflow:hidden;\" \r\n             data-action=\"image-drop-zone\" \r\n             data-path=\"${uploadPath}\" \r\n             data-id=\"${item.id}\"\r\n             data-name=\"${item.name || item.id}\" \r\n             data-status=\"${item.status || 'pending'}\">\r\n             <img src=\"${imgPath}${imageParams[item.id] ? '?v=' + imageParams[item.id] : ''}\" class=\"asset-image\">\r\n             \r\n             <!-- Status Stamp -->\r\n             <div class=\"status-stamp ${stampClass}\">\r\n                ${stampLabel}\r\n             </div>\r\n        </div>`;\r\n\r\n    // 3. TIER (Interactive Select)\r\n    const tier = item.tier || (item.id.match(/_t(\\d)_/)?.[1] ? parseInt(item.id.match(/_t(\\d)_/)![1]) : 0);\r\n    const tierColors: Record<number, string> = { 1: '#b0bec5', 2: '#4caf50', 3: '#2196f3', 4: '#9c27b0', 5: '#f44336' };\r\n    const currentTierColor = tierColors[Number(tier)] || '#666';\r\n\r\n    const tierOptions = [1, 2, 3, 4, 5].map(t =>\r\n        `<option value=\"${t}\" ${Number(tier) === t ? 'selected' : ''}>T${t}</option>`\r\n    ).join('');\r\n\r\n    const tierHtml = `\r\n        <div class=\"control-wrapper\" title=\"Tier\" style=\"width:100%;\">\r\n            <select class=\"badge-select\" \r\n                style=\"width:100%; color:${currentTierColor}; border:1px solid ${currentTierColor}40; background: ${currentTierColor}10; padding:2px 0; text-align:center;\" \r\n                data-action=\"update-tier\" \r\n                data-category=\"${currentCategoryName}\" \r\n                data-file=\"${fileName}\" \r\n                data-id=\"${item.id}\" \r\n                data-capture-value=\"true\"\r\n                onclick=\"event.stopPropagation()\">\r\n                <option value=\"0\" ${!tier ? 'selected' : ''}>T?</option>\r\n                ${tierOptions}\r\n            </select>\r\n        </div>\r\n    `;\r\n\r\n    // 4.5 TYPE BADGE & TIER\r\n    let typeLabel = '';\r\n    let typeField = '';\r\n    let typeColor = '#7f8c8d';\r\n    let showTier = true;\r\n    let groundCategory = '';\r\n    let groundMaterial = '';\r\n\r\n    if (currentCategoryName === 'nodes') {\r\n        typeLabel = item.nodeSubtype || 'Generic';\r\n        typeField = 'nodeSubtype';\r\n        typeColor = '#d35400'; // Orange/Wood/Earth\r\n    } else if (currentCategoryName === 'items' || currentCategoryName === 'resources') {\r\n        if (item.sourceFile) {\r\n            typeLabel = item.sourceFile.charAt(0).toUpperCase() + item.sourceFile.slice(1);\r\n            typeField = 'sourceFile';\r\n        } else {\r\n            typeLabel = item.type || (currentCategoryName === 'items' ? 'Item' : 'Resource');\r\n            typeField = 'type';\r\n        }\r\n        typeColor = currentCategoryName === 'items' ? '#8e44ad' : '#27ae60';\r\n    } else if (currentCategoryName === 'equipment') {\r\n        typeLabel = item.slot || (item.weaponType ? item.weaponType : 'Gear');\r\n        typeField = item.slot ? 'slot' : 'weaponType';\r\n        typeColor = '#2980b9'; // Blue/Gear\r\n    } else if (currentCategoryName === 'ground') {\r\n        showTier = false;\r\n        // Parse ID for badges\r\n        const parts = item.id.split('_');\r\n        if (parts.length >= 4) {\r\n            groundCategory = parts[1]; // base, overgrown...\r\n            const biomes = ['grasslands', 'tundra', 'desert', 'badlands', 'global'];\r\n            const biomeIndex = parts.findIndex(p => biomes.includes(p));\r\n            if (biomeIndex > 2) {\r\n                groundMaterial = parts.slice(2, biomeIndex).join(' ');\r\n            }\r\n        }\r\n    }\r\n\r\n    // Simplistic Badge (Mockup for now, could be dropdown later if we have constants)\r\n    let typeHtml = '';\r\n\r\n    if (currentCategoryName === 'ground') {\r\n        // RENDER GROUND BADGES (Cat | Mat)\r\n        typeHtml = `\r\n         <div class=\"control-wrapper\" style=\"width:100%;\">\r\n             <span class=\"badge-static\" \r\n                style=\"display:block; width:100%; color:#9b59b6; border:1px solid #9b59b640; background:#9b59b610; padding:2px 0; font-size:0.7rem; border-radius:4px; text-transform:uppercase; font-weight:bold;\">\r\n                ${groundCategory}\r\n            </span>\r\n        </div>\r\n        <div class=\"control-wrapper\" style=\"width:100%;\">\r\n             <span class=\"badge-static\" \r\n                style=\"display:block; width:100%; color:#e67e22; border:1px solid #e67e2240; background:#e67e2210; padding:2px 0; font-size:0.7rem; border-radius:4px; text-transform:uppercase; font-weight:bold;\">\r\n                ${groundMaterial}\r\n            </span>\r\n        </div>\r\n        `;\r\n    } else {\r\n        typeHtml = typeLabel ? `\r\n            <div class=\"control-wrapper\" title=\"Type: ${typeLabel}\" style=\"width:100%;\">\r\n                <span class=\"badge-static\" \r\n                    style=\"display:block; width:100%; color:${typeColor}; border:1px solid ${typeColor}40; background:${typeColor}10; padding:2px 0; font-size:0.7rem; border-radius:4px; text-transform:uppercase; font-weight:bold; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;\">\r\n                    ${typeLabel}\r\n                </span>\r\n            </div>\r\n        ` : '<div class=\"control-wrapper\" style=\"width:100%;\"></div>';\r\n    }\r\n\r\n    // 4. BIOME (Interactive Select)\r\n    // Valid biomes from BiomeConfig + global\r\n    const biomes = ['grasslands', 'tundra', 'desert', 'badlands', 'global'];\r\n    const rawBiome = item.biome; // Can be undefined\r\n    const displayBiome = rawBiome || 'global'; // Default for selection/color\r\n\r\n    // If missing, use a distinct style (e.g. Warning/Red) to prompt user\r\n    const isMissing = !rawBiome;\r\n    const biomeColor = isMissing ? '#e74c3c' : (BIOME_COLORS[displayBiome.toLowerCase()] || '#7f8c8d');\r\n\r\n    const biomeOptions = biomes.map(b =>\r\n        `<option value=\"${b}\" ${b === displayBiome ? 'selected' : ''}>${b.toUpperCase()}${isMissing && b === 'global' ? '*' : ''}</option>`\r\n    ).join('');\r\n\r\n    const biomeHtml = `\r\n         <div class=\"control-wrapper\" title=\"${isMissing ? 'Biome Not Set (Defaulting to Global)' : 'Biome'}\" style=\"width:100%;\">\r\n            <select class=\"badge-select\" \r\n                style=\"width:100%; color:${biomeColor}; border:1px solid ${biomeColor}40; background:${biomeColor}10; padding:2px 0; text-align:center; ${isMissing ? 'font-style:italic;' : ''}\" \r\n                data-action=\"update-field\" \r\n                data-field=\"biome\" \r\n                data-category=\"${currentCategoryName}\" \r\n                data-file=\"${fileName}\" \r\n                data-id=\"${item.id}\" \r\n                data-capture-value=\"true\"\r\n                onclick=\"event.stopPropagation()\">\r\n                ${isMissing ? `<option value=\"\" disabled selected>SET BIOME</option>` : ''}\r\n                ${biomeOptions}\r\n            </select>\r\n        </div>\r\n    `;\r\n\r\n    // 5. SIZE Label & Buttons\r\n    const size = item.display?.width || 128;\r\n    const sizeMap = [\r\n        { label: 'XS', val: 64 },\r\n        { label: 'S', val: 128 },\r\n        { label: 'M', val: 256 },\r\n        { label: 'L', val: 512 },\r\n        { label: 'XL', val: 1024 }\r\n    ];\r\n\r\n    const sizeBadges = sizeMap.map(s => {\r\n        const isActive = size === s.val;\r\n        // Used to be button, let's keep it compact\r\n        return `<button class=\"size-badge ${isActive ? 'active' : ''}\" \r\n            data-action=\"update-display-size\" \r\n            data-category=\"${currentCategoryName}\" \r\n            data-file=\"${fileName}\" \r\n            data-id=\"${item.id}\" \r\n            data-value=\"${s.val}\">${s.label}</button>`;\r\n    }).join('');\r\n\r\n    const sizeHtml = `<div class=\"size-controls\" style=\"gap:2px; padding:2px;\">${sizeBadges}</div>`;\r\n\r\n    // 6. SFX (Interactive Pills with Names)\r\n    let sfxHtml = '';\r\n    if (item.sfx && Object.keys(item.sfx).length > 0) {\r\n        const sfxItems = Object.entries(item.sfx).map(([key, val]) => {\r\n            const hasFile = typeof val === 'object' ? !!val.id : !!val;\r\n            const sfxId = typeof val === 'string' ? val : (val as { id: string }).id;\r\n\r\n            // Interactive button to play\r\n            return `<button class=\"mini-sfx-btn ${hasFile ? 'has-sound' : 'missing'}\" \r\n                data-action=\"play-sound\" \r\n                data-id=\"${sfxId}\" \r\n                title=\"Play ${key}\"\r\n                style=\"margin-bottom:4px; margin-right:4px;\">\r\n                <span></span> <span class=\"sfx-label\">${key}</span>\r\n            </button>`;\r\n        }).join('');\r\n        if (sfxItems) sfxHtml = `<div class=\"asset-details-row sfx-row\" style=\"flex-wrap:wrap; gap:8px; margin-top:8px;\">${sfxItems}</div>`;\r\n    }\r\n\r\n    // 7. DROPS\r\n    let dropsHtml = '';\r\n    const drops = item.loot;\r\n    if (drops && drops.length > 0) {\r\n        // Dynamic Drop Size\r\n        const dropSize = Math.max(48, Math.floor((categoryImageSize - 16) / 2));\r\n\r\n        const dropItems = drops.map(d => {\r\n            const chance = d.chance !== undefined ? (d.chance <= 1 ? Math.round(d.chance * 100) : d.chance) : 100;\r\n            const dropInfo = globalAssetLookup[d.item] || globalAssetLookup['item_' + d.item] || null;\r\n            const dropImgPath = dropInfo ? `/images/${dropInfo.path}` : '/images/PH.png';\r\n\r\n            const dropActionAttrs = dropInfo\r\n                ? `data-action=\"navigate-asset\" data-category=\"${dropInfo.category}\" data-id=\"${d.item}\" style=\"width:${dropSize}px; height:${dropSize}px; margin-bottom:4px; cursor:pointer;\"`\r\n                : `style=\"width:${dropSize}px; height:${dropSize}px; margin-bottom:4px;\"`;\r\n\r\n            return `\r\n                <div class=\"drop-item\" ${dropActionAttrs} title=\"${d.item} (${chance}%)\">\r\n                    <img src=\"${dropImgPath}\" onerror=\"this.src='/images/PH.png'\" class=\"drop-img\">\r\n                    <span class=\"drop-overlay name\">${d.item}</span>\r\n                    <span class=\"drop-overlay chance\">${chance}%</span>\r\n                </div>\r\n            `;\r\n        }).join('');\r\n        dropsHtml = `<div class=\"asset-details-row drops-row\" style=\"display:flex; flex-wrap:wrap; gap:8px; justify-content:center; margin-top:8px;\">${dropItems}</div>`;\r\n    }\r\n\r\n    // 7c. NODE DROPS (Specific to Nodes)\r\n    // Nodes might use 'drops' (Fishing) or 'resourceDrop' (Legacy) or 'loot' (Standard)\r\n    // We normalize this to a single list to display.\r\n    if (currentCategoryName === 'nodes') {\r\n        let nodeDrops: Array<{ id: string, chance?: number }> = [];\r\n\r\n        // 1. Check 'drops' array (Fishing style)\r\n        if (item.drops && Array.isArray(item.drops)) {\r\n            nodeDrops = item.drops.map((d) => ({\r\n                id: d.item,\r\n                chance: d.chance\r\n            }));\r\n        }\r\n        // 2. Check 'loot' array (Standard style)\r\n        else if (item.loot && Array.isArray(item.loot)) {\r\n            nodeDrops = item.loot.map((d) => ({\r\n                id: d.item,\r\n                chance: d.chance\r\n            }));\r\n        }\r\n        // 3. Check 'resourceDrop' string (Legacy style)\r\n        else if (item.resourceDrop) {\r\n            nodeDrops = [{ id: item.resourceDrop, chance: 1 }];\r\n        }\r\n\r\n        if (nodeDrops.length > 0) {\r\n            // Reuse drop size\r\n            const dropSize = Math.max(48, Math.floor((categoryImageSize - 16) / 2));\r\n\r\n            const dropItems = nodeDrops.map(d => {\r\n                const assetInfo = globalAssetLookup[d.id] || null;\r\n                const dropImgPath = assetInfo ? `/images/${assetInfo.path}` : '/images/PH.png';\r\n                const chance = d.chance != null ? (d.chance > 1 ? d.chance : Math.round(d.chance * 100)) : 100;\r\n\r\n                // Action attributes for click navigation\r\n                const actionAttrs = assetInfo\r\n                    ? `data-action=\"navigate-asset\" data-category=\"${assetInfo.category}\" data-id=\"${d.id}\" style=\"cursor:pointer;\"`\r\n                    : '';\r\n\r\n                return `\r\n                    <div class=\"drop-item\" ${actionAttrs} title=\"Drops: ${d.id} (${chance}%)\" style=\"width:${dropSize}px; height:${dropSize}px; position:relative; background:#111; border-radius:4px; border:1px solid #444;\">\r\n                        <img src=\"${dropImgPath}\" onerror=\"this.src='/images/PH.png'\" class=\"drop-img\" style=\"width:100%; height:100%; object-fit:contain; display:block;\">\r\n                        <span class=\"drop-overlay name\" style=\"position:absolute; top:2px; left:2px; font-size:9px; background:rgba(0,0,0,0.7); padding:1px 3px; pointer-events:none;\">${d.id}</span>\r\n                        <span class=\"drop-overlay chance\" style=\"position:absolute; bottom:2px; right:2px; font-size:9px; background:rgba(0,0,0,0.7); padding:1px 3px; pointer-events:none; color:#4caf50;\">${chance}%</span>\r\n                    </div>\r\n                `;\r\n            }).join('');\r\n            dropsHtml = `<div class=\"asset-details-row drops-row\" style=\"display:flex; flex-wrap:wrap; gap:8px; justify-content:center; margin-top:8px; border-top:1px solid #333; padding-top:4px; \">\r\n                <div style=\"width:100%; text-align:center; font-size:10px; color:#888; margin-bottom:4px;\">DROPS</div>\r\n                ${dropItems}\r\n             </div>`;\r\n        } else {\r\n            // Show N/A if no drops found\r\n            dropsHtml = `<div class=\"asset-details-row\" style=\"margin-top:8px; border-top:1px solid #333; padding-top:8px; text-align:center; \">\r\n                <div style=\"font-size:10px; color:#888;\">DROPS</div>\r\n                <div style=\"font-size:12px; color:#666; font-style:italic;\">N/A</div>\r\n             </div>`;\r\n        }\r\n    }\r\n\r\n\r\n\r\n    // 8. ACTIONS FOOTER - Increased Spacing\r\n    const actionsHtml = `\r\n        <div class=\"card-footer\" style=\"display:flex; flex-direction:column; gap:12px; margin-top:auto; padding-top:12px; border-top:1px solid #333;\">\r\n            <textarea class=\"feedback-input\" \r\n                rows=\"1\"\r\n                placeholder=\"Feedback...\" \r\n                data-action=\"update-field\" \r\n                data-field=\"declineNote\"\r\n                data-category=\"${currentCategoryName}\" \r\n                data-file=\"${fileName}\" \r\n                data-id=\"${item.id}\" \r\n                data-capture-value=\"true\"\r\n                onclick=\"event.stopPropagation()\"\r\n                style=\"min-height:32px; width:100%; resize:none; padding:8px; order:1; font-size:0.85rem;\">${item.declineNote || ''}</textarea>\r\n            \r\n            <div class=\"card-actions\" style=\"display:flex; gap:12px; order:2; flex-wrap:wrap;\">\r\n                <button class=\"action-btn approve\" data-action=\"quick-approve\" data-id=\"${item.id}\" data-file=\"${fileName}\" data-category=\"${currentCategoryName}\" title=\"Approve\" style=\"height:40px; font-weight:800; flex:1;\">APPROVE</button>\r\n                <button class=\"action-btn decline\" data-action=\"quick-decline\" data-id=\"${item.id}\" data-file=\"${fileName}\" data-category=\"${currentCategoryName}\" title=\"Decline\" style=\"height:40px; font-weight:800; flex:1;\">DECLINE</button>\r\n            </div>\r\n        </div>\r\n    `;\r\n\r\n    card.innerHTML = `\r\n        ${statusHtml}\r\n        ${imgHtml}\r\n        <div class=\"asset-header\">\r\n            <input class=\"name-input\" type=\"text\"\r\n                value=\"${item.name || ''}\" \r\n                placeholder=\"${item.id}\"\r\n                title=\"Click to edit name\"\r\n                data-action=\"update-field\" \r\n                data-field=\"name\"\r\n                data-category=\"${currentCategoryName}\" \r\n                data-file=\"${fileName}\" \r\n                data-id=\"${item.id}\" \r\n                data-capture-value=\"true\"\r\n                onclick=\"event.stopPropagation()\"\r\n                onfocus=\"this.select()\"\r\n                style=\"width:100%; background:transparent; border:none; color:#ddd; font-weight:bold; font-size:1rem; margin-bottom:8px; padding:2px 4px; border-radius:4px; text-overflow:ellipsis;\">\r\n        </div>\r\n        \r\n        <div class=\"asset-controls-row\" style=\"display:grid; grid-template-columns: repeat(3, 1fr); gap:4px; margin-bottom:8px;\">\r\n            ${showTier ? `<div style=\"text-align:center;\">${tierHtml}</div>` : ''}\r\n            ${showTier ? `<div style=\"text-align:center;\">${typeHtml}</div>` : `<div style=\"grid-column: span 2; display:grid; grid-template-columns: 1fr 1fr; gap:4px;\">${typeHtml}</div>`}\r\n            <div style=\"text-align:center;\">${biomeHtml}</div>\r\n        </div>\r\n        <div style=\"display:flex; justify-content:center; margin-bottom:12px;\">\r\n             ${sizeHtml}\r\n        </div>\r\n\r\n        ${sfxHtml}\r\n        ${dropsHtml}\r\n        \r\n        <div class=\"spacer\" style=\"flex:1\"></div>\r\n        ${actionsHtml}\r\n    `;\r\n\r\n    return card;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\dashboard\\src\\configRenderer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\dashboard\\src\\domBuilder.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\dashboard\\src\\filters.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\dashboard\\src\\inspectorRenderer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\dashboard\\src\\legacyAssets.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'renderToString' is defined but never used.","line":6,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":27,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"renderToString"},"fix":{"range":[131,147],"text":""},"desc":"Remove unused variable \"renderToString\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setCurrentCategory' is defined but never used.","line":14,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":23,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"setCurrentCategory"},"fix":{"range":[294,319],"text":""},"desc":"Remove unused variable \"setCurrentCategory\"."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Legacy Assets Module\r\n * Functions for manifest-based asset rendering (original dashboard functionality)\r\n */\r\n\r\nimport { h, renderToString } from './domBuilder';\r\nimport {\r\n    manifest,\r\n    declineNotes,\r\n    assetPrompts,\r\n    currentFilter,\r\n    currentCategory,\r\n    missingAssets,\r\n    setCurrentCategory,\r\n    BASE_PATH,\r\n} from './state';\r\n\r\n// ============================================\r\n// CATEGORY FILTERS\r\n// ============================================\r\n\r\nexport function buildCategoryFilters(): void {\r\n    if (!manifest || !manifest.assets) return;\r\n\r\n    const categoryStats: Record<string, { total: number; clean: number; pending: number; approved: number }> = {};\r\n    manifest.assets.forEach((a) => {\r\n        if (!categoryStats[a.category]) {\r\n            categoryStats[a.category] = { total: 0, clean: 0, pending: 0, approved: 0 };\r\n        }\r\n        categoryStats[a.category].total++;\r\n        if (a.status === 'clean') categoryStats[a.category].clean++;\r\n        if (a.status === 'pending') categoryStats[a.category].pending++;\r\n        if (a.status === 'approved') categoryStats[a.category].approved++;\r\n    });\r\n\r\n    const sorted = Object.keys(categoryStats).sort();\r\n    const totalAssets = manifest.assets.length;\r\n    const totalClean = manifest.assets.filter((a) => a.status === 'clean').length;\r\n\r\n    const container = document.getElementById('categoryFilters');\r\n    if (!container) return;\r\n\r\n    // Clear container\r\n    container.innerHTML = '';\r\n\r\n    // \"All\" button\r\n    const allBtn = h('button', {\r\n        className: `filter-btn secondary ${currentCategory === 'all' ? 'active' : ''}`,\r\n        'data-action': 'filter-category',\r\n        'data-category': 'all'\r\n    }, [`All (${totalClean}/${totalAssets})`]);\r\n    container.appendChild(allBtn);\r\n\r\n    // Category buttons\r\n    sorted.forEach((cat) => {\r\n        const stats = categoryStats[cat];\r\n        const btn = h('button', {\r\n            className: `filter-btn secondary ${currentCategory === cat ? 'active' : ''}`,\r\n            'data-action': 'filter-category',\r\n            'data-category': cat\r\n        }, [`${cat} (${stats.clean}/${stats.total})`]);\r\n        container.appendChild(btn);\r\n    });\r\n}\r\n\r\n// ============================================\r\n// RENDER ASSETS\r\n// ============================================\r\n\r\nexport function renderAssets(): void {\r\n    const container = document.getElementById('mainContent');\r\n    if (!container) return;\r\n    container.innerHTML = '';\r\n\r\n    if (currentFilter === 'missing') {\r\n        if (missingAssets.length === 0) {\r\n            container.innerHTML =\r\n                '<div class=\"loading\" style=\"color: var(--accent-green);\"> No missing assets! All AssetLoader IDs have valid files.</div>';\r\n            return;\r\n        }\r\n\r\n        const cards = missingAssets.map(item => {\r\n            return h('div', { className: 'asset-card declined' }, [\r\n                h('div', { style: 'padding:1rem; background:#eee; height:100px; display:flex; align-items:center; justify-content:center;' }, [\r\n                    h('span', { style: 'font-size:2rem;' }, [''])\r\n                ]),\r\n                h('div', { className: 'asset-info' }, [\r\n                    h('div', { className: 'asset-name', style: 'color:var(--ink-red);' }, [item.id]),\r\n                    h('div', { style: 'font-size:0.7rem; color:#000; margin-top:0.25rem;' }, [`Expected: ${item.expectedFile}`])\r\n                ])\r\n            ]);\r\n        });\r\n\r\n        const categoryEl = h('div', { className: 'category' }, [\r\n            h('div', { className: 'category-header' }, [\r\n                h('h2', { className: 'category-title' }, [' Missing Assets in AssetLoader.js']),\r\n                h('span', { style: 'color: var(--accent)' }, [`${missingAssets.length} assets pointing to PH.png`])\r\n            ]),\r\n            h('div', { className: 'asset-grid' }, cards)\r\n        ]);\r\n\r\n        container.appendChild(categoryEl);\r\n        return;\r\n    }\r\n\r\n    if (!manifest || !manifest.assets) return;\r\n\r\n    const categories: Record<string, typeof manifest.assets> = {};\r\n    manifest.assets.forEach((asset) => {\r\n        if (currentFilter !== 'all' && asset.status !== currentFilter) return;\r\n        if (currentCategory !== 'all' && asset.category !== currentCategory) return;\r\n        if (!categories[asset.category]) categories[asset.category] = [];\r\n        categories[asset.category].push(asset);\r\n    });\r\n\r\n    const sortedCategories = Object.keys(categories).sort();\r\n    for (const category of sortedCategories) {\r\n        const assets = categories[category];\r\n\r\n        const cards = assets.map(asset => createAssetCard(asset));\r\n\r\n        const categoryEl = h('div', { className: 'category' }, [\r\n            h('div', { className: 'category-header' }, [\r\n                h('h2', { className: 'category-title' }, [category]),\r\n                h('span', { style: 'color: var(--text-dim)' }, [`${assets.length} assets`])\r\n            ]),\r\n            h('div', { className: 'asset-grid' }, cards)\r\n        ]);\r\n\r\n        container.appendChild(categoryEl);\r\n    }\r\n\r\n    if (sortedCategories.length === 0)\r\n        container.innerHTML = '<div class=\"loading\">No assets match the current filter.</div>';\r\n}\r\n\r\n// ============================================\r\n// CREATE ASSET CARD\r\n// ============================================\r\n\r\nfunction createAssetCard(asset: { path: string; name: string; status: string }): HTMLElement {\r\n    const safeId = asset.name.replace(/[^a-zA-Z0-9]/g, '_');\r\n    const imgPath = BASE_PATH + asset.path;\r\n    const existingNotes = declineNotes[asset.name] || '';\r\n\r\n    let actions: HTMLElement[] = [];\r\n    let notesInput: HTMLElement | null = null;\r\n\r\n    // Common approve button\r\n    const approveBtn = h('button', {\r\n        className: 'approve',\r\n        'data-action': 'approve-asset',\r\n        'data-path': asset.path\r\n    }, [' Approve']);\r\n\r\n    // Common decline button\r\n    const declineBtn = h('button', {\r\n        className: 'decline',\r\n        'data-action': 'decline-asset',\r\n        'data-path': asset.path,\r\n        'data-name': asset.name,\r\n        'data-safe-id': safeId,\r\n        // declineAsset reads the note from input. ID is needed.\r\n        // Wait, `declineAsset(path, name, safeId)` does:\r\n        // note = document.getElementById(`notes_${safeId}`).value\r\n        // So simply passing safeId is enough for it to find the input if we name it correctly.\r\n    }, [' Decline']);\r\n\r\n    if (asset.status === 'pending') {\r\n        notesInput = h('input', {\r\n            type: 'text',\r\n            id: `notes_${safeId}`,\r\n            className: 'notes-input',\r\n            placeholder: 'Decline reason...',\r\n            value: existingNotes\r\n        });\r\n        actions = [approveBtn, declineBtn];\r\n    } else if (asset.status === 'approved') {\r\n        const declinePromptBtn = h('button', {\r\n            className: 'decline',\r\n            'data-action': 'decline-asset-prompt',\r\n            'data-path': asset.path,\r\n            'data-name': asset.name\r\n        }, [' Decline']);\r\n        actions = [declinePromptBtn];\r\n    } else if (asset.status === 'declined') {\r\n        actions = [h('button', {\r\n            className: 'approve',\r\n            'data-action': 'approve-asset',\r\n            'data-path': asset.path\r\n        }, [' Re-approve'])];\r\n    } else if (asset.status === 'clean') {\r\n        notesInput = h('input', {\r\n            type: 'text',\r\n            id: `notes_${safeId}`,\r\n            className: 'notes-input',\r\n            placeholder: 'Remake instructions...',\r\n            value: existingNotes\r\n        });\r\n\r\n        const remakeBtn = h('button', {\r\n            className: 'secondary',\r\n            'data-action': 'remake-asset',\r\n            'data-path': asset.path,\r\n            'data-name': asset.name,\r\n            'data-safe-id': safeId,\r\n            style: 'background:var(--brass); color:white;'\r\n        }, [' Remake']);\r\n\r\n        actions = [remakeBtn];\r\n    }\r\n\r\n    // Prompt Preview\r\n    let baseNameForPrompt = asset.name.replace('_approved', '').replace('_declined', '');\r\n    if (baseNameForPrompt.includes('_clean')) {\r\n        baseNameForPrompt = baseNameForPrompt.replace('_clean', '_original');\r\n    }\r\n    const prompt = assetPrompts[baseNameForPrompt] || assetPrompts[asset.name] || '';\r\n    const promptPreview = prompt\r\n        ? h('div', {\r\n            className: 'prompt-preview',\r\n            title: prompt.replace(/\"/g, '&quot;')\r\n        }, [` ${prompt.substring(0, 40)}${prompt.length > 40 ? '...' : ''}`])\r\n        : null;\r\n\r\n    // Notes Display for Declined\r\n    const notesDisplay = (asset.status === 'declined' && existingNotes)\r\n        ? h('div', {\r\n            style: 'font-size:0.7rem; color:var(--ink-red); margin-top:0.3rem; font-style:italic;'\r\n        }, [` ${existingNotes}`])\r\n        : null;\r\n\r\n\r\n    const cardChildren: HTMLElement[] = [\r\n        h('div', { className: 'asset-name' }, [asset.name]),\r\n        h('span', { className: `asset-status status-${asset.status}` }, [asset.status]),\r\n        promptPreview,\r\n        notesDisplay,\r\n        notesInput,\r\n        h('div', { className: 'asset-actions' }, actions)\r\n    ];\r\n\r\n    const card = h('div', {\r\n        className: `asset-card ${asset.status}`,\r\n        'data-path': asset.path\r\n    }, [\r\n        h('img', {\r\n            className: 'asset-image',\r\n            src: imgPath,\r\n            alt: asset.name,\r\n            'data-action': 'open-modal',\r\n            'data-path': imgPath,\r\n            'data-name': asset.name,\r\n            'data-status': asset.status,\r\n            // onerror must still be inline or handled via delegation on 'error' event (not bubbly)\r\n            // delegation doesn't capture 'error'. \r\n            // We can keep inline onerror=\"this.style.display='none'\" as it is standard self-contained logic\r\n            onerror: \"this.style.display='none'\"\r\n        }),\r\n        h('div', { className: 'asset-info' }, cardChildren)\r\n    ]);\r\n\r\n    return card;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\dashboard\\src\\lootRenderer.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'lootData' is defined but never used.","line":6,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":18,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"lootData"},"fix":{"range":[102,111],"text":""},"desc":"Remove unused variable \"lootData\"."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Loot Renderer\r\n * Renders the loot view with resources, items, and equipment\r\n */\r\n\r\nimport { lootData, setLootData, setLootDataHash, lootFilter, setLootFilterValue } from './state';\r\n\r\n// ============================================\r\n// SHOW LOOT VIEW\r\n// ============================================\r\n\r\nexport async function showLootView(): Promise<void> {\r\n    const container = document.getElementById('mainContent');\r\n    if (!container) return;\r\n\r\n    container.innerHTML = '<div class=\"loading\">Loading loot data...</div>';\r\n\r\n    try {\r\n        const resp = await fetch('/api/get_loot', { method: 'POST', body: '{}' });\r\n        const data = await resp.json();\r\n        setLootData(data);\r\n        setLootDataHash(JSON.stringify(data));\r\n        renderLootView();\r\n    } catch (err) {\r\n        container.innerHTML = '<div class=\"error\">Failed to load loot data: ' + (err as Error).message + '</div>';\r\n    }\r\n}\r\n\r\n// ============================================\r\n// FILTER SETTERS\r\n// ============================================\r\n\r\nexport function setLootCategoryFilter(category: string): void {\r\n    setLootFilterValue({ category });\r\n    renderLootView();\r\n}\r\n\r\nexport function setBiomeLootFilter(biome: string): void {\r\n    setLootFilterValue({ biome: lootFilter.biome === biome ? 'all' : biome });\r\n    renderLootView();\r\n}\r\n\r\nexport function setTierLootFilter(tier: string | number): void {\r\n    setLootFilterValue({ tier: lootFilter.tier === tier ? 'all' : tier });\r\n    renderLootView();\r\n}\r\n\r\n// ============================================\r\n// RENDER LOOT VIEW\r\n// ============================================\r\n\r\nexport function renderLootView(): void {\r\n    const container = document.getElementById('mainContent');\r\n    if (!container) return;\r\n\r\n    container.innerHTML = '<div class=\"loading\">Loot view coming soon...</div>';\r\n    // Full implementation can be migrated from asset_dashboard.html\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\dashboard\\src\\main.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'categoryData' is defined but never used.","line":9,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":17,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"categoryData"},"fix":{"range":[199,218],"text":""},"desc":"Remove unused variable \"categoryData\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'currentCategoryName' is defined but never used.","line":11,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":24,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"currentCategoryName"},"fix":{"range":[240,266],"text":""},"desc":"Remove unused variable \"currentCategoryName\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'updateCategoryStatus' is defined but never used.","line":14,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":25,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"updateCategoryStatus"},"fix":{"range":[302,323],"text":""},"desc":"Remove unused variable \"updateCategoryStatus\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'updateConsumedStatus' is defined but never used.","line":15,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":25,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"updateConsumedStatus"},"fix":{"range":[322,349],"text":""},"desc":"Remove unused variable \"updateConsumedStatus\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'updateItemWeapon' is defined but never used.","line":16,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":16,"endColumn":21,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"updateItemWeapon"},"fix":{"range":[349,372],"text":""},"desc":"Remove unused variable \"updateItemWeapon\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'updateItemStat' is defined but never used.","line":17,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":17,"endColumn":19,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"updateItemStat"},"fix":{"range":[372,393],"text":""},"desc":"Remove unused variable \"updateItemStat\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'updateItemField' is defined but never used.","line":18,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":18,"endColumn":20,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"updateItemField"},"fix":{"range":[393,415],"text":""},"desc":"Remove unused variable \"updateItemField\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'updateItemTier' is defined but never used.","line":19,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":19,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"updateItemTier"},"fix":{"range":[415,436],"text":""},"desc":"Remove unused variable \"updateItemTier\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'updateDisplayField' is defined but never used.","line":20,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":20,"endColumn":23,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"updateDisplayField"},"fix":{"range":[436,461],"text":""},"desc":"Remove unused variable \"updateDisplayField\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'updateWeaponMeta' is defined but never used.","line":21,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":21,"endColumn":21,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"updateWeaponMeta"},"fix":{"range":[461,484],"text":""},"desc":"Remove unused variable \"updateWeaponMeta\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'syncEntitiesToJson' is defined but never used.","line":22,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":22,"endColumn":23,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"syncEntitiesToJson"},"fix":{"range":[484,509],"text":""},"desc":"Remove unused variable \"syncEntitiesToJson\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'markSfxForRegeneration' is defined but never used.","line":23,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":23,"endColumn":27,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"markSfxForRegeneration"},"fix":{"range":[509,538],"text":""},"desc":"Remove unused variable \"markSfxForRegeneration\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'updateDisplaySize' is defined but never used.","line":25,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":25,"endColumn":22,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"updateDisplaySize"},"fix":{"range":[572,596],"text":""},"desc":"Remove unused variable \"updateDisplaySize\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'openModal' is defined but never used.","line":30,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":30,"endColumn":19,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"openModal"},"fix":{"range":[716,726],"text":""},"desc":"Remove unused variable \"openModal\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'closeModal' is defined but never used.","line":30,"column":21,"nodeType":"Identifier","messageId":"unusedVar","endLine":30,"endColumn":31,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"closeModal"},"fix":{"range":[725,737],"text":""},"desc":"Remove unused variable \"closeModal\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'toggleComparisonView' is defined but never used.","line":30,"column":33,"nodeType":"Identifier","messageId":"unusedVar","endLine":30,"endColumn":53,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"toggleComparisonView"},"fix":{"range":[737,759],"text":""},"desc":"Remove unused variable \"toggleComparisonView\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'showLandingPage' is defined but never used.","line":32,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":32,"endColumn":20,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"showLandingPage"},"fix":{"range":[813,829],"text":""},"desc":"Remove unused variable \"showLandingPage\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'navigateToAsset' is defined but never used.","line":35,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":35,"endColumn":20,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"navigateToAsset"},"fix":{"range":[870,892],"text":""},"desc":"Remove unused variable \"navigateToAsset\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'approveCategoryItem' is defined but never used.","line":36,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":36,"endColumn":24,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"approveCategoryItem"},"fix":{"range":[892,918],"text":""},"desc":"Remove unused variable \"approveCategoryItem\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'declineCategoryItem' is defined but never used.","line":37,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":37,"endColumn":24,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"declineCategoryItem"},"fix":{"range":[918,944],"text":""},"desc":"Remove unused variable \"declineCategoryItem\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'remakeCategoryItem' is defined but never used.","line":38,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":38,"endColumn":23,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"remakeCategoryItem"},"fix":{"range":[944,969],"text":""},"desc":"Remove unused variable \"remakeCategoryItem\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'declineCategoryItemById' is defined but never used.","line":39,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":39,"endColumn":28,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"declineCategoryItemById"},"fix":{"range":[969,999],"text":""},"desc":"Remove unused variable \"declineCategoryItemById\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'remakeCategoryItemById' is defined but never used.","line":40,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":40,"endColumn":27,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"remakeCategoryItemById"},"fix":{"range":[999,1028],"text":""},"desc":"Remove unused variable \"remakeCategoryItemById\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'approveAsset' is defined but never used.","line":41,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":41,"endColumn":17,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"approveAsset"},"fix":{"range":[1028,1047],"text":""},"desc":"Remove unused variable \"approveAsset\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'declineAsset' is defined but never used.","line":42,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":42,"endColumn":17,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"declineAsset"},"fix":{"range":[1047,1066],"text":""},"desc":"Remove unused variable \"declineAsset\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'declineAssetPrompt' is defined but never used.","line":43,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":43,"endColumn":23,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"declineAssetPrompt"},"fix":{"range":[1066,1091],"text":""},"desc":"Remove unused variable \"declineAssetPrompt\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'startAutoRefresh' is defined but never used.","line":44,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":44,"endColumn":21,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"startAutoRefresh"},"fix":{"range":[1091,1114],"text":""},"desc":"Remove unused variable \"startAutoRefresh\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'stopAutoRefresh' is defined but never used.","line":45,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":45,"endColumn":20,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"stopAutoRefresh"},"fix":{"range":[1114,1136],"text":""},"desc":"Remove unused variable \"stopAutoRefresh\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setCategoryStatusFilter' is defined but never used.","line":50,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":50,"endColumn":28,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"setCategoryStatusFilter"},"fix":{"range":[1251,1275],"text":""},"desc":"Remove unused variable \"setCategoryStatusFilter\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setCategoryBiomeFilter' is defined but never used.","line":51,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":51,"endColumn":27,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"setCategoryBiomeFilter"},"fix":{"range":[1274,1303],"text":""},"desc":"Remove unused variable \"setCategoryBiomeFilter\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setCategoryTierFilter' is defined but never used.","line":52,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":52,"endColumn":26,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"setCategoryTierFilter"},"fix":{"range":[1303,1331],"text":""},"desc":"Remove unused variable \"setCategoryTierFilter\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setCategoryFileFilter' is defined but never used.","line":53,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":53,"endColumn":26,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"setCategoryFileFilter"},"fix":{"range":[1331,1359],"text":""},"desc":"Remove unused variable \"setCategoryFileFilter\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setCategoryWeaponTypeFilter' is defined but never used.","line":54,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":54,"endColumn":32,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"setCategoryWeaponTypeFilter"},"fix":{"range":[1359,1393],"text":""},"desc":"Remove unused variable \"setCategoryWeaponTypeFilter\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setCategoryHandsFilter' is defined but never used.","line":55,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":55,"endColumn":27,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"setCategoryHandsFilter"},"fix":{"range":[1393,1422],"text":""},"desc":"Remove unused variable \"setCategoryHandsFilter\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setCategoryNodeSubtypeFilter' is defined but never used.","line":56,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":56,"endColumn":33,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"setCategoryNodeSubtypeFilter"},"fix":{"range":[1422,1457],"text":""},"desc":"Remove unused variable \"setCategoryNodeSubtypeFilter\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setCategoryImageSize' is defined but never used.","line":57,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":57,"endColumn":25,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"setCategoryImageSize"},"fix":{"range":[1457,1484],"text":""},"desc":"Remove unused variable \"setCategoryImageSize\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setCategorySortOrder' is defined but never used.","line":58,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":58,"endColumn":25,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"setCategorySortOrder"},"fix":{"range":[1484,1511],"text":""},"desc":"Remove unused variable \"setCategorySortOrder\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setLootFilter' is defined but never used.","line":59,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":59,"endColumn":18,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"setLootFilter"},"fix":{"range":[1511,1531],"text":""},"desc":"Remove unused variable \"setLootFilter\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setBiomeFilter' is defined but never used.","line":60,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":60,"endColumn":19,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"setBiomeFilter"},"fix":{"range":[1531,1552],"text":""},"desc":"Remove unused variable \"setBiomeFilter\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setTierFilter' is defined but never used.","line":61,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":61,"endColumn":18,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"setTierFilter"},"fix":{"range":[1237,1594],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'showTemplatesView' is defined but never used.","line":63,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":63,"endColumn":27,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"showTemplatesView"},"fix":{"range":[1596,1644],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'showLootView' is defined but never used.","line":64,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":64,"endColumn":22,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"showLootView"},"fix":{"range":[1646,1692],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'buildCategoryFilters' is defined but never used.","line":65,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":65,"endColumn":30,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"buildCategoryFilters"},"fix":{"range":[1703,1724],"text":""},"desc":"Remove unused variable \"buildCategoryFilters\"."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":43,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Dashboard Main Entry Point\r\n * Initialization and global exports for legacy onclick handlers\r\n */\r\n\r\n// Re-export everything from modules for global access\r\nimport {\r\n    sfxRegenerationQueue,\r\n    categoryData,\r\n    setCategoryData,\r\n    currentCategoryName,\r\n} from './state';\r\nimport {\r\n    updateCategoryStatus,\r\n    updateConsumedStatus,\r\n    updateItemWeapon,\r\n    updateItemStat,\r\n    updateItemField,\r\n    updateItemTier,\r\n    updateDisplayField,\r\n    updateWeaponMeta,\r\n    syncEntitiesToJson,\r\n    markSfxForRegeneration,\r\n    saveRegenerationQueueToFile,\r\n    updateDisplaySize,\r\n    loadGlobalAssetLookup,\r\n    fetchPrompts,\r\n} from './api';\r\nimport { setAssetPrompts } from './state';\r\nimport { openModal, closeModal, toggleComparisonView, initModalHandlers } from './modals';\r\nimport {\r\n    showLandingPage,\r\n    loadManifest,\r\n    showCategoryView,\r\n    navigateToAsset,\r\n    approveCategoryItem,\r\n    declineCategoryItem,\r\n    remakeCategoryItem,\r\n    declineCategoryItemById,\r\n    remakeCategoryItemById,\r\n    approveAsset,\r\n    declineAsset,\r\n    declineAssetPrompt,\r\n    startAutoRefresh,\r\n    stopAutoRefresh,\r\n    showConfigView,\r\n} from './views';\r\nimport { renderCategoryView } from './categoryRenderer';\r\nimport {\r\n    setCategoryStatusFilter,\r\n    setCategoryBiomeFilter,\r\n    setCategoryTierFilter,\r\n    setCategoryFileFilter,\r\n    setCategoryWeaponTypeFilter,\r\n    setCategoryHandsFilter,\r\n    setCategoryNodeSubtypeFilter,\r\n    setCategoryImageSize,\r\n    setCategorySortOrder,\r\n    setLootFilter,\r\n    setBiomeFilter,\r\n    setTierFilter,\r\n} from './filters';\r\nimport { showTemplatesView } from './templates';\r\nimport { showLootView } from './lootRenderer';\r\nimport { buildCategoryFilters, renderAssets } from './legacyAssets';\r\n\r\nimport { initEventDelegation, disposeDelegation } from './ActionDelegator';\r\nimport { initResizeHandle } from './ResizePanels';\r\n\r\n// ============================================\r\n// LIVE POLLING\r\n// ============================================\r\n\r\nfunction startLivePolling(): void {\r\n    // Prevent multiple intervals\r\n    stopLivePolling();\r\n\r\n    window.pollingInterval = setInterval(async () => {\r\n        if (!window.currentViewCategory) {\r\n            return;\r\n        }\r\n\r\n        try {\r\n            const response = await fetch('/api/get_category?_=' + Date.now(), {\r\n                method: 'POST',\r\n                headers: { 'Content-Type': 'application/json', 'Cache-Control': 'no-cache' },\r\n                body: JSON.stringify({ category: window.currentViewCategory }),\r\n            });\r\n            const data = await response.json();\r\n            const entities = data.entities || [];\r\n            const newHash = JSON.stringify(entities);\r\n\r\n            if (window.lastDataHash !== null && newHash !== window.lastDataHash) {\r\n                console.log('[LiveSync] Entity data changed! Refreshing view...');\r\n                setCategoryData(data);\r\n                renderCategoryView();\r\n            }\r\n            window.lastDataHash = newHash;\r\n        } catch {\r\n            // Ignore polling errors\r\n        }\r\n    }, 1500);\r\n    console.log('[LiveSync] Started polling every 1.5s');\r\n}\r\n\r\nfunction stopLivePolling(): void {\r\n    if (window.pollingInterval) {\r\n        clearInterval(window.pollingInterval);\r\n        window.pollingInterval = null;\r\n        console.log('[LiveSync] Stopped polling');\r\n    }\r\n}\r\n\r\n// ============================================\r\n// EQUIPMENT STATS CONFIG\r\n// Defines ALL stats for each equipment category\r\n// ============================================\r\n\r\nwindow.EquipmentStatsConfig = {\r\n    categories: ['offense', 'defense', 'utility'],\r\n    getStatsByCategory: (category: string) => {\r\n        const stats: Record<string, Array<{ key: string; label: string; icon: string; type: string; default: number | boolean }>> = {\r\n            offense: [\r\n                { key: 'damage', label: 'Damage', icon: 'stat_damage', type: 'number', default: 0 },\r\n                { key: 'attackSpeed', label: 'Attack Speed', icon: 'stat_attack_speed', type: 'number', default: 1.0 },\r\n                { key: 'range', label: 'Range', icon: 'stat_range', type: 'number', default: 0 },\r\n                { key: 'critChance', label: 'Crit Chance', icon: 'stat_crit_chance', type: 'number', default: 0 },\r\n                { key: 'critDamage', label: 'Crit Damage', icon: 'stat_crit_damage', type: 'number', default: 1.5 },\r\n            ],\r\n            defense: [\r\n                { key: 'armor', label: 'Armor', icon: 'stat_armor', type: 'number', default: 0 },\r\n                { key: 'health', label: 'Health', icon: 'stat_health', type: 'number', default: 0 },\r\n                { key: 'stamina', label: 'Stamina', icon: 'stat_stamina', type: 'number', default: 0 },\r\n                { key: 'speed', label: 'Speed', icon: 'stat_speed', type: 'number', default: 0 },\r\n            ],\r\n            utility: [\r\n                { key: 'efficiency', label: 'Efficiency', icon: 'stat_efficiency', type: 'number', default: 1.0 },\r\n            ],\r\n        };\r\n        return stats[category] || [];\r\n    },\r\n};\r\n\r\n// ============================================\r\n// INITIALIZATION\r\n// ============================================\r\n\r\nfunction initApp() {\r\n    console.log('[Dashboard] Initializing App...');\r\n\r\n    try {\r\n        // Replace loading message immediately so we never stay stuck\r\n        loadManifest();\r\n\r\n        // Initialize Event Delegation (Replaces inline onclicks)\r\n        initEventDelegation();\r\n\r\n        // Resizable sidebars\r\n        initResizeHandle('resize-sidebar', 'sidebar', true, {\r\n            defaultPx: 260,\r\n            storageKey: 'dashboard-sidebar-width',\r\n        });\r\n        initResizeHandle('resize-inspector', 'inspectorPanel', false, {\r\n            defaultPx: 350,\r\n            storageKey: 'dashboard-inspector-width',\r\n        });\r\n\r\n    // Load Global Asset Lookup (for Drops/Sources)\r\n    loadGlobalAssetLookup().then(() => {\r\n        // If we are already on a view, re-render to show drops/sources\r\n        if (window.currentViewCategory) {\r\n            import('./categoryRenderer').then(({ renderCategoryView }) => {\r\n                renderCategoryView();\r\n            });\r\n        }\r\n    });\r\n\r\n    // Load Asset Prompts\r\n    fetchPrompts().then((data) => {\r\n        setAssetPrompts(data || {});\r\n        // If inspector is open, we might want to re-render it, but usually this is fast enough\r\n    });\r\n\r\n    // Set up filter button listeners\r\n    // Note: If these elements exist in static HTML, they might accumulate listeners on re-run\r\n    // Ideally we should use delegation for these too, but for now we'll assume they are safe-ish \r\n    // or we should replace them to strip listeners.\r\n    document.querySelectorAll('.filter-btn').forEach((btn) => {\r\n        // Cloning removes listeners\r\n        const newBtn = btn.cloneNode(true);\r\n        btn.parentNode?.replaceChild(newBtn, btn);\r\n\r\n        newBtn.addEventListener('click', () => {\r\n            document.querySelectorAll('.filter-btn').forEach((b) => b.classList.remove('active'));\r\n            (newBtn as HTMLElement).classList.add('active');\r\n            const filter = (newBtn as HTMLElement).dataset.filter;\r\n            if (filter) {\r\n                import('./state').then(({ setCurrentFilter }) => {\r\n                    setCurrentFilter(filter);\r\n                    renderAssets();\r\n                });\r\n            }\r\n        });\r\n    });\r\n\r\n    // Keyboard & Mouse handlers for modal\r\n    initModalHandlers();\r\n\r\n    // Sync SFX regeneration queue from localStorage to server on load\r\n    if (sfxRegenerationQueue && sfxRegenerationQueue.length > 0) {\r\n        console.log(`[Dashboard] Syncing ${sfxRegenerationQueue.length} SFX queue items to server...`);\r\n        saveRegenerationQueueToFile();\r\n    }\r\n\r\n    // Handle Browser Navigation (Back/Forward)\r\n    // Clean up old popstate if it exists? \r\n    // window.onpopstate is cleaner for replacement than addEventListener\r\n    window.onpopstate = (event) => {\r\n        // Always try to hide map editor first to ensure clean state\r\n        import('@dashboard/mapEditorView').then(({ hideMapEditorView }) => hideMapEditorView());\r\n\r\n        if (event.state && event.state.view === 'map') {\r\n            import('@dashboard/mapEditorView').then((m) => m.showMapEditorView(false));\r\n        } else if (event.state && event.state.view === 'config') {\r\n            showConfigView(false);\r\n        } else if (event.state && event.state.category) {\r\n            showCategoryView(event.state.category, false);\r\n        } else {\r\n            loadManifest();\r\n        }\r\n    };\r\n\r\n        // Check URL for initial view/category (Only on fresh load or if we want to reset view on HMR)\r\n        if (!window.currentViewCategory) {\r\n            const urlParams = new URLSearchParams(window.location.search);\r\n            const viewParam = urlParams.get('view');\r\n            const categoryParam = urlParams.get('category');\r\n\r\n            if (viewParam === 'map') {\r\n                import('@dashboard/mapEditorView').then((m) => m.showMapEditorView(false));\r\n            } else if (viewParam === 'config') {\r\n                showConfigView(false);\r\n            } else if (categoryParam) {\r\n                showCategoryView(categoryParam, false);\r\n            }\r\n            // else: loadManifest already called above\r\n        } else {\r\n            if (window.currentViewCategory) {\r\n                renderCategoryView();\r\n            }\r\n        }\r\n\r\n        // Start live polling\r\n        startLivePolling();\r\n    } catch (err) {\r\n        console.error('[Dashboard] Init failed:', err);\r\n        loadManifest(); // Fallback so user at least sees landing page\r\n    }\r\n}\r\n\r\n// Boot - ensure we never stay stuck on \"Loading...\"\r\nlet booted = false;\r\nfunction boot(): void {\r\n    if (booted) return;\r\n    booted = true;\r\n    try {\r\n        initApp();\r\n    } catch (err) {\r\n        console.error('[Dashboard] Boot failed:', err);\r\n        loadManifest();\r\n    }\r\n}\r\n\r\nif (document.readyState === 'loading') {\r\n    document.addEventListener('DOMContentLoaded', boot);\r\n    // Fallback: if DOMContentLoaded never fires (e.g. script blocking), run after 2s\r\n    setTimeout(boot, 2000);\r\n} else {\r\n    boot();\r\n}\r\n\r\nconsole.log('[Dashboard] TypeScript modules loaded');\r\n\r\n// ============================================\r\n// HMR Configuration\r\n// ============================================\r\nif (import.meta.hot) {\r\n    import.meta.hot.accept(() => {\r\n        console.log('[HMR] Dashboard module updated. Re-initializing...');\r\n        // initApp will be called because this module is re-executed\r\n        // But we are inside the accept callback of the *previous* module?\r\n        // No, import.meta.hot.accept() means \"I accept updates\".\r\n        // When update happens, the NEW module is executed.\r\n        // The NEW module's top level code runs.\r\n        // So initApp() above is called by the `else { initApp() }` block because readyState is complete.\r\n    });\r\n\r\n    import.meta.hot.dispose(() => {\r\n        console.log('[HMR] Disposing old dashboard instance...');\r\n        stopLivePolling();\r\n        disposeDelegation();\r\n    });\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\dashboard\\src\\mapEditorView.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ZoneConfig' is defined but never used.","line":3,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":20,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"ZoneConfig"},"fix":{"range":[127,138],"text":""},"desc":"Remove unused variable \"ZoneConfig\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ZoneCategories' is defined but never used.","line":3,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":36,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"ZoneCategories"},"fix":{"range":[118,192],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'MAP_STORAGE_KEY' is assigned a value but never used.","line":24,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":24,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { MapEditorCore } from '../../../src/tools/map-editor/MapEditorCore';\r\nimport { Logger } from '@core/Logger';\r\nimport { ZoneConfig, ZoneCategories } from '../../../src/data/ZoneConfig';\r\nimport { AssetPaletteView } from './AssetPaletteView';\r\nimport { initResizeHandle } from './ResizePanels';\r\nimport { loadDefaultMap, saveDefaultMap } from './MapStorage';\r\nimport type { MapEditorDataPayload } from '../../../src/tools/map-editor/MapEditorTypes';\r\nimport { OutlinerPanel } from './OutlinerPanel';\r\n\r\n/** Mapgen4 param shape (loaded only when user generates). */\r\ninterface ProcParam {\r\n    spacing: number;\r\n    mountainSpacing: number;\r\n    meshSeed: number;\r\n    elevation: Record<string, number>;\r\n    biomes: Record<string, number>;\r\n    rivers: Record<string, number>;\r\n    towns?: { enabled: boolean; numTowns: number; minSpacing: number; townRadius: number; defaultZoneId: string; elevationMin: number; elevationMax: number; rainfallMin: number; rainfallMax: number; seed?: number };\r\n    roads?: { enabled: boolean; baseWidth: number; shortcutsPerTown: number; riverCrossingCost: number; coverageGridSize?: number; slopeWeight?: number; waypointCurviness?: number; seed?: number };\r\n    railroads?: { enabled: boolean };\r\n}\r\n\r\nconst DEFAULT_MAP_FILENAME = 'default';\r\nconst MAP_STORAGE_KEY = 'map-editor-default-map';\r\n\r\nlet editorInstance: MapEditorCore | null = null;\r\nlet paletteInstance: AssetPaletteView | null = null;\r\nlet currentLoadedMap: string | null = null;\r\n/** Last mapgen4 param from a successful load; used when procCache is null so save does not use form defaults. */\r\nlet lastLoadedMapgen4Param: ProcParam | null = null;\r\n\r\nlet autoSaveTimer: ReturnType<typeof setTimeout> | null = null;\r\nconst AUTO_SAVE_DEBOUNCE_MS = 800;\r\n\r\nconst AUTO_SAVE_STORAGE_KEY = 'map-editor-auto-save';\r\n\r\nfunction getAutoSaveEnabled(): boolean {\r\n    return localStorage.getItem(AUTO_SAVE_STORAGE_KEY) === 'true';\r\n}\r\n\r\nfunction setAutoSaveEnabled(enabled: boolean): void {\r\n    localStorage.setItem(AUTO_SAVE_STORAGE_KEY, String(enabled));\r\n}\r\n\r\nexport async function showMapEditorView(pushState = true): Promise<void> {\r\n    const mainContent = document.getElementById('mainContent');\r\n    const container = document.getElementById('map-editor-container');\r\n    const stickyBar = document.querySelector('.sticky-bar') as HTMLElement;\r\n    const stats = document.querySelector('.stats') as HTMLElement;\r\n\r\n    if (mainContent) mainContent.style.display = 'none';\r\n    if (stickyBar) stickyBar.style.display = 'none';\r\n    if (stats) stats.style.display = 'none';\r\n    if (container) container.style.display = 'flex';\r\n\r\n    if (pushState) {\r\n        const url = new URL(window.location.href);\r\n        url.searchParams.set('view', 'map');\r\n        url.searchParams.delete('category');\r\n        window.history.pushState({ view: 'map' }, '', url.toString());\r\n        window.currentViewCategory = '';\r\n    }\r\n\r\n    document.querySelectorAll('.nav-item').forEach((btn) => {\r\n        btn.classList.remove('active');\r\n        if (btn.getAttribute('data-action') === 'toggle-map-editor') {\r\n            btn.classList.add('active');\r\n        }\r\n    });\r\n\r\n    if (!editorInstance) {\r\n        const loadingOverlay = document.getElementById('map-editor-loading-overlay');\r\n        if (loadingOverlay) loadingOverlay.style.display = 'flex';\r\n\r\n        try {\r\n            // Wait for layout so map-editor-canvas has non-zero dimensions before mount\r\n            await new Promise<void>((r) => requestAnimationFrame(() => requestAnimationFrame(() => r())));\r\n\r\n            editorInstance = new MapEditorCore();\r\n            await editorInstance.mount('map-editor-canvas', async (cat) => {\r\n                const { fetchCategory } = await import('./api');\r\n                return fetchCategory(cat) as unknown;\r\n            });\r\n\r\n            paletteInstance = new AssetPaletteView('palette-content', (id, cat) => {\r\n                if (editorInstance) editorInstance.selectAsset(id, cat);\r\n            });\r\n\r\n            await loadDefaultMapOnFirstOpen();\r\n            initMapPanel();\r\n            if (editorInstance) {\r\n                editorInstance.setOnManualDataChange(() => {\r\n                    OutlinerPanel.refresh();\r\n                    runPreviewCanvas().catch(() => { });\r\n                    if (getAutoSaveEnabled()) scheduleAutoSave();\r\n                });\r\n                editorInstance.setOnCommandExecuted(() => {\r\n                    OutlinerPanel.refresh();\r\n                    if (getAutoSaveEnabled()) scheduleAutoSave();\r\n                });\r\n            }\r\n            initModeAndTools();\r\n            initMapEditorResize();\r\n            initProceduralPreviewClickAndViewport();\r\n            initMapEditBroadcast();\r\n            await runPreviewCanvas({ skipRebuildIfLoaded: true });\r\n            initMapEditorBeforeUnload();\r\n\r\n            const canvasContainer = document.getElementById('map-editor-canvas');\r\n            if (canvasContainer) {\r\n                const ro = new ResizeObserver(() => {\r\n                    editorInstance?.resize?.();\r\n                    editorInstance?.invalidateProceduralViewport?.();\r\n                });\r\n                ro.observe(canvasContainer);\r\n            }\r\n        } catch (err) {\r\n            Logger.error('[MapEditor] First-time init failed', err);\r\n        } finally {\r\n            if (loadingOverlay) loadingOverlay.style.display = 'none';\r\n        }\r\n    } else {\r\n        refreshMapList();\r\n        runPreviewCanvas();\r\n    }\r\n}\r\n\r\n/** Procedural preview uses mapgen4 space 0..1000; editor world is 0..160000 px. */\r\nconst PREVIEW_TO_WORLD = 160000 / 1000;\r\n\r\nfunction drawViewportRectOnOverlay(overlay: HTMLCanvasElement): void {\r\n    if (!editorInstance) return;\r\n    const viewport = editorInstance.getViewportWorldRect();\r\n    if (!viewport) return;\r\n    const w = overlay.width;\r\n    const h = overlay.height;\r\n    const scale = Math.min(w, h) / 1000;\r\n    const offX = (w - 1000 * scale) / 2;\r\n    const offY = (h - 1000 * scale) / 2;\r\n    const x = offX + (viewport.x / PREVIEW_TO_WORLD) * scale;\r\n    const y = offY + (viewport.y / PREVIEW_TO_WORLD) * scale;\r\n    const rw = (viewport.width / PREVIEW_TO_WORLD) * scale;\r\n    const rh = (viewport.height / PREVIEW_TO_WORLD) * scale;\r\n    const ctx = overlay.getContext('2d');\r\n    if (!ctx) return;\r\n    ctx.clearRect(0, 0, w, h);\r\n    ctx.strokeStyle = 'rgba(255, 255, 200, 0.9)';\r\n    ctx.lineWidth = 2;\r\n    ctx.strokeRect(x, y, rw, rh);\r\n}\r\n\r\nfunction drawViewportRectOnProceduralOverlay(): void {\r\n    const overlaySidebar = document.getElementById('proc-preview-overlay') as HTMLCanvasElement;\r\n    const wrapSidebar = document.getElementById('proc-preview-wrap');\r\n    const container = document.getElementById('map-editor-container');\r\n    const inMapView = container && container.style.display !== 'none';\r\n    if (wrapSidebar) wrapSidebar.classList.toggle('has-viewport', inMapView && (document.getElementById('procedural-panel-body')?.style.display !== 'none'));\r\n    if (!editorInstance || !inMapView) return;\r\n    if (overlaySidebar && document.getElementById('procedural-panel-body')?.style.display !== 'none') drawViewportRectOnOverlay(overlaySidebar);\r\n}\r\n\r\nlet mapEditChannel: BroadcastChannel | null = null;\r\n\r\nfunction scheduleAutoSave(): void {\r\n    if (autoSaveTimer) clearTimeout(autoSaveTimer);\r\n    autoSaveTimer = setTimeout(() => {\r\n        autoSaveTimer = null;\r\n        saveMapToDefault();\r\n    }, AUTO_SAVE_DEBOUNCE_MS);\r\n}\r\n\r\nasync function loadDefaultMapOnFirstOpen(): Promise<void> {\r\n    if (!editorInstance || currentLoadedMap) return;\r\n    let data: MapEditorDataPayload | null = null;\r\n    let loadSource: 'localStorage' | 'indexedDB' | 'API' | 'static' | null = null;\r\n\r\n    // 1. Try MapStorage (localStorage then IndexedDB)  survives refresh, avoids quota for large maps\r\n    const stored = await loadDefaultMap();\r\n    if (stored?.data) {\r\n        data = stored.data as MapEditorDataPayload;\r\n        loadSource = stored.source;\r\n    }\r\n\r\n    // 2. Try API (authoritative when server is running)\r\n    if (!data) {\r\n        try {\r\n            const res = await fetch(\r\n                `/api/load_map?filename=${encodeURIComponent(DEFAULT_MAP_FILENAME)}`,\r\n                { cache: 'no-store' }\r\n            );\r\n            const result = await res.json();\r\n            if (result.success && result.data) {\r\n                data = result.data as MapEditorDataPayload;\r\n                loadSource = 'API';\r\n            }\r\n        } catch {\r\n            /* API failed */\r\n        }\r\n    }\r\n\r\n    // 3. Try static file fallback\r\n    if (!data) {\r\n        try {\r\n            const res = await fetch(`/maps/default.json?_=${Date.now()}`, { cache: 'no-store' });\r\n            if (res.ok) {\r\n                const json = await res.json();\r\n                data = json as MapEditorDataPayload;\r\n                loadSource = 'static';\r\n            }\r\n        } catch {\r\n            /* Static fetch failed */\r\n        }\r\n    }\r\n\r\n    if (data) {\r\n        editorInstance.loadData(data);\r\n        const param = data.mapgen4Param as ProcParam | undefined;\r\n        lastLoadedMapgen4Param = param ?? null;\r\n        setProcParamFromData(param);\r\n        if (param) {\r\n            await editorInstance.setProceduralPreview(param as unknown as import('../../../src/tools/map-editor/Mapgen4Generator').Mapgen4Param);\r\n        }\r\n        currentLoadedMap = DEFAULT_MAP_FILENAME;\r\n        updateLoadedDisplay();\r\n        OutlinerPanel.refresh();\r\n        broadcastMapFull();\r\n        Logger.info(`[MapEditor] Load default map: source=${loadSource ?? 'none'} success=true`);\r\n        try {\r\n            await saveDefaultMap(data);\r\n        } catch {\r\n            // Keep storage in sync when possible\r\n        }\r\n    } else {\r\n        Logger.info('[MapEditor] Load default map: no data from any source (localStorage/indexedDB/API/static)');\r\n    }\r\n}\r\n\r\nasync function saveMapToDefault(): Promise<void> {\r\n    if (!editorInstance) return;\r\n    const mapData = buildMapPayload();\r\n    if (!mapData) return;\r\n\r\n    const filename = currentLoadedMap || DEFAULT_MAP_FILENAME;\r\n    try {\r\n        const res = await fetch('/api/save_map', {\r\n            method: 'POST',\r\n            headers: { 'Content-Type': 'application/json' },\r\n            body: JSON.stringify({ filename, mapData })\r\n        });\r\n        const result = await res.json();\r\n        if (result.success) {\r\n            if (!currentLoadedMap) {\r\n                currentLoadedMap = DEFAULT_MAP_FILENAME;\r\n                updateLoadedDisplay();\r\n            }\r\n            refreshMapList();\r\n            broadcastMapFull();\r\n            try {\r\n                const { source } = await saveDefaultMap(mapData);\r\n                Logger.info(`[MapEditor] Save default map: API success, local persistence=${source}`);\r\n            } catch {\r\n                // local persistence failed\r\n            }\r\n        }\r\n    } catch (e) {\r\n        Logger.error('Auto-save map error:', e);\r\n        try {\r\n            const { source } = await saveDefaultMap(mapData);\r\n            Logger.info(`[MapEditor] Save default map: API failed, local persistence=${source}`);\r\n        } catch {\r\n            // Fallback: persist locally when API fails so refresh loads it\r\n        }\r\n    }\r\n}\r\n\r\nfunction initMapEditorBeforeUnload(): void {\r\n    window.addEventListener('beforeunload', () => {\r\n        if (autoSaveTimer) {\r\n            clearTimeout(autoSaveTimer);\r\n            autoSaveTimer = null;\r\n        }\r\n        if (getAutoSaveEnabled() && editorInstance) {\r\n            const mapData = buildMapPayload();\r\n            if (mapData) {\r\n                const filename = currentLoadedMap || DEFAULT_MAP_FILENAME;\r\n                fetch('/api/save_map', {\r\n                    method: 'POST',\r\n                    headers: { 'Content-Type': 'application/json' },\r\n                    body: JSON.stringify({ filename, mapData }),\r\n                    keepalive: true\r\n                }).catch(() => { });\r\n                if (filename === DEFAULT_MAP_FILENAME || filename === 'default') {\r\n                    saveDefaultMap(mapData).catch(() => { });\r\n                }\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nfunction initMapEditBroadcast(): void {\r\n    if (typeof BroadcastChannel === 'undefined' || !editorInstance) return;\r\n    mapEditChannel = new BroadcastChannel('game-map-updates');\r\n    const cm = editorInstance.getChunkManager();\r\n    cm?.setOnMapEdit((type, payload) => {\r\n        mapEditChannel?.postMessage({ type, ...(payload as object) });\r\n        if (getAutoSaveEnabled()) scheduleAutoSave();\r\n    });\r\n}\r\n\r\nexport function broadcastMapFull(): void {\r\n    if (!mapEditChannel || !editorInstance) return;\r\n    const data = buildMapPayload();\r\n    if (data) mapEditChannel.postMessage({ type: 'MAP_FULL', data });\r\n}\r\n\r\nfunction initProceduralPreviewClickAndViewport(): void {\r\n    const wrap = document.getElementById('proc-preview-wrap');\r\n    const overlay = document.getElementById('proc-preview-overlay') as HTMLCanvasElement;\r\n    const previewCanvas = document.getElementById('proc-preview-canvas') as HTMLCanvasElement;\r\n    if (!wrap || !overlay || !previewCanvas) return;\r\n\r\n    wrap.addEventListener('click', (e: MouseEvent) => {\r\n        if (!editorInstance || (e.target !== overlay && e.target !== previewCanvas)) return;\r\n        const rect = wrap.getBoundingClientRect();\r\n        const can = overlay;\r\n        const mx = ((e.clientX - rect.left) / rect.width) * can.width;\r\n        const my = ((e.clientY - rect.top) / rect.height) * can.height;\r\n        const w = can.width;\r\n        const h = can.height;\r\n        const scale = Math.min(w, h) / 1000;\r\n        const offX = (w - 1000 * scale) / 2;\r\n        const offY = (h - 1000 * scale) / 2;\r\n        const previewX = (mx - offX) / scale;\r\n        const previewY = (my - offY) / scale;\r\n        const worldX = previewX * PREVIEW_TO_WORLD;\r\n        const worldY = previewY * PREVIEW_TO_WORLD;\r\n        editorInstance.centerViewOn(worldX, worldY);\r\n    });\r\n\r\n    setInterval(() => {\r\n        const proceduralBody = document.getElementById('procedural-panel-body');\r\n        const container = document.getElementById('map-editor-container');\r\n        if (container?.style.display !== 'none' && proceduralBody?.style.display !== 'none') {\r\n            drawViewportRectOnProceduralOverlay();\r\n        }\r\n    }, 100);\r\n}\r\n\r\nfunction initMapEditorResize(): void {\r\n    const triggerMapCanvasResize = () => editorInstance?.resize?.();\r\n    initResizeHandle('resize-map-palette', 'map-editor-sidebar', true, {\r\n        defaultPx: 300,\r\n        minPx: 180,\r\n        storageKey: 'map-editor-palette-width',\r\n        onResize: triggerMapCanvasResize,\r\n    });\r\n    initResizeHandle('resize-map-panel', 'maps-panel', false, {\r\n        defaultPx: 280,\r\n        minPx: 200,\r\n        storageKey: 'map-editor-maps-panel-width',\r\n        onResize: triggerMapCanvasResize,\r\n    });\r\n}\r\n\r\nconst MAP_PANEL_COLLAPSED_KEY = 'map-editor-maps-panel-collapsed';\r\n\r\nfunction initMapPanel(): void {\r\n    const toggleBtn = document.getElementById('maps-panel-toggle');\r\n    const panel = document.getElementById('maps-panel');\r\n    if (!toggleBtn || !panel) return;\r\n\r\n    const stored = localStorage.getItem(MAP_PANEL_COLLAPSED_KEY);\r\n    const initiallyCollapsed = stored === 'true';\r\n    toggleBtn.setAttribute('aria-expanded', String(!initiallyCollapsed));\r\n    panel.classList.toggle('collapsed', initiallyCollapsed);\r\n\r\n    toggleBtn.addEventListener('click', () => {\r\n        const expanded = toggleBtn.getAttribute('aria-expanded') === 'true';\r\n        toggleBtn.setAttribute('aria-expanded', String(!expanded));\r\n        panel.classList.toggle('collapsed', expanded);\r\n        localStorage.setItem(MAP_PANEL_COLLAPSED_KEY, String(expanded));\r\n    });\r\n\r\n    const filenameInput = document.getElementById('map-save-filename') as HTMLInputElement;\r\n    filenameInput?.addEventListener('keydown', (e) => {\r\n        if (e.key === 'Enter') saveMapFromPanel();\r\n    });\r\n\r\n    const autoSaveToggle = document.getElementById('map-auto-save-toggle') as HTMLInputElement;\r\n    if (autoSaveToggle) {\r\n        autoSaveToggle.checked = getAutoSaveEnabled();\r\n        autoSaveToggle.addEventListener('change', () => {\r\n            setAutoSaveEnabled(autoSaveToggle.checked);\r\n        });\r\n    }\r\n\r\n    initPanelTabs();\r\n    initOutlinerPanel();\r\n    initProceduralPanel();\r\n    updateLoadedDisplay();\r\n    refreshMapList();\r\n}\r\n\r\nconst MAP_PANEL_TAB_KEY = 'map-editor-maps-panel-tab';\r\n\r\nfunction initPanelTabs(): void {\r\n    const tabMaps = document.getElementById('tab-maps');\r\n    const tabOutliner = document.getElementById('tab-outliner');\r\n    const tabProcedural = document.getElementById('tab-procedural');\r\n    const bodyMaps = document.getElementById('maps-panel-body');\r\n    const bodyOutliner = document.getElementById('outliner-panel-body');\r\n    const bodyProcedural = document.getElementById('procedural-panel-body');\r\n    const panelTitle = document.getElementById('maps-panel-title');\r\n    let isInitialRestore = true;\r\n    const switchTo = (tab: 'maps' | 'outliner' | 'procedural') => {\r\n        localStorage.setItem(MAP_PANEL_TAB_KEY, tab);\r\n        tabMaps?.classList.toggle('active', tab === 'maps');\r\n        tabOutliner?.classList.toggle('active', tab === 'outliner');\r\n        tabProcedural?.classList.toggle('active', tab === 'procedural');\r\n        if (bodyMaps) bodyMaps.style.display = tab === 'maps' ? '' : 'none';\r\n        if (bodyOutliner) bodyOutliner.style.display = tab === 'outliner' ? '' : 'none';\r\n        if (bodyProcedural) bodyProcedural.style.display = tab === 'procedural' ? '' : 'none';\r\n        if (panelTitle) {\r\n            panelTitle.textContent = tab === 'maps' ? 'Maps' : tab === 'outliner' ? 'Outliner' : 'Procedural';\r\n        }\r\n        if (tab === 'outliner') {\r\n            OutlinerPanel.refresh();\r\n        }\r\n        if (tab === 'procedural' && !isInitialRestore) {\r\n            runPreviewCanvas({ skipRebuildIfLoaded: true });\r\n        }\r\n    };\r\n    tabMaps?.addEventListener('click', () => switchTo('maps'));\r\n    tabOutliner?.addEventListener('click', () => switchTo('outliner'));\r\n    tabProcedural?.addEventListener('click', () => switchTo('procedural'));\r\n\r\n    const storedTab = localStorage.getItem(MAP_PANEL_TAB_KEY) as 'maps' | 'outliner' | 'procedural' | null;\r\n    if (storedTab && (storedTab === 'maps' || storedTab === 'outliner' || storedTab === 'procedural')) {\r\n        switchTo(storedTab);\r\n    }\r\n    isInitialRestore = false;\r\n}\r\n\r\nfunction initOutlinerPanel(): void {\r\n    if (!editorInstance) return;\r\n    OutlinerPanel.init(\r\n        editorInstance,\r\n        () => { /* onRefresh callback  currently unused */ },\r\n        () => runPreviewCanvas()\r\n    );\r\n}\r\n\r\nexport function refreshOutliner(): void {\r\n    OutlinerPanel.refresh();\r\n}\r\n\r\nfunction setProcStatus(message: string, isError = false): void {\r\n    const el = document.getElementById('proc-status');\r\n    if (el) {\r\n        el.textContent = message;\r\n        el.style.color = isError ? '#e74c3c' : '#888';\r\n    }\r\n}\r\n\r\n\r\nconst PREVIEW_DEBOUNCE_MS = 120;\r\n\r\nlet previewDebounceTimer: ReturnType<typeof setTimeout> | null = null;\r\n\r\n/** Update minimap and main view. Debounced to avoid rapid rebuilds when dragging sliders. */\r\nfunction scheduleLivePreview(): void {\r\n    if (previewDebounceTimer) clearTimeout(previewDebounceTimer);\r\n    previewDebounceTimer = setTimeout(() => {\r\n        previewDebounceTimer = null;\r\n        runPreviewCanvas();\r\n        if (getAutoSaveEnabled()) scheduleAutoSave();\r\n    }, PREVIEW_DEBOUNCE_MS);\r\n}\r\n\r\n/** @param skipRebuildIfLoaded When true and a map is loaded, skip setProceduralPreview (used on init to avoid overwriting cache built from loaded params). */\r\nasync function runPreviewCanvas(opts?: { skipRebuildIfLoaded?: boolean }): Promise<void> {\r\n    const skipRebuildIfLoaded = opts?.skipRebuildIfLoaded ?? false;\r\n    const canvasSidebar = document.getElementById('proc-preview-canvas') as HTMLCanvasElement;\r\n    try {\r\n        const param = getProcParam();\r\n        const mapgenParam = param as unknown as import('../../../src/tools/map-editor/Mapgen4Generator').Mapgen4Param;\r\n        if (editorInstance) {\r\n            const shouldRebuild = !currentLoadedMap || !skipRebuildIfLoaded;\r\n            if (shouldRebuild) {\r\n                await editorInstance.setProceduralPreview(mapgenParam);\r\n            }\r\n            if (canvasSidebar && !editorInstance.drawCachedToCanvas(canvasSidebar)) {\r\n                if (shouldRebuild) {\r\n                    const { runAndDrawPreview } =\r\n                        await import('../../../src/tools/map-editor/Mapgen4PreviewRenderer');\r\n                    runAndDrawPreview(canvasSidebar, mapgenParam);\r\n                }\r\n            }\r\n        } else if (canvasSidebar) {\r\n            const { runAndDrawPreview } =\r\n                await import('../../../src/tools/map-editor/Mapgen4PreviewRenderer');\r\n            runAndDrawPreview(canvasSidebar, mapgenParam);\r\n        }\r\n    } catch (e) {\r\n        Logger.error('Mapgen4 preview error:', e);\r\n    }\r\n}\r\n\r\nfunction bindSlider(id: string, valueId: string, parse: (s: string) => number): number {\r\n    const input = document.getElementById(id) as HTMLInputElement;\r\n    const valueEl = document.getElementById(valueId);\r\n    if (!input) return 0;\r\n    const updateDisplay = () => {\r\n        if (valueEl) valueEl.textContent = input.value;\r\n    };\r\n    input.addEventListener('input', updateDisplay);\r\n    input.addEventListener('change', scheduleLivePreview);\r\n    updateDisplay();\r\n    return parse(input.value);\r\n}\r\n\r\nfunction bindNumberInput(id: string): void {\r\n    const input = document.getElementById(id) as HTMLInputElement;\r\n    if (!input) return;\r\n    input.addEventListener('change', scheduleLivePreview);\r\n}\r\n\r\nfunction bindCheckbox(id: string): void {\r\n    const input = document.getElementById(id) as HTMLInputElement;\r\n    if (!input) return;\r\n    input.addEventListener('change', scheduleLivePreview);\r\n}\r\n\r\nfunction getProcParam(): ProcParam {\r\n    const num = (id: string) =>\r\n        parseFloat((document.getElementById(id) as HTMLInputElement)?.value ?? '0') || 0;\r\n    const int = (id: string) =>\r\n        parseInt((document.getElementById(id) as HTMLInputElement)?.value ?? '0', 10) || 0;\r\n    const checked = (id: string) => (document.getElementById(id) as HTMLInputElement)?.checked ?? false;\r\n    return {\r\n        spacing: num('proc-spacing') || 5.5,\r\n        mountainSpacing: num('proc-mountain-spacing') || 35,\r\n        meshSeed: int('proc-mesh-seed') || 12345,\r\n        elevation: {\r\n            seed: int('proc-elev-seed') || 187,\r\n            island: num('proc-island'),\r\n            noisy_coastlines: num('proc-noisy-coastlines'),\r\n            hill_height: num('proc-hill-height'),\r\n            mountain_jagged: num('proc-mountain-jagged'),\r\n            mountain_sharpness: num('proc-mountain-sharpness'),\r\n            mountain_folds: num('proc-mountain-folds'),\r\n            ocean_depth: num('proc-ocean-depth')\r\n        },\r\n        biomes: {\r\n            wind_angle_deg: num('proc-wind-angle'),\r\n            raininess: num('proc-raininess'),\r\n            rain_shadow: num('proc-rain-shadow'),\r\n            evaporation: num('proc-evaporation')\r\n        },\r\n        rivers: {\r\n            lg_min_flow: num('proc-lg-min-flow'),\r\n            lg_river_width: num('proc-lg-river-width'),\r\n            flow: num('proc-flow')\r\n        },\r\n        towns: {\r\n            enabled: checked('proc-towns-enabled'),\r\n            numTowns: int('proc-num-towns') || 5,\r\n            minSpacing: num('proc-town-spacing') || 60,\r\n            townRadius: num('proc-town-radius') || 30,\r\n            defaultZoneId: 'civ_town',\r\n            elevationMin: num('proc-town-elev-min') ?? 0,\r\n            elevationMax: num('proc-town-elev-max') ?? 0.3,\r\n            rainfallMin: num('proc-town-rain-min') ?? 0.2,\r\n            rainfallMax: num('proc-town-rain-max') ?? 1\r\n        },\r\n        roads: {\r\n            enabled: checked('proc-roads-enabled'),\r\n            baseWidth: num('proc-road-width') || 80,\r\n            shortcutsPerTown: int('proc-road-shortcuts') ?? 1,\r\n            riverCrossingCost: num('proc-road-river-cost') ?? 1.2,\r\n            coverageGridSize: int('proc-road-coverage') ?? 0,\r\n            slopeWeight: num('proc-road-slope-weight') ?? 3,\r\n            waypointCurviness: num('proc-road-waypoint-curviness') ?? 0.15\r\n        },\r\n        railroads: {\r\n            enabled: checked('proc-railroads-enabled')\r\n        }\r\n    };\r\n}\r\n\r\n/** Build full map payload including procedural params for save/broadcast. Uses editor procCache when available, else last-loaded param, else form. */\r\nfunction buildMapPayload(): MapEditorDataPayload | null {\r\n    if (!editorInstance) return null;\r\n\r\n    const serialized = editorInstance.serialize();\r\n    const fromEditor = editorInstance?.getMapgen4Param?.() as import('../../../src/tools/map-editor/Mapgen4Generator').Mapgen4Param | undefined;\r\n    const fromUIParam = getProcParam() as unknown as import('../../../src/tools/map-editor/Mapgen4Generator').Mapgen4Param;\r\n\r\n    const mapgen4Param = fromEditor && Object.keys(fromEditor).length > 0 ? fromEditor : fromUIParam;\r\n    const paramSource = fromEditor ? 'procCache' : lastLoadedMapgen4Param ? 'lastLoaded' : 'form';\r\n    Logger.info(`[MapEditor] buildMapPayload: mapgen4Param source=${paramSource}`);\r\n\r\n    // MapEditorDataPayload requires `chunks` to be a Record<string, ChunkData>, not an Array.\r\n    // Ensure that mapping occurs if needed.\r\n    const payload: MapEditorDataPayload = {\r\n        chunks: serialized.chunks,\r\n        heroSpawn: serialized.heroSpawn,\r\n        mapgen4Param,\r\n        manualTowns: serialized.manualTowns,\r\n        manualStations: serialized.manualStations,\r\n        railroadWaypoints: serialized.railroadWaypoints\r\n    };\r\n\r\n    return payload;\r\n}\r\n\r\n/** Restore procedural form inputs from saved mapgen4 param. Does not trigger live preview. */\r\nfunction setProcParamFromData(param: ProcParam | null | undefined): void {\r\n    if (!param) return;\r\n    const setInput = (id: string, value: number): void => {\r\n        const input = document.getElementById(id) as HTMLInputElement | null;\r\n        if (input) {\r\n            input.value = String(value);\r\n            const valEl = document.getElementById(id + '-val');\r\n            if (valEl) valEl.textContent = input.value;\r\n        }\r\n    };\r\n    setInput('proc-spacing', param.spacing);\r\n    setInput('proc-mountain-spacing', param.mountainSpacing);\r\n    setInput('proc-mesh-seed', param.meshSeed);\r\n    if (param.elevation) {\r\n        setInput('proc-elev-seed', param.elevation.seed ?? 187);\r\n        setInput('proc-island', param.elevation.island ?? 0.5);\r\n        setInput('proc-noisy-coastlines', param.elevation.noisy_coastlines ?? 0.01);\r\n        setInput('proc-hill-height', param.elevation.hill_height ?? 0.02);\r\n        setInput('proc-mountain-jagged', param.elevation.mountain_jagged ?? 0);\r\n        setInput('proc-mountain-sharpness', param.elevation.mountain_sharpness ?? 9.8);\r\n        setInput('proc-mountain-folds', param.elevation.mountain_folds ?? 0.05);\r\n        setInput('proc-ocean-depth', param.elevation.ocean_depth ?? 1.4);\r\n    }\r\n    if (param.biomes) {\r\n        setInput('proc-wind-angle', param.biomes.wind_angle_deg ?? 0);\r\n        setInput('proc-raininess', param.biomes.raininess ?? 0.9);\r\n        setInput('proc-rain-shadow', param.biomes.rain_shadow ?? 0.5);\r\n        setInput('proc-evaporation', param.biomes.evaporation ?? 0.5);\r\n    }\r\n    if (param.rivers) {\r\n        setInput('proc-lg-min-flow', param.rivers.lg_min_flow ?? 2.7);\r\n        setInput('proc-lg-river-width', param.rivers.lg_river_width ?? -2.4);\r\n        setInput('proc-flow', param.rivers.flow ?? 0.2);\r\n    }\r\n    if (param.towns) {\r\n        const cb = document.getElementById('proc-towns-enabled') as HTMLInputElement;\r\n        if (cb) cb.checked = param.towns.enabled ?? true;\r\n        setInput('proc-num-towns', param.towns.numTowns ?? 5);\r\n        setInput('proc-town-spacing', param.towns.minSpacing ?? 60);\r\n        setInput('proc-town-radius', param.towns.townRadius ?? 30);\r\n        setInput('proc-town-elev-min', param.towns.elevationMin ?? 0);\r\n        setInput('proc-town-elev-max', param.towns.elevationMax ?? 0.3);\r\n        setInput('proc-town-rain-min', param.towns.rainfallMin ?? 0.2);\r\n        setInput('proc-town-rain-max', param.towns.rainfallMax ?? 1);\r\n    }\r\n    if (param.roads) {\r\n        const cb = document.getElementById('proc-roads-enabled') as HTMLInputElement;\r\n        if (cb) cb.checked = param.roads.enabled ?? true;\r\n        setInput('proc-road-width', param.roads.baseWidth ?? 80);\r\n        setInput('proc-road-shortcuts', param.roads.shortcutsPerTown ?? 1);\r\n        setInput('proc-road-river-cost', param.roads.riverCrossingCost ?? 1.2);\r\n        setInput('proc-road-coverage', param.roads.coverageGridSize ?? 0);\r\n        setInput('proc-road-slope-weight', param.roads.slopeWeight ?? 3);\r\n        setInput('proc-road-waypoint-curviness', param.roads.waypointCurviness ?? 0.15);\r\n    }\r\n    if (param.railroads) {\r\n        const cb = document.getElementById('proc-railroads-enabled') as HTMLInputElement;\r\n        if (cb) cb.checked = param.railroads.enabled ?? true;\r\n    }\r\n}\r\n\r\nfunction initProceduralPanel(): void {\r\n    bindSlider('proc-spacing', 'proc-spacing-val', parseFloat);\r\n    bindSlider('proc-mountain-spacing', 'proc-mountain-spacing-val', parseFloat);\r\n    bindNumberInput('proc-mesh-seed');\r\n    bindSlider('proc-island', 'proc-island-val', parseFloat);\r\n    bindSlider('proc-noisy-coastlines', 'proc-noisy-coastlines-val', parseFloat);\r\n    bindSlider('proc-hill-height', 'proc-hill-height-val', parseFloat);\r\n    bindSlider('proc-mountain-jagged', 'proc-mountain-jagged-val', parseFloat);\r\n    bindSlider('proc-mountain-sharpness', 'proc-mountain-sharpness-val', parseFloat);\r\n    bindSlider('proc-mountain-folds', 'proc-mountain-folds-val', parseFloat);\r\n    bindSlider('proc-ocean-depth', 'proc-ocean-depth-val', parseFloat);\r\n    bindSlider('proc-wind-angle', 'proc-wind-angle-val', parseFloat);\r\n    bindSlider('proc-raininess', 'proc-raininess-val', parseFloat);\r\n    bindSlider('proc-rain-shadow', 'proc-rain-shadow-val', parseFloat);\r\n    bindSlider('proc-evaporation', 'proc-evaporation-val', parseFloat);\r\n    bindSlider('proc-lg-min-flow', 'proc-lg-min-flow-val', parseFloat);\r\n    bindSlider('proc-lg-river-width', 'proc-lg-river-width-val', parseFloat);\r\n    bindSlider('proc-flow', 'proc-flow-val', parseFloat);\r\n    bindNumberInput('proc-elev-seed');\r\n    bindCheckbox('proc-towns-enabled');\r\n    bindNumberInput('proc-num-towns');\r\n    const updateTownNum = () => {\r\n        const el = document.getElementById('proc-num-towns-val');\r\n        const input = document.getElementById('proc-num-towns') as HTMLInputElement;\r\n        if (el && input) el.textContent = input.value;\r\n    };\r\n    document.getElementById('proc-num-towns')?.addEventListener('input', updateTownNum);\r\n    updateTownNum();\r\n    bindSlider('proc-town-spacing', 'proc-town-spacing-val', parseFloat);\r\n    bindSlider('proc-town-radius', 'proc-town-radius-val', parseFloat);\r\n    bindSlider('proc-town-elev-min', 'proc-town-elev-min-val', parseFloat);\r\n    bindSlider('proc-town-elev-max', 'proc-town-elev-max-val', parseFloat);\r\n    bindSlider('proc-town-rain-min', 'proc-town-rain-min-val', parseFloat);\r\n    bindSlider('proc-town-rain-max', 'proc-town-rain-max-val', parseFloat);\r\n    bindCheckbox('proc-roads-enabled');\r\n    bindNumberInput('proc-road-width');\r\n    bindNumberInput('proc-road-shortcuts');\r\n    bindNumberInput('proc-road-coverage');\r\n    const updateRoadWidth = () => {\r\n        const el = document.getElementById('proc-road-width-val');\r\n        const input = document.getElementById('proc-road-width') as HTMLInputElement;\r\n        if (el && input) el.textContent = input.value;\r\n    };\r\n    const updateRoadShortcuts = () => {\r\n        const el = document.getElementById('proc-road-shortcuts-val');\r\n        const input = document.getElementById('proc-road-shortcuts') as HTMLInputElement;\r\n        if (el && input) el.textContent = input.value;\r\n    };\r\n    const updateRoadCoverage = () => {\r\n        const el = document.getElementById('proc-road-coverage-val');\r\n        const input = document.getElementById('proc-road-coverage') as HTMLInputElement;\r\n        if (el && input) el.textContent = input.value;\r\n    };\r\n    document.getElementById('proc-road-width')?.addEventListener('input', updateRoadWidth);\r\n    document.getElementById('proc-road-shortcuts')?.addEventListener('input', updateRoadShortcuts);\r\n    document.getElementById('proc-road-coverage')?.addEventListener('input', updateRoadCoverage);\r\n    updateRoadWidth();\r\n    updateRoadShortcuts();\r\n    updateRoadCoverage();\r\n    bindSlider('proc-road-river-cost', 'proc-road-river-cost-val', parseFloat);\r\n    bindSlider('proc-road-slope-weight', 'proc-road-slope-weight-val', parseFloat);\r\n    bindSlider('proc-road-waypoint-curviness', 'proc-road-waypoint-curviness-val', parseFloat);\r\n    bindCheckbox('proc-railroads-enabled');\r\n\r\n    const rebuildBtn = document.getElementById('proc-railroad-rebuild');\r\n    if (rebuildBtn) {\r\n        rebuildBtn.addEventListener('click', async () => {\r\n            if (!editorInstance) {\r\n                setProcStatus('Editor not ready', true);\r\n                return;\r\n            }\r\n            const param = editorInstance.getMapgen4Param() ?? getProcParam();\r\n            await editorInstance.setProceduralPreview(param as import('../../../src/tools/map-editor/Mapgen4Generator').Mapgen4Param);\r\n            setProcStatus('Railroad path rebuilt.');\r\n        });\r\n    }\r\n}\r\n\r\nfunction setMapStatus(message: string, isError = false): void {\r\n    const el = document.getElementById('map-status');\r\n    if (el) {\r\n        el.textContent = message;\r\n        el.style.color = isError ? '#e74c3c' : '#888';\r\n        if (message) {\r\n            setTimeout(() => {\r\n                el.textContent = '';\r\n            }, 4000);\r\n        }\r\n    }\r\n}\r\n\r\nfunction updateLoadedDisplay(): void {\r\n    const el = document.getElementById('map-loaded-display');\r\n    const input = document.getElementById('map-save-filename') as HTMLInputElement;\r\n    if (el && input) {\r\n        if (currentLoadedMap) {\r\n            el.textContent = `Loaded: ${currentLoadedMap}`;\r\n            el.style.color = '#66fcf1';\r\n            input.value = currentLoadedMap;\r\n            input.placeholder = 'Edit to save as new map';\r\n        } else {\r\n            el.textContent = 'No map loaded';\r\n            el.style.color = '#666';\r\n            input.value = DEFAULT_MAP_FILENAME;\r\n            input.placeholder = `Saves to ${DEFAULT_MAP_FILENAME}`;\r\n        }\r\n    }\r\n}\r\n\r\nexport async function saveMapFromPanel(): Promise<void> {\r\n    if (!editorInstance) {\r\n        setMapStatus('Editor not ready', true);\r\n        return;\r\n    }\r\n\r\n    const input = document.getElementById('map-save-filename') as HTMLInputElement;\r\n    const typed = input?.value?.trim() ?? '';\r\n    // If empty and we have a loaded map, overwrite it. Otherwise use typed name (or require one).\r\n    const filename = typed || currentLoadedMap;\r\n    if (!filename) {\r\n        setMapStatus('Enter a map name', true);\r\n        return;\r\n    }\r\n\r\n    const mapData = buildMapPayload();\r\n    if (!mapData) {\r\n        setMapStatus('Failed to serialize', true);\r\n        return;\r\n    }\r\n\r\n    setMapStatus('Saving...');\r\n    try {\r\n        const res = await fetch('/api/save_map', {\r\n            method: 'POST',\r\n            headers: { 'Content-Type': 'application/json' },\r\n            body: JSON.stringify({ filename, mapData })\r\n        });\r\n        const result = await res.json();\r\n        if (result.success) {\r\n            currentLoadedMap = filename;\r\n            updateLoadedDisplay();\r\n            setMapStatus('Saved as ' + filename);\r\n            refreshMapList();\r\n            broadcastMapFull();\r\n            if (filename === DEFAULT_MAP_FILENAME || filename === 'default') {\r\n                try {\r\n                    const { source } = await saveDefaultMap(mapData);\r\n                    Logger.info(`[MapEditor] Save from panel (default): persistence=${source}`);\r\n                } catch {\r\n                    /* local persistence failed */\r\n                }\r\n            }\r\n        } else {\r\n            setMapStatus('Save failed: ' + (result.error || 'Unknown error'), true);\r\n        }\r\n    } catch (e) {\r\n        Logger.error('Save map error:', e);\r\n        setMapStatus('Save error', true);\r\n    }\r\n}\r\n\r\nexport async function refreshMapList(): Promise<void> {\r\n    const listEl = document.getElementById('map-list');\r\n    if (!listEl) return;\r\n\r\n    try {\r\n        const res = await fetch('/api/list_maps');\r\n        const result = await res.json();\r\n        const maps: string[] = result.maps || [];\r\n        listEl.innerHTML = '';\r\n\r\n        if (maps.length === 0) {\r\n            listEl.innerHTML =\r\n                '<div style=\"color:#666; padding:8px; font-size:11px;\">No saved maps</div>';\r\n        } else {\r\n            maps.forEach((name) => {\r\n                const row = document.createElement('div');\r\n                row.style.cssText =\r\n                    'display:flex; align-items:center; gap:6px; padding:6px 8px; background:#252525; border-radius:4px; margin-bottom:4px;';\r\n                const label = document.createElement('button');\r\n                label.type = 'button';\r\n                label.textContent = name;\r\n                label.style.cssText =\r\n                    'flex:1; text-align:left; background:none; border:none; color:#66fcf1; cursor:pointer; font-size:12px; padding:0;';\r\n                label.title = 'Load';\r\n                label.addEventListener('click', () => loadMapByName(name));\r\n                const delBtn = document.createElement('button');\r\n                delBtn.type = 'button';\r\n                delBtn.textContent = '';\r\n                delBtn.title = 'Delete';\r\n                delBtn.style.cssText =\r\n                    'background:#5a2525; color:#fff; border:none; border-radius:4px; cursor:pointer; padding:4px 8px; font-size:11px;';\r\n                delBtn.addEventListener('click', (e) => {\r\n                    e.stopPropagation();\r\n                    deleteMapByName(name);\r\n                });\r\n                row.appendChild(label);\r\n                row.appendChild(delBtn);\r\n                listEl.appendChild(row);\r\n            });\r\n        }\r\n    } catch (e) {\r\n        Logger.error('Failed to list maps:', e);\r\n        listEl.innerHTML =\r\n            '<div style=\"color:#e74c3c; padding:8px; font-size:11px;\">Failed to load list</div>';\r\n    }\r\n}\r\n\r\nasync function loadMapByName(filename: string): Promise<void> {\r\n    if (!editorInstance) return;\r\n\r\n    setMapStatus('Loading...');\r\n    try {\r\n        const res = await fetch(`/api/load_map?filename=${encodeURIComponent(filename)}`, { cache: 'no-store' });\r\n        const result = await res.json();\r\n        if (result.success && result.data) {\r\n            const data = result.data as unknown as MapEditorDataPayload;\r\n            editorInstance.loadData(data);\r\n            lastLoadedMapgen4Param = (data.mapgen4Param as unknown as ProcParam) ?? null;\r\n            setProcParamFromData(data.mapgen4Param as unknown as ProcParam);\r\n            if (data.mapgen4Param) {\r\n                await editorInstance.setProceduralPreview(data.mapgen4Param as unknown as import('../../../src/tools/map-editor/Mapgen4Generator').Mapgen4Param);\r\n            }\r\n            currentLoadedMap = filename;\r\n            updateLoadedDisplay();\r\n            OutlinerPanel.refresh();\r\n            broadcastMapFull();\r\n            setMapStatus('Loaded: ' + filename);\r\n            Logger.info(`[MapEditor] Load map: ${filename} (API)`);\r\n        } else {\r\n            setMapStatus('Load failed: ' + (result.error || 'Unknown error'), true);\r\n        }\r\n    } catch (e) {\r\n        Logger.error('Load map error:', e);\r\n        setMapStatus('Load error', true);\r\n    }\r\n}\r\n\r\nasync function deleteMapByName(filename: string): Promise<void> {\r\n    try {\r\n        const res = await fetch('/api/delete_map', {\r\n            method: 'POST',\r\n            headers: { 'Content-Type': 'application/json' },\r\n            body: JSON.stringify({ filename })\r\n        });\r\n        const result = await res.json();\r\n        if (result.success) {\r\n            if (currentLoadedMap === filename) {\r\n                currentLoadedMap = null;\r\n                lastLoadedMapgen4Param = null;\r\n                updateLoadedDisplay();\r\n            }\r\n            setMapStatus('Deleted: ' + filename);\r\n            refreshMapList();\r\n        } else {\r\n            setMapStatus('Delete failed: ' + (result.error || 'Unknown error'), true);\r\n        }\r\n    } catch (e) {\r\n        Logger.error('Delete map error:', e);\r\n        setMapStatus('Delete error', true);\r\n    }\r\n}\r\n\r\nfunction initModeAndTools(): void {\r\n    const modes = ['object', 'ground', 'zone', 'manipulation'] as const;\r\n    type EditorMode = typeof modes[number];\r\n\r\n    const updateModeUI = (mode: EditorMode) => {\r\n        modes.forEach(m => {\r\n            const btn = document.getElementById(`mode-${m}`);\r\n            if (btn) {\r\n                btn.classList.toggle('active', m === mode);\r\n            }\r\n        });\r\n\r\n        if (editorInstance) editorInstance.setMode(mode as 'object' | 'manipulation');\r\n        if (paletteInstance) paletteInstance.setMode(mode as 'object' | 'ground' | 'zone' | 'manipulation');\r\n    };\r\n\r\n    modes.forEach(mode => {\r\n        const btn = document.getElementById(`mode-${mode}`);\r\n        btn?.addEventListener('click', () => updateModeUI(mode));\r\n    });\r\n\r\n    const gridInput = document.getElementById('editor-grid-opacity') as HTMLInputElement;\r\n    const gridVal = document.getElementById('editor-grid-val');\r\n    gridInput?.addEventListener('input', (e) => {\r\n        const val = parseInt((e.target as HTMLInputElement).value);\r\n        if (gridVal) gridVal.innerText = `${val}%`;\r\n        if (editorInstance) editorInstance.setGridOpacity(val / 100);\r\n    });\r\n\r\n    const debugBtn = document.getElementById('debug-btn');\r\n    const debugPanel = document.getElementById('debug-panel');\r\n    const debugStationNumbersCheck = document.getElementById('debug-station-numbers') as HTMLInputElement;\r\n    const debugSplinePathCheck = document.getElementById('debug-spline-path') as HTMLInputElement;\r\n    debugBtn?.addEventListener('click', (e) => {\r\n        e.stopPropagation();\r\n        if (debugPanel) debugPanel.style.display = debugPanel.style.display === 'none' ? 'block' : 'none';\r\n    });\r\n    debugStationNumbersCheck?.addEventListener('change', () => {\r\n        if (editorInstance) editorInstance.setDebugStationNumbers(debugStationNumbersCheck.checked);\r\n    });\r\n    debugSplinePathCheck?.addEventListener('change', () => {\r\n        if (editorInstance) editorInstance.setDebugShowSplinePath(debugSplinePathCheck.checked);\r\n    });\r\n    if (editorInstance && debugStationNumbersCheck) {\r\n        debugStationNumbersCheck.checked = editorInstance.getDebugStationNumbers();\r\n    }\r\n    if (editorInstance && debugSplinePathCheck) {\r\n        debugSplinePathCheck.checked = editorInstance.getDebugShowSplinePath();\r\n    }\r\n    document.addEventListener('click', () => {\r\n        if (debugPanel) debugPanel.style.display = 'none';\r\n    });\r\n    debugPanel?.addEventListener('click', (e) => e.stopPropagation());\r\n\r\n\r\n}\r\n\r\nexport function hideMapEditorView(): void {\r\n    const mainContent = document.getElementById('mainContent');\r\n    const container = document.getElementById('map-editor-container');\r\n    const stickyBar = document.querySelector('.sticky-bar') as HTMLElement;\r\n    const stats = document.querySelector('.stats') as HTMLElement;\r\n\r\n    if (container) container.style.display = 'none';\r\n    if (mainContent) mainContent.style.removeProperty('display');\r\n    if (stickyBar) stickyBar.style.removeProperty('display');\r\n    if (stats) stats.style.removeProperty('display');\r\n\r\n    document.querySelectorAll('.nav-item[data-action=\"toggle-map-editor\"]').forEach((btn) => {\r\n        btn.classList.remove('active');\r\n    });\r\n}\r\n\r\n// HMR: when any of these map-editor modules change, refresh procedural preview instead of full page reload.\r\n// Vite requires string literals here (no variables).\r\nif (import.meta.hot) {\r\n    import.meta.hot.accept(\r\n        [\r\n            '../../../src/tools/map-editor/Mapgen4SplineUtils.ts',\r\n            '../../../src/tools/map-editor/RailroadSplineBuilder.ts',\r\n            '../../../src/tools/map-editor/MapEditorCore.ts',\r\n            '../../../src/tools/map-editor/MapEditorProceduralRenderer.ts',\r\n            '../../../src/tools/map-editor/Mapgen4Generator.ts',\r\n            '../../../src/tools/map-editor/RailroadGenerator.ts',\r\n            '../../../src/tools/map-editor/RailroadDijkstra.ts',\r\n            '../../../src/tools/map-editor/RailroadPathfinder.ts',\r\n            '../../../src/tools/map-editor/Mapgen4Param.ts',\r\n            '../../../src/tools/map-editor/Mapgen4PreviewRenderer.ts',\r\n            '../../../src/tools/map-editor/Mapgen4RailroadPreview.ts',\r\n            '../../../src/tools/map-editor/RailroadGeneratorTypes.ts',\r\n            '../../../src/tools/map-editor/RailroadMeshRenderer.ts',\r\n        ],\r\n        () => {\r\n            if (editorInstance) {\r\n                runPreviewCanvas().catch(() => { });\r\n            }\r\n        }\r\n    );\r\n\r\n    // Accept updates to itself so changes to mapEditorView don't reload the page\r\n    import.meta.hot.accept((newModule) => {\r\n        Logger.info('[HMR] mapEditorView updated. Re-initializing view...');\r\n        if (newModule && newModule.showMapEditorView && document.getElementById('map-editor-container')?.style.display !== 'none') {\r\n            newModule.showMapEditorView(false);\r\n        }\r\n    });\r\n\r\n    // Clean up when this module is replaced\r\n    import.meta.hot.dispose(() => {\r\n        Logger.info('[HMR] Disposing old mapEditorView instance...');\r\n        if (previewDebounceTimer) {\r\n            clearTimeout(previewDebounceTimer);\r\n            previewDebounceTimer = null;\r\n        }\r\n        if (autoSaveTimer) {\r\n            clearTimeout(autoSaveTimer);\r\n            autoSaveTimer = null;\r\n        }\r\n        if (mapEditChannel) {\r\n            mapEditChannel.close();\r\n        }\r\n        if (editorInstance) {\r\n            editorInstance.unmount();\r\n        }\r\n        if (paletteInstance) {\r\n            paletteInstance.dispose();\r\n        }\r\n    });\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\dashboard\\src\\modals.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\dashboard\\src\\state.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\dashboard\\src\\templates.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'showLandingPage' is defined but never used.","line":6,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":25,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"showLandingPage"},"fix":{"range":[71,113],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'templateSaveTimer' is assigned a value but never used.","line":13,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'templateSections' is assigned a value but never used.","line":14,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'assetPromptsJson' is assigned a value but never used.","line":15,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'content' is defined but never used. Allowed unused args must match /^_/u.","line":72,"column":35,"nodeType":"Identifier","messageId":"unusedVar","endLine":72,"endColumn":42},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'idx' is defined but never used. Allowed unused args must match /^_/u.","line":77,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":77,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'key' is defined but never used. Allowed unused args must match /^_/u.","line":81,"column":30,"nodeType":"Identifier","messageId":"unusedVar","endLine":81,"endColumn":33}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Templates View\n * Handles the prompt templates editor view\n */\n\nimport { showLandingPage } from './views';\n\n// ============================================\n// STATE\n// ============================================\n\nlet templatesContent = '';\nconst templateSaveTimer: ReturnType<typeof setTimeout> | null = null;\nlet templateSections: unknown[] = [];\nlet assetPromptsJson: Record<string, unknown> = {};\n\n// ============================================\n// SHOW TEMPLATES VIEW\n// ============================================\n\nexport async function showTemplatesView(): Promise<void> {\n    const container = document.getElementById('mainContent');\n    if (!container) return;\n\n    container.innerHTML = '<div class=\"loading\">Loading templates...</div>';\n\n    try {\n        const resp = await fetch('/api/get_prompt_templates', { method: 'POST', body: '{}' });\n        const data = await resp.json();\n        if (!data.success) {\n            container.innerHTML = `<div class=\"error\">Error loading templates: ${data.error}</div>`;\n            return;\n        }\n        templatesContent = data.content;\n        templateSections = parseAllTemplateSections(templatesContent);\n\n        // Load asset prompts\n        try {\n            const jsonResp = await fetch('/api/get_prompts', { method: 'POST', body: '{}' });\n            assetPromptsJson = await jsonResp.json();\n        } catch {\n            assetPromptsJson = {};\n        }\n\n        renderTemplatesView();\n    } catch (err) {\n        container.innerHTML = `<div class=\"error\">Error: ${(err as Error).message}</div>`;\n    }\n}\n\n// ============================================\n// RENDER TEMPLATES VIEW\n// ============================================\n\nexport function renderTemplatesView(): void {\n    const container = document.getElementById('mainContent');\n    if (!container) return;\n\n    container.innerHTML = `\n        <div style=\"text-align:center; padding:3rem;\">\n            <h2> Templates Editor</h2>\n            <p style=\"color:var(--text-dim);\">Coming soon in modular version...</p>\n            <button data-action=\"refresh-manifest\" class=\"secondary\" style=\"margin-top:1rem;\"> Back</button>\n        </div>\n    `;\n}\n\n// ============================================\n// STUB FUNCTIONS\n// ============================================\n\nfunction parseAllTemplateSections(content: string): unknown[] {\n    // Stub - full implementation in asset_dashboard.html\n    return [];\n}\n\nexport function onSectionEdit(idx: number): void {\n    // Stub\n}\n\nexport function onPromptEdit(key: string): void {\n    // Stub\n}\n\nexport async function saveAllSections(): Promise<void> {\n    // Stub\n}\n\nexport async function saveAllPrompts(): Promise<void> {\n    // Stub\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\dashboard\\src\\views.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'categoryData' is defined but never used.","line":11,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":17,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"categoryData"},"fix":{"range":[188,207],"text":""},"desc":"Remove unused variable \"categoryData\"."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Dashboard Views Module\r\n * Landing page, category views, and templates\r\n */\r\n\r\nimport {\r\n    CATEGORY_ICONS,\r\n    CATEGORY_COLORS,\r\n    setCategoryData,\r\n    setCurrentCategoryName,\r\n    categoryData,\r\n    currentCategoryName,\r\n    setCategoryFilterValue,\r\n    categoryFilter,\r\n    saveCategoryFiltersCache,\r\n    getCategoryFiltersFromCache,\r\n} from './state';\r\nimport { fetchCategory, updateCategoryStatus, loadGlobalAssetLookup } from './api';\r\nimport { renderCategoryView } from './categoryRenderer';\r\nimport { renderConfigView } from './configRenderer';\r\n\r\n// ============================================\r\n// POLLING STATE\r\n// ============================================\r\n\r\ndeclare global {\r\n    interface Window {\r\n        pollingInterval: ReturnType<typeof setInterval> | null;\r\n        lastDataHash: string | null;\r\n        currentViewCategory: string | null;\r\n        setPollingCategory: (category: string | null) => void;\r\n    }\r\n}\r\n\r\nwindow.pollingInterval = null;\r\nwindow.lastDataHash = null;\r\nwindow.currentViewCategory = null;\r\n\r\nwindow.setPollingCategory = function (category: string | null): void {\r\n    window.currentViewCategory = category;\r\n    window.lastDataHash = null;\r\n    console.log('[LiveSync] Now watching:', category);\r\n};\r\n\r\n// ============================================\r\n// LANDING PAGE\r\n// ============================================\r\n\r\nexport function showLandingPage(): void {\r\n    const container = document.getElementById('mainContent');\r\n    if (!container) return;\r\n\r\n    const categories = ['enemies', 'bosses', 'npcs', 'equipment', 'items', 'resources', 'nodes', 'environment', 'ground', 'ui', 'config', 'hero'];\r\n\r\n    container.innerHTML = `\r\n        <div style=\"padding:2rem; text-align:center;\">\r\n            <h2 style=\"margin-bottom:1rem;\"> Entity Registry Dashboard</h2>\r\n            <p style=\"color:var(--text-dim); margin-bottom:2rem;\">Select a category to view and manage entities</p>\r\n            <div style=\"display:grid; grid-template-columns:repeat(auto-fit, minmax(200px, 1fr)); gap:1rem; max-width:1000px; margin:0 auto;\">\r\n                ${categories\r\n            .map(\r\n                (cat) => `\r\n                    <button data-action=\"navigate-category\" data-category=\"${cat}\" \r\n                        style=\"padding:1.5rem; font-size:1.2rem; background:${CATEGORY_COLORS[cat] || '#666'}; \r\n                               border:none; border-radius:8px; cursor:pointer; color:white; \r\n                               display:flex; flex-direction:column; align-items:center; gap:0.5rem;\r\n                               transition:transform 0.2s, box-shadow 0.2s;\"\r\n                        onmouseover=\"this.style.transform='scale(1.05)'; this.style.boxShadow='0 4px 20px rgba(0,0,0,0.3)';\"\r\n                        onmouseout=\"this.style.transform='scale(1)'; this.style.boxShadow='none';\">\r\n                        <span style=\"font-size:2rem;\">${CATEGORY_ICONS[cat] || ''}</span>\r\n                        <span>${cat.charAt(0).toUpperCase() + cat.slice(1)}</span>\r\n                    </button>\r\n                `\r\n            )\r\n            .join('')}\r\n            </div>\r\n        </div>\r\n    `;\r\n\r\n    window.setPollingCategory(null);\r\n}\r\n\r\nexport function loadManifest(): void {\r\n    showLandingPage();\r\n}\r\n\r\nexport function showImagesView(): void {\r\n    showLandingPage();\r\n}\r\n\r\n// ============================================\r\n// CATEGORY VIEW\r\n// ============================================\r\n\r\nexport async function showCategoryView(categoryName: string, pushState: boolean = true): Promise<void> {\r\n    const container = document.getElementById('mainContent');\r\n    if (!container) return;\r\n\r\n    container.innerHTML = '<div class=\"loading\">Loading category data...</div>';\r\n    setCurrentCategoryName(categoryName);\r\n\r\n    // Always try to hide map editor first\r\n    import('@dashboard/mapEditorView').then(({ hideMapEditorView }) => hideMapEditorView());\r\n\r\n    // Update URL History\r\n    if (pushState) {\r\n        const url = new URL(window.location.href);\r\n        url.searchParams.set('category', categoryName);\r\n        url.searchParams.delete('view'); // Clear view param\r\n        window.history.pushState({ category: categoryName }, '', url.toString());\r\n    }\r\n\r\n    // Update Sidebar Active State\r\n    document.querySelectorAll('.nav-item').forEach(btn => {\r\n        const btnCat = btn.getAttribute('data-category');\r\n        // Clear all action-based buttons (like map editor) if switching to category\r\n        if (btn.dataset.action !== 'navigate-category' && btn.dataset.action !== 'toggle-config') {\r\n            btn.classList.remove('active');\r\n        }\r\n\r\n        if (btnCat === categoryName) {\r\n            btn.classList.add('active');\r\n        } else {\r\n            btn.classList.remove('active');\r\n        }\r\n    });\r\n\r\n    // 0. Save current category-specific filters before switching\r\n    if (currentCategoryName) {\r\n        saveCategoryFiltersCache(currentCategoryName, {\r\n            file: categoryFilter.file,\r\n            weaponType: categoryFilter.weaponType,\r\n            hands: categoryFilter.hands,\r\n            nodeSubtype: categoryFilter.nodeSubtype\r\n        });\r\n    }\r\n\r\n    // Restore specific filters for new category (or default to all)\r\n    // Shared filters (status, biome, tier) remains from global state\r\n    const cached = getCategoryFiltersFromCache(categoryName);\r\n    setCategoryFilterValue({\r\n        file: cached.file || 'all',\r\n        weaponType: cached.weaponType || 'all',\r\n        hands: cached.hands || 'all',\r\n        nodeSubtype: cached.nodeSubtype || 'all'\r\n    });\r\n\r\n    try {\r\n        // Load asset lookup if not loaded\r\n        await loadGlobalAssetLookup();\r\n\r\n        const data = await fetchCategory(categoryName);\r\n        setCategoryData(data);\r\n        renderCategoryView();\r\n\r\n        // Set polling for live updates\r\n        window.setPollingCategory(categoryName);\r\n    } catch (err) {\r\n        container.innerHTML = `<div class=\"error\">Error loading category: ${(err as Error).message}</div>`;\r\n    }\r\n}\r\n\r\n// ============================================\r\n// NAVIGATION\r\n// ============================================\r\n\r\nexport async function navigateToAsset(category: string, assetId: string): Promise<void> {\r\n    // Switch to category view\r\n    await showCategoryView(category);\r\n\r\n    // Wait for render and scroll to asset\r\n    // Wait for render and scroll to asset\r\n    setTimeout(() => {\r\n        // Use exact ID match as stored in dataset.id in categoryRenderer\r\n        const card = document.querySelector(`.asset-card[data-id=\"${assetId}\"]`) as HTMLElement | null;\r\n        if (card) {\r\n            card.scrollIntoView({ behavior: 'auto', block: 'center' });\r\n\r\n            // Remove class if it exists to restart animation\r\n            card.classList.remove('highlight-flash');\r\n            void card.offsetWidth; // Trigger reflow\r\n            card.classList.add('highlight-flash');\r\n\r\n            setTimeout(() => {\r\n                card.classList.remove('highlight-flash');\r\n            }, 2000);\r\n        } else {\r\n            console.warn(`[Navigation] Target card not found for ID: ${assetId}`);\r\n        }\r\n    }, 500);\r\n}\r\n\r\n// ============================================\r\n// STATS\r\n// ============================================\r\n\r\nexport function updateStats(): void {\r\n    // Stats are now rendered inline in category view\r\n    // This function is kept for compatibility\r\n}\r\n\r\n// ============================================\r\n// ACTION HELPERS\r\n// ============================================\r\n\r\nexport function approveCategoryItem(category: string, fileName: string, itemId: string): void {\r\n    updateCategoryStatus(category, fileName, itemId, 'approved');\r\n}\r\n\r\nexport function declineCategoryItem(category: string, fileName: string, itemId: string, safeId: string): void {\r\n    const noteInput = document.getElementById(`note_${safeId}`) as HTMLInputElement | null;\r\n    const note = noteInput?.value || '';\r\n    updateCategoryStatus(category, fileName, itemId, 'declined', note);\r\n}\r\n\r\nexport function remakeCategoryItem(category: string, fileName: string, itemId: string, safeId: string): void {\r\n    const noteInput = document.getElementById(`note_${safeId}`) as HTMLInputElement | null;\r\n    const note = noteInput?.value || 'Remake requested';\r\n    updateCategoryStatus(category, fileName, itemId, 'declined', `Remake: ${note}`);\r\n}\r\n\r\nexport function declineCategoryItemById(\r\n    category: string,\r\n    fileName: string,\r\n    itemId: string,\r\n    noteInputId: string\r\n): void {\r\n    const noteInput = document.getElementById(noteInputId) as HTMLInputElement | null;\r\n    const note = noteInput?.value || '';\r\n    updateCategoryStatus(category, fileName, itemId, 'declined', note);\r\n}\r\n\r\nexport function remakeCategoryItemById(\r\n    category: string,\r\n    fileName: string,\r\n    itemId: string,\r\n    noteInputId: string\r\n): void {\r\n    const noteInput = document.getElementById(noteInputId) as HTMLInputElement | null;\r\n    const note = noteInput?.value || 'Remake requested';\r\n    updateCategoryStatus(category, fileName, itemId, 'declined', `Remake: ${note}`);\r\n}\r\n\r\n// ============================================\r\n// ASSET HELPERS (for legacy assets view)\r\n// ============================================\r\n\r\nexport function approveAsset(path: string): void {\r\n    import('./api').then(({ changeStatus }) => {\r\n        changeStatus(path, 'approved').then(() => loadManifest());\r\n    });\r\n}\r\n\r\nexport function declineAsset(path: string, name: string, safeId: string): void {\r\n    const noteInput = document.getElementById(`notes_${safeId}`) as HTMLInputElement | null;\r\n    const note = noteInput?.value || '';\r\n\r\n    import('./api').then(({ changeStatus, saveNotes }) => {\r\n        changeStatus(path, 'declined').then(() => {\r\n            if (note) saveNotes(name, note);\r\n            loadManifest();\r\n        });\r\n    });\r\n}\r\n\r\nexport function declineAssetPrompt(path: string, name: string): void {\r\n    const note = prompt('Reason for declining:');\r\n    if (note) {\r\n        import('./api').then(({ changeStatus, saveNotes }) => {\r\n            changeStatus(path, 'declined').then(() => {\r\n                saveNotes(name, note);\r\n                loadManifest();\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\n// ============================================\r\n// AUTO REFRESH\r\n// ============================================\r\n\r\nlet autoRefreshInterval: ReturnType<typeof setInterval> | null = null;\r\n\r\nexport function startAutoRefresh(): void {\r\n    if (autoRefreshInterval) return;\r\n\r\n    autoRefreshInterval = setInterval(async () => {\r\n        if (!window.currentViewCategory) return;\r\n\r\n        try {\r\n            const response = await fetch('/api/get_category?_=' + Date.now(), {\r\n                method: 'POST',\r\n                headers: { 'Content-Type': 'application/json', 'Cache-Control': 'no-cache' },\r\n                body: JSON.stringify({ category: window.currentViewCategory }),\r\n            });\r\n            const data = await response.json();\r\n            const newHash = JSON.stringify(data.entities || []);\r\n\r\n            if (window.lastDataHash !== null && newHash !== window.lastDataHash) {\r\n                console.log('[LiveSync] Data changed, refreshing...');\r\n                setCategoryData(data);\r\n                renderCategoryView();\r\n            }\r\n            window.lastDataHash = newHash;\r\n        } catch {\r\n            // Ignore polling errors\r\n        }\r\n    }, 1500);\r\n}\r\n\r\nexport function stopAutoRefresh(): void {\r\n    if (autoRefreshInterval) {\r\n        clearInterval(autoRefreshInterval);\r\n        autoRefreshInterval = null;\r\n    }\r\n}\r\n\r\nexport function showConfigView(pushState: boolean = true): void {\r\n    const mainContent = document.getElementById('mainContent');\r\n    // Ensure map editor is hidden\r\n    import('@dashboard/mapEditorView').then(({ hideMapEditorView }) => hideMapEditorView());\r\n\r\n    if (mainContent) {\r\n        // Update URL History\r\n        if (pushState) {\r\n            const url = new URL(window.location.href);\r\n            url.searchParams.set('view', 'config');\r\n            url.searchParams.delete('category'); // Clear category param\r\n            window.history.pushState({ view: 'config' }, '', url.toString());\r\n        }\r\n\r\n        // Hide stats and filters when showing config\r\n        const stats = document.querySelector('.stats') as HTMLElement;\r\n        const stickyBar = document.querySelector('.sticky-bar') as HTMLElement;\r\n        if (stats) stats.style.display = 'none';\r\n        if (stickyBar) stickyBar.style.display = 'none';\r\n\r\n        // Sidebar Active State\r\n        document.querySelectorAll('.nav-item').forEach(btn => {\r\n            btn.classList.remove('active');\r\n            if (btn.getAttribute('data-action') === 'toggle-config') {\r\n                btn.classList.add('active');\r\n            }\r\n        });\r\n\r\n        renderConfigView(mainContent);\r\n\r\n        // Stop polling when in config\r\n        window.setPollingCategory(null);\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\decline_notes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\enemies\\_config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\enemies\\asset_queue.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\environment\\_config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\environment\\asset_queue.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\equipment\\_config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\equipment\\asset_queue.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\items\\_config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\items\\asset_queue.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\items\\bone.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\items\\leather.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\items\\mechanical.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\items\\metal.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\items\\wood.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\nodes\\_config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\nodes\\asset_queue.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\npcs\\_config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\npcs\\asset_queue.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\npcs\\merchants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\props\\_config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\props\\asset_queue.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\props\\flora.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\resources\\_config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\resources\\asset_queue.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\resources\\food.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\resources\\minerals.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\resources\\salvage.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\resources\\scraps.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\scripts\\fix_entity_syntax.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\scripts\\update_entity_sizes.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\sfx_regeneration_queue.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\ui\\_config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\ui\\asset_queue.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\ui\\icons.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\vfx\\_config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\vfx\\asset_queue.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\tools\\vfx\\combat.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\vite.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Anthony\\.gemini\\antigravity\\scratch\\jurassic-knights-valley\\vitest.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
